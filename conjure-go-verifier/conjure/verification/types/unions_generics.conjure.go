// This file was generated by Conjure and should not be manually edited.

//go:build go1.18

package types

import (
	"context"
	"fmt"
)

type UnionWithT[T any] Union

func (u *UnionWithT[T]) Accept(ctx context.Context, v UnionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "stringExample":
		if u.stringExample == nil {
			return result, fmt.Errorf("field \"stringExample\" is required")
		}
		return v.VisitStringExample(ctx, *u.stringExample)
	case "set":
		if u.set == nil {
			return result, fmt.Errorf("field \"set\" is required")
		}
		return v.VisitSet(ctx, *u.set)
	case "thisFieldIsAnInteger":
		if u.thisFieldIsAnInteger == nil {
			return result, fmt.Errorf("field \"thisFieldIsAnInteger\" is required")
		}
		return v.VisitThisFieldIsAnInteger(ctx, *u.thisFieldIsAnInteger)
	case "alsoAnInteger":
		if u.alsoAnInteger == nil {
			return result, fmt.Errorf("field \"alsoAnInteger\" is required")
		}
		return v.VisitAlsoAnInteger(ctx, *u.alsoAnInteger)
	case "if":
		if u.if_ == nil {
			return result, fmt.Errorf("field \"if\" is required")
		}
		return v.VisitIf(ctx, *u.if_)
	case "new":
		if u.new == nil {
			return result, fmt.Errorf("field \"new\" is required")
		}
		return v.VisitNew(ctx, *u.new)
	case "interface":
		if u.interface_ == nil {
			return result, fmt.Errorf("field \"interface\" is required")
		}
		return v.VisitInterface(ctx, *u.interface_)
	}
}

type UnionVisitorWithT[T any] interface {
	VisitStringExample(ctx context.Context, v StringExample) (T, error)
	VisitSet(ctx context.Context, v []string) (T, error)
	VisitThisFieldIsAnInteger(ctx context.Context, v int) (T, error)
	VisitAlsoAnInteger(ctx context.Context, v int) (T, error)
	VisitIf(ctx context.Context, v int) (T, error)
	VisitNew(ctx context.Context, v int) (T, error)
	VisitInterface(ctx context.Context, v int) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
