// This file was generated by Conjure and should not be manually edited.

package api

import (
	"context"
	"fmt"

	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type ExampleUnion struct {
	typ       string
	str       *string
	other     *string
	myMap     *map[string][]int
	recursive *ExampleUnion
}

type exampleUnionDeserializer struct {
	Type      string            `json:"type"`
	Str       *string           `json:"str"`
	Other     *string           `json:"other"`
	MyMap     *map[string][]int `json:"myMap"`
	Recursive *ExampleUnion     `json:"recursive"`
}

func (u *exampleUnionDeserializer) toStruct() ExampleUnion {
	return ExampleUnion{typ: u.Type, str: u.Str, other: u.Other, myMap: u.MyMap, recursive: u.Recursive}
}

func (u *ExampleUnion) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %s", u.typ)
	case "str":
		return struct {
			Type string `json:"type"`
			Str  string `json:"str"`
		}{Type: "str", Str: *u.str}, nil
	case "other":
		return struct {
			Type  string `json:"type"`
			Other string `json:"other"`
		}{Type: "other", Other: *u.other}, nil
	case "myMap":
		return struct {
			Type  string           `json:"type"`
			MyMap map[string][]int `json:"myMap"`
		}{Type: "myMap", MyMap: *u.myMap}, nil
	case "recursive":
		return struct {
			Type      string       `json:"type"`
			Recursive ExampleUnion `json:"recursive"`
		}{Type: "recursive", Recursive: *u.recursive}, nil
	}
}

func (u ExampleUnion) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ExampleUnion) UnmarshalJSON(data []byte) error {
	var deser exampleUnionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	return nil
}

func (u ExampleUnion) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ExampleUnion) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ExampleUnion) Accept(v ExampleUnionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "str":
		return v.VisitStr(*u.str)
	case "other":
		return v.VisitOther(*u.other)
	case "myMap":
		return v.VisitMyMap(*u.myMap)
	case "recursive":
		return v.VisitRecursive(*u.recursive)
	}
}

type ExampleUnionVisitor interface {
	VisitStr(v string) error
	VisitOther(v string) error
	VisitMyMap(v map[string][]int) error
	VisitRecursive(v ExampleUnion) error
	VisitUnknown(typeName string) error
}

func (u *ExampleUnion) AcceptWithContext(ctx context.Context, v ExampleUnionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "str":
		return v.VisitStrWithContext(ctx, *u.str)
	case "other":
		return v.VisitOtherWithContext(ctx, *u.other)
	case "myMap":
		return v.VisitMyMapWithContext(ctx, *u.myMap)
	case "recursive":
		return v.VisitRecursiveWithContext(ctx, *u.recursive)
	}
}

type ExampleUnionVisitorWithContext interface {
	VisitStrWithContext(ctx context.Context, v string) error
	VisitOtherWithContext(ctx context.Context, v string) error
	VisitMyMapWithContext(ctx context.Context, v map[string][]int) error
	VisitRecursiveWithContext(ctx context.Context, v ExampleUnion) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewExampleUnionFromStr(v string) ExampleUnion {
	return ExampleUnion{typ: "str", str: &v}
}

func NewExampleUnionFromOther(v string) ExampleUnion {
	return ExampleUnion{typ: "other", other: &v}
}

func NewExampleUnionFromMyMap(v map[string][]int) ExampleUnion {
	return ExampleUnion{typ: "myMap", myMap: &v}
}

func NewExampleUnionFromRecursive(v ExampleUnion) ExampleUnion {
	return ExampleUnion{typ: "recursive", recursive: &v}
}

type OtherUnion struct {
	typ   string
	str   *string
	myMap *map[string]int
}

type otherUnionDeserializer struct {
	Type  string          `json:"type"`
	Str   *string         `json:"str"`
	MyMap *map[string]int `json:"myMap"`
}

func (u *otherUnionDeserializer) toStruct() OtherUnion {
	return OtherUnion{typ: u.Type, str: u.Str, myMap: u.MyMap}
}

func (u *OtherUnion) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %s", u.typ)
	case "str":
		return struct {
			Type string `json:"type"`
			Str  string `json:"str"`
		}{Type: "str", Str: *u.str}, nil
	case "myMap":
		return struct {
			Type  string         `json:"type"`
			MyMap map[string]int `json:"myMap"`
		}{Type: "myMap", MyMap: *u.myMap}, nil
	}
}

func (u OtherUnion) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *OtherUnion) UnmarshalJSON(data []byte) error {
	var deser otherUnionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	return nil
}

func (u OtherUnion) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *OtherUnion) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *OtherUnion) Accept(v OtherUnionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "str":
		return v.VisitStr(*u.str)
	case "myMap":
		return v.VisitMyMap(*u.myMap)
	}
}

type OtherUnionVisitor interface {
	VisitStr(v string) error
	VisitMyMap(v map[string]int) error
	VisitUnknown(typeName string) error
}

func (u *OtherUnion) AcceptWithContext(ctx context.Context, v OtherUnionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "str":
		return v.VisitStrWithContext(ctx, *u.str)
	case "myMap":
		return v.VisitMyMapWithContext(ctx, *u.myMap)
	}
}

type OtherUnionVisitorWithContext interface {
	VisitStrWithContext(ctx context.Context, v string) error
	VisitMyMapWithContext(ctx context.Context, v map[string]int) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewOtherUnionFromStr(v string) OtherUnion {
	return OtherUnion{typ: "str", str: &v}
}

func NewOtherUnionFromMyMap(v map[string]int) OtherUnion {
	return OtherUnion{typ: "myMap", myMap: &v}
}
