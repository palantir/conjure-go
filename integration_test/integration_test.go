// Copyright (c) 2018 Palantir Technologies. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package integration_test

import (
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path"
	"strings"
	"testing"

	"github.com/nmiyake/pkg/dirs"
	"github.com/palantir/godel/pkg/products/v2"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestCLI(t *testing.T) {
	tmpDir, cleanup, err := dirs.TempDir(".", "TestCLIProject-")
	defer cleanup()
	require.NoError(t, err)

	cli, err := products.Bin("conjure-go")
	require.NoError(t, err)

	for currCaseNum, tc := range []struct {
		name   string
		irFile string
		want   map[string]string
	}{
		{
			name:   "base case",
			irFile: "testdata/string-alias.json",
			want: map[string]string{
				"test/api/aliases.conjure.go": stringAliasFile,
			},
		},
	} {
		currCaseTmpDir := path.Join(tmpDir, fmt.Sprintf("case-%d", currCaseNum))
		err := os.Mkdir(currCaseTmpDir, 0755)
		require.NoError(t, err, "Case %d: %s", currCaseNum, tc.name)

		outputDir := path.Join(currCaseTmpDir, "output")
		err = os.Mkdir(outputDir, 0755)
		require.NoError(t, err, "Case %d: %s", currCaseNum, tc.name)

		cmd := exec.Command(cli, "--output", outputDir, tc.irFile)
		output, err := cmd.CombinedOutput()
		require.NoError(t, err, "command %v failed with output:\n%s", cmd.Args, string(output))
		for k, wantSrc := range tc.want {
			wantSrc = strings.Replace(wantSrc, "{{currCaseTmpDir}}", path.Join(currCaseTmpDir, "output"), -1)
			bytes, err := ioutil.ReadFile(path.Join(currCaseTmpDir, "output", k))
			require.NoError(t, err)
			gotSrc := string(bytes)
			assert.Equal(t, strings.Split(wantSrc, "\n"), strings.Split(gotSrc, "\n"), "Case %d: %s: Unexpected content for file %s:\n%s\nWanted:\n%s", currCaseNum, tc.name, k, gotSrc, wantSrc)
		}
	}
}

func TestCLIInModule(t *testing.T) {
	tmpDir, cleanup, err := dirs.TempDir("", "TestCLIProject-")
	defer cleanup()
	require.NoError(t, err)

	cli, err := products.Bin("conjure-go")
	require.NoError(t, err)

	for currCaseNum, tc := range []struct {
		name   string
		irFile string
		want   map[string]string
	}{
		{
			name:   "base case",
			irFile: "testdata/string-alias.json",
			want: map[string]string{
				"test/api/aliases.conjure.go": stringAliasFile,
			},
		},
	} {
		currCaseTmpDir := path.Join(tmpDir, fmt.Sprintf("case-%d", currCaseNum))
		err := os.Mkdir(currCaseTmpDir, 0755)
		require.NoError(t, err, "Case %d: %s", currCaseNum, tc.name)
		modulePath := fmt.Sprintf("github.com/test-org/test-repo-%d", currCaseNum)
		err = ioutil.WriteFile(path.Join(currCaseTmpDir, "go.mod"), []byte("module "+modulePath), 0644)
		require.NoError(t, err, "Case %d: %s", currCaseNum, tc.name)

		outputDir := path.Join(currCaseTmpDir, "output")
		err = os.Mkdir(outputDir, 0755)
		require.NoError(t, err, "Case %d: %s", currCaseNum, tc.name)

		cmd := exec.Command(cli, "--output", outputDir, tc.irFile)
		output, err := cmd.CombinedOutput()
		require.NoError(t, err, "command %v failed with output:\n%s", cmd.Args, string(output))
		for k, wantSrc := range tc.want {
			wantSrc = strings.Replace(wantSrc, "{{currModulePath}}", path.Join(modulePath, "output"), -1)
			bytes, err := ioutil.ReadFile(path.Join(currCaseTmpDir, "output", k))
			require.NoError(t, err)
			gotSrc := string(bytes)
			assert.Equal(t, strings.Split(wantSrc, "\n"), strings.Split(gotSrc, "\n"), "Case %d: %s: Unexpected content for file %s:\n%s\nWanted:\n%s", currCaseNum, tc.name, k, gotSrc, wantSrc)
		}
	}
}

const stringAliasFile = `// This file was generated by Conjure and should not be manually edited.

package api

import (
	"context"

	safejson "github.com/palantir/pkg/safejson"
	werror "github.com/palantir/witchcraft-go-error"
	gjson "github.com/tidwall/gjson"
)

type StringAlias string

func (a StringAlias) String() string {
	return string(a)
}

func (a *StringAlias) UnmarshalString(data string) error {
	rawStringAlias := data
	*a = StringAlias(rawStringAlias)
	return nil
}

func (a StringAlias) MarshalJSON() ([]byte, error) {
	size, err := a.JSONSize()
	if err != nil {
		return nil, err
	}
	return a.AppendJSON(make([]byte, 0, size))
}

func (a StringAlias) AppendJSON(out []byte) ([]byte, error) {
	out = safejson.AppendQuotedString(out, string(a))
	return out, nil
}

func (a StringAlias) JSONSize() (int, error) {
	var out int
	out += safejson.QuotedStringLength(string(a))
	return out, nil
}

func (a *StringAlias) UnmarshalJSON(data []byte) error {
	ctx := context.TODO()
	if !gjson.ValidBytes(data) {
		return werror.ErrorWithContextParams(ctx, "invalid JSON for StringAlias")
	}
	return a.unmarshalJSONResult(ctx, gjson.ParseBytes(data))
}

func (a *StringAlias) UnmarshalJSONString(data string) error {
	ctx := context.TODO()
	if !gjson.Valid(data) {
		return werror.ErrorWithContextParams(ctx, "invalid JSON for StringAlias")
	}
	return a.unmarshalJSONResult(ctx, gjson.Parse(data))
}

func (a *StringAlias) unmarshalJSONResult(ctx context.Context, value gjson.Result) error {
	var rawStringAlias string
	var err error
	if value.Type != gjson.String {
		err = werror.ErrorWithContextParams(ctx, "StringAlias expected JSON string")
		return err
	}
	rawStringAlias = value.Str
	*a = StringAlias(rawStringAlias)
	return nil
}
`
