// Copyright (c) 2018 Palantir Technologies. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package integration_test

import (
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path"
	"strings"
	"testing"

	"github.com/palantir/godel/pkg/products/v2"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestCLI(t *testing.T) {
	tmpDir := t.TempDir()

	cli, err := products.Bin("conjure-go")
	require.NoError(t, err)

	for currCaseNum, tc := range []struct {
		name   string
		irFile string
		want   map[string]string
	}{
		{
			name:   "base case",
			irFile: "testdata/minimal-api.json",
			want: map[string]string{
				"foundry/catalog/api/datasets/structs.conjure.go": `// This file was generated by Conjure and should not be manually edited.

package datasets

import (
	"encoding/json"

	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	"github.com/palantir/pkg/rid"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	wparams "github.com/palantir/witchcraft-go-params"
	"github.com/tidwall/gjson"
)

type Dataset struct {
	FileSystemId string ` + "`" + `json:"fileSystemId"` + "`" + `
	// Uniquely identifies this dataset.
	Rid rid.ResourceIdentifier ` + "`" + `json:"rid"` + "`" + `
}

func (o Dataset) MarshalJSON() ([]byte, error) {
	type DatasetAlias Dataset
	return safejson.Marshal(DatasetAlias(o))
}

func (o Dataset) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

// UnmarshalJSON deserializes data, ignoring unrecognized keys.
// Prefer UnmarshalJSONString if data is already in string form to avoid an extra copy.
func (o *Dataset) UnmarshalJSON(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

// UnmarshalJSONString deserializes data, ignoring unrecognized keys.
func (o *Dataset) UnmarshalJSONString(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), false)
}

// UnmarshalJSONStrict deserializes data, rejecting unrecognized keys.
// Prefer UnmarshalJSONStringStrict if data is already in string form to avoid an extra copy.
func (o *Dataset) UnmarshalJSONStrict(data []byte) error {
	if !gjson.ValidBytes(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), true)
}

// UnmarshalJSONStringStrict deserializes data, rejecting unrecognized keys.
func (o *Dataset) UnmarshalJSONStringStrict(data string) error {
	if !gjson.Valid(data) {
		return errors.NewInvalidArgument()
	}
	return o.unmarshalGJSON(gjson.Parse(data), true)
}

// UnmarshalYAML implements yaml.Unmarshaler. It converts the YAML to JSON, then runs UnmarshalJSON.
func (o *Dataset) UnmarshalYAML(unmarshal func(interface{}) error) error {
	data, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return errors.WrapWithInvalidArgument(err)
	}
	return o.unmarshalGJSON(gjson.ParseBytes(data), false)
}

func (o *Dataset) unmarshalGJSON(value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return errors.NewInvalidArgument()
	}
	var seenFileSystemId bool
	var seenRid bool
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		if value.Type == gjson.Null {
			return true
		}
		switch key.Str {
		case "fileSystemId":
			seenFileSystemId = true
			if value.Type != gjson.String {
				err = errors.NewInvalidArgument()
				return false
			}
			o.FileSystemId = value.Str
		case "rid":
			seenRid = true
			if value.Type != gjson.String {
				err = errors.NewInvalidArgument()
				return false
			}
			o.Rid, err = rid.ParseRID(value.Str)
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.String())
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seenFileSystemId {
		missingFields = append(missingFields, "fileSystemId")
	}
	if !seenRid {
		missingFields = append(missingFields, "rid")
	}
	if len(missingFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("missingFields", missingFields))
	}
	if strict && len(unrecognizedFields) > 0 {
		return errors.NewInvalidArgument(wparams.NewSafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}
`,
			},
		},
	} {
		currCaseTmpDir := path.Join(tmpDir, fmt.Sprintf("case-%d", currCaseNum))
		err := os.Mkdir(currCaseTmpDir, 0755)
		require.NoError(t, err, "Case %d: %s", currCaseNum, tc.name)

		outputDir := path.Join(currCaseTmpDir, "output")
		err = os.Mkdir(outputDir, 0755)
		require.NoError(t, err, "Case %d: %s", currCaseNum, tc.name)

		cmd := exec.Command(cli, "--output", outputDir, tc.irFile)
		output, err := cmd.CombinedOutput()
		require.NoError(t, err, "command %v failed with output:\n%s", cmd.Args, string(output))
		for k, wantSrc := range tc.want {
			wantSrc = strings.Replace(wantSrc, "{{currCaseTmpDir}}", path.Join(currCaseTmpDir, "output"), -1)
			bytes, err := ioutil.ReadFile(path.Join(currCaseTmpDir, "output", k))
			require.NoError(t, err)
			gotSrc := string(bytes)
			assert.Equal(t, strings.Split(wantSrc, "\n"), strings.Split(gotSrc, "\n"), "Case %d: %s: Unexpected content for file %s:\n%s\nWanted:\n%s", currCaseNum, tc.name, k, gotSrc, wantSrc)
		}
	}
}

func TestCLIInModule(t *testing.T) {
	tmpDir := t.TempDir()

	cli, err := products.Bin("conjure-go")
	require.NoError(t, err)

	for currCaseNum, tc := range []struct {
		name   string
		irFile string
		want   map[string]string
	}{
		{
			name:   "base case",
			irFile: "testdata/minimal-api.json",
			want: map[string]string{
				"foundry/catalog/api/datasets/structs.conjure.go": `// This file was generated by Conjure and should not be manually edited.

package datasets

import (
	"github.com/palantir/pkg/rid"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type Dataset struct {
	FileSystemId string ` + "`" + `json:"fileSystemId"` + "`" + `
	// Uniquely identifies this dataset.
	Rid rid.ResourceIdentifier ` + "`" + `json:"rid" conjure-docs:"Uniquely identifies this dataset."` + "`" + `
}

func (o Dataset) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Dataset) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}
`,
			},
		},
	} {
		currCaseTmpDir := path.Join(tmpDir, fmt.Sprintf("case-%d", currCaseNum))
		err := os.Mkdir(currCaseTmpDir, 0755)
		require.NoError(t, err, "Case %d: %s", currCaseNum, tc.name)
		modulePath := fmt.Sprintf("github.com/test-org/test-repo-%d", currCaseNum)
		err = ioutil.WriteFile(path.Join(currCaseTmpDir, "go.mod"), []byte("module "+modulePath), 0644)
		require.NoError(t, err, "Case %d: %s", currCaseNum, tc.name)

		outputDir := path.Join(currCaseTmpDir, "output")
		err = os.Mkdir(outputDir, 0755)
		require.NoError(t, err, "Case %d: %s", currCaseNum, tc.name)

		cmd := exec.Command(cli, "--output", outputDir, tc.irFile)
		output, err := cmd.CombinedOutput()
		require.NoError(t, err, "command %v failed with output:\n%s", cmd.Args, string(output))
		for k, wantSrc := range tc.want {
			wantSrc = strings.Replace(wantSrc, "{{currModulePath}}", path.Join(modulePath, "output"), -1)
			bytes, err := ioutil.ReadFile(path.Join(currCaseTmpDir, "output", k))
			require.NoError(t, err)
			gotSrc := string(bytes)
			assert.Equal(t, strings.Split(wantSrc, "\n"), strings.Split(gotSrc, "\n"), "Case %d: %s: Unexpected content for file %s:\n%s\nWanted:\n%s", currCaseNum, tc.name, k, gotSrc, wantSrc)
		}
	}
}
