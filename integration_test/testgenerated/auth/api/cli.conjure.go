// This file was generated by Conjure and should not be manually edited.

package api

import (
	"context"
	"fmt"
	"io"
	"os"

	"github.com/palantir/conjure-go-runtime/v2/conjure-go-client/httpclient"
	"github.com/palantir/pkg/bearertoken"
	werror "github.com/palantir/witchcraft-go-error"
	"github.com/palantir/witchcraft-go-logging/wlog"
	wlogzap "github.com/palantir/witchcraft-go-logging/wlog-zap"
	"github.com/palantir/witchcraft-go-logging/wlog/evtlog/evt2log"
	"github.com/palantir/witchcraft-go-logging/wlog/svclog/svc1log"
	"github.com/palantir/witchcraft-go-logging/wlog/trclog/trc1log"
	"github.com/palantir/witchcraft-go-tracing/wtracing"
	"github.com/palantir/witchcraft-go-tracing/wzipkin"
	"github.com/spf13/cobra"
	"github.com/spf13/pflag"
	"gopkg.in/yaml.v3"
)

type CLIConfig struct {
	Client httpclient.ClientConfig `yaml:",inline"`
}

// Commands for BothAuthService

type CLIBothAuthServiceClientProvider interface {
	Get(ctx context.Context, flags *pflag.FlagSet) (BothAuthServiceClient, error)
}

type defaultCLIBothAuthServiceClientProvider struct{}

func NewDefaultCLIBothAuthServiceClientProvider() CLIBothAuthServiceClientProvider {
	return defaultCLIBothAuthServiceClientProvider{}
}

func (d defaultCLIBothAuthServiceClientProvider) Get(ctx context.Context, flags *pflag.FlagSet) (BothAuthServiceClient, error) {
	conf, err := loadCLIConfig(ctx, flags)
	if err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "failed to load CLI configuration file")
	}
	client, err := httpclient.NewClient(httpclient.WithConfig(conf.Client))
	if err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "failed to create client with provided config")
	}
	return NewBothAuthServiceClient(client), nil
}

type BothAuthServiceCLICommand struct {
	clientProvider CLIBothAuthServiceClientProvider
}

func NewBothAuthServiceCLICommand() *cobra.Command {
	return NewBothAuthServiceCLICommandWithClientProvider(NewDefaultCLIBothAuthServiceClientProvider())
}

func NewBothAuthServiceCLICommandWithClientProvider(clientProvider CLIBothAuthServiceClientProvider) *cobra.Command {
	rootCmd := &cobra.Command{
		Short: "Runs commands on the BothAuthService",
		Use:   "bothAuthService",
	}
	rootCmd.PersistentFlags().String("conf", "var/conf/configuration.yml", "The configuration file is optional. The default path is ./var/conf/configuration.yml.")
	rootCmd.PersistentFlags().BoolP("verbose", "v", false, "Enables verbose mode for debugging client connections.")

	cliCommand := BothAuthServiceCLICommand{clientProvider: clientProvider}

	bothAuthService_Default_Cmd := &cobra.Command{
		RunE:  cliCommand.bothAuthService_Default_CmdRun,
		Short: "Calls the default endpoint.",
		Use:   "default",
	}
	rootCmd.AddCommand(bothAuthService_Default_Cmd)
	bothAuthService_Default_Cmd.Flags().String("bearer_token", "", "bearer_token is a required field.")

	bothAuthService_Cookie_Cmd := &cobra.Command{
		RunE:  cliCommand.bothAuthService_Cookie_CmdRun,
		Short: "Calls the cookie endpoint.",
		Use:   "cookie",
	}
	rootCmd.AddCommand(bothAuthService_Cookie_Cmd)
	bothAuthService_Cookie_Cmd.Flags().String("bearer_token", "", "bearer_token is a required field.")

	bothAuthService_None_Cmd := &cobra.Command{
		RunE:  cliCommand.bothAuthService_None_CmdRun,
		Short: "Calls the none endpoint.",
		Use:   "none",
	}
	rootCmd.AddCommand(bothAuthService_None_Cmd)

	bothAuthService_WithArg_Cmd := &cobra.Command{
		RunE:  cliCommand.bothAuthService_WithArg_CmdRun,
		Short: "Calls the withArg endpoint.",
		Use:   "withArg",
	}
	rootCmd.AddCommand(bothAuthService_WithArg_Cmd)
	bothAuthService_WithArg_Cmd.Flags().String("arg", "", "Required. ")
	bothAuthService_WithArg_Cmd.Flags().String("bearer_token", "", "bearer_token is a required field.")

	return rootCmd
}

func (c BothAuthServiceCLICommand) bothAuthService_Default_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	bearer_tokenRaw, err := flags.GetString("bearer_token")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument __authVar")
	}
	if bearer_tokenRaw == "" {
		return werror.ErrorWithContextParams(ctx, "bearer_token is a required argument")
	}
	__authVarArg := bearertoken.Token(bearer_tokenRaw)
	result, err := client.Default(ctx, __authVarArg)
	if err != nil {
		return err
	}
	fmt.Fprintf(cmd.OutOrStdout(), "%v\n", result)
	return nil
}

func (c BothAuthServiceCLICommand) bothAuthService_Cookie_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	bearer_tokenRaw, err := flags.GetString("bearer_token")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument __authVar")
	}
	if bearer_tokenRaw == "" {
		return werror.ErrorWithContextParams(ctx, "bearer_token is a required argument")
	}
	__authVarArg := bearertoken.Token(bearer_tokenRaw)
	return client.Cookie(ctx, __authVarArg)
}

func (c BothAuthServiceCLICommand) bothAuthService_None_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	return client.None(ctx)
}

func (c BothAuthServiceCLICommand) bothAuthService_WithArg_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	bearer_tokenRaw, err := flags.GetString("bearer_token")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument __authVar")
	}
	if bearer_tokenRaw == "" {
		return werror.ErrorWithContextParams(ctx, "bearer_token is a required argument")
	}
	__authVarArg := bearertoken.Token(bearer_tokenRaw)
	argRaw, err := flags.GetString("arg")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument arg")
	}
	if argRaw == "" {
		return werror.ErrorWithContextParams(ctx, "arg is a required argument")
	}
	argArg := argRaw

	return client.WithArg(ctx, __authVarArg, argArg)
}

// Commands for CookieAuthService

type CLICookieAuthServiceClientProvider interface {
	Get(ctx context.Context, flags *pflag.FlagSet) (CookieAuthServiceClient, error)
}

type defaultCLICookieAuthServiceClientProvider struct{}

func NewDefaultCLICookieAuthServiceClientProvider() CLICookieAuthServiceClientProvider {
	return defaultCLICookieAuthServiceClientProvider{}
}

func (d defaultCLICookieAuthServiceClientProvider) Get(ctx context.Context, flags *pflag.FlagSet) (CookieAuthServiceClient, error) {
	conf, err := loadCLIConfig(ctx, flags)
	if err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "failed to load CLI configuration file")
	}
	client, err := httpclient.NewClient(httpclient.WithConfig(conf.Client))
	if err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "failed to create client with provided config")
	}
	return NewCookieAuthServiceClient(client), nil
}

type CookieAuthServiceCLICommand struct {
	clientProvider CLICookieAuthServiceClientProvider
}

func NewCookieAuthServiceCLICommand() *cobra.Command {
	return NewCookieAuthServiceCLICommandWithClientProvider(NewDefaultCLICookieAuthServiceClientProvider())
}

func NewCookieAuthServiceCLICommandWithClientProvider(clientProvider CLICookieAuthServiceClientProvider) *cobra.Command {
	rootCmd := &cobra.Command{
		Short: "Runs commands on the CookieAuthService",
		Use:   "cookieAuthService",
	}
	rootCmd.PersistentFlags().String("conf", "var/conf/configuration.yml", "The configuration file is optional. The default path is ./var/conf/configuration.yml.")
	rootCmd.PersistentFlags().BoolP("verbose", "v", false, "Enables verbose mode for debugging client connections.")

	cliCommand := CookieAuthServiceCLICommand{clientProvider: clientProvider}

	cookieAuthService_Cookie_Cmd := &cobra.Command{
		RunE:  cliCommand.cookieAuthService_Cookie_CmdRun,
		Short: "Calls the cookie endpoint.",
		Use:   "cookie",
	}
	rootCmd.AddCommand(cookieAuthService_Cookie_Cmd)
	cookieAuthService_Cookie_Cmd.Flags().String("bearer_token", "", "bearer_token is a required field.")

	return rootCmd
}

func (c CookieAuthServiceCLICommand) cookieAuthService_Cookie_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	bearer_tokenRaw, err := flags.GetString("bearer_token")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument __authVar")
	}
	if bearer_tokenRaw == "" {
		return werror.ErrorWithContextParams(ctx, "bearer_token is a required argument")
	}
	__authVarArg := bearertoken.Token(bearer_tokenRaw)
	return client.Cookie(ctx, __authVarArg)
}

// Commands for HeaderAuthService

type CLIHeaderAuthServiceClientProvider interface {
	Get(ctx context.Context, flags *pflag.FlagSet) (HeaderAuthServiceClient, error)
}

type defaultCLIHeaderAuthServiceClientProvider struct{}

func NewDefaultCLIHeaderAuthServiceClientProvider() CLIHeaderAuthServiceClientProvider {
	return defaultCLIHeaderAuthServiceClientProvider{}
}

func (d defaultCLIHeaderAuthServiceClientProvider) Get(ctx context.Context, flags *pflag.FlagSet) (HeaderAuthServiceClient, error) {
	conf, err := loadCLIConfig(ctx, flags)
	if err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "failed to load CLI configuration file")
	}
	client, err := httpclient.NewClient(httpclient.WithConfig(conf.Client))
	if err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "failed to create client with provided config")
	}
	return NewHeaderAuthServiceClient(client), nil
}

type HeaderAuthServiceCLICommand struct {
	clientProvider CLIHeaderAuthServiceClientProvider
}

func NewHeaderAuthServiceCLICommand() *cobra.Command {
	return NewHeaderAuthServiceCLICommandWithClientProvider(NewDefaultCLIHeaderAuthServiceClientProvider())
}

func NewHeaderAuthServiceCLICommandWithClientProvider(clientProvider CLIHeaderAuthServiceClientProvider) *cobra.Command {
	rootCmd := &cobra.Command{
		Short: "Runs commands on the HeaderAuthService",
		Use:   "headerAuthService",
	}
	rootCmd.PersistentFlags().String("conf", "var/conf/configuration.yml", "The configuration file is optional. The default path is ./var/conf/configuration.yml.")
	rootCmd.PersistentFlags().BoolP("verbose", "v", false, "Enables verbose mode for debugging client connections.")

	cliCommand := HeaderAuthServiceCLICommand{clientProvider: clientProvider}

	headerAuthService_Default_Cmd := &cobra.Command{
		RunE:  cliCommand.headerAuthService_Default_CmdRun,
		Short: "Calls the default endpoint.",
		Use:   "default",
	}
	rootCmd.AddCommand(headerAuthService_Default_Cmd)
	headerAuthService_Default_Cmd.Flags().String("bearer_token", "", "bearer_token is a required field.")

	headerAuthService_Binary_Cmd := &cobra.Command{
		RunE:  cliCommand.headerAuthService_Binary_CmdRun,
		Short: "Calls the binary endpoint.",
		Use:   "binary",
	}
	rootCmd.AddCommand(headerAuthService_Binary_Cmd)
	headerAuthService_Binary_Cmd.Flags().String("bearer_token", "", "bearer_token is a required field.")

	headerAuthService_BinaryOptional_Cmd := &cobra.Command{
		RunE:  cliCommand.headerAuthService_BinaryOptional_CmdRun,
		Short: "Calls the binaryOptional endpoint.",
		Use:   "binaryOptional",
	}
	rootCmd.AddCommand(headerAuthService_BinaryOptional_Cmd)
	headerAuthService_BinaryOptional_Cmd.Flags().String("bearer_token", "", "bearer_token is a required field.")

	return rootCmd
}

func (c HeaderAuthServiceCLICommand) headerAuthService_Default_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	bearer_tokenRaw, err := flags.GetString("bearer_token")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument __authVar")
	}
	if bearer_tokenRaw == "" {
		return werror.ErrorWithContextParams(ctx, "bearer_token is a required argument")
	}
	__authVarArg := bearertoken.Token(bearer_tokenRaw)
	result, err := client.Default(ctx, __authVarArg)
	if err != nil {
		return err
	}
	fmt.Fprintf(cmd.OutOrStdout(), "%v\n", result)
	return nil
}

func (c HeaderAuthServiceCLICommand) headerAuthService_Binary_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	bearer_tokenRaw, err := flags.GetString("bearer_token")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument __authVar")
	}
	if bearer_tokenRaw == "" {
		return werror.ErrorWithContextParams(ctx, "bearer_token is a required argument")
	}
	__authVarArg := bearertoken.Token(bearer_tokenRaw)
	result, err := client.Binary(ctx, __authVarArg)
	if err != nil {
		return err
	}
	_, err = io.Copy(cmd.OutOrStdout(), result)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to write result bytes to stdout")
	}
	return result.Close()
}

func (c HeaderAuthServiceCLICommand) headerAuthService_BinaryOptional_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	bearer_tokenRaw, err := flags.GetString("bearer_token")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument __authVar")
	}
	if bearer_tokenRaw == "" {
		return werror.ErrorWithContextParams(ctx, "bearer_token is a required argument")
	}
	__authVarArg := bearertoken.Token(bearer_tokenRaw)
	result, err := client.BinaryOptional(ctx, __authVarArg)
	if err != nil {
		return err
	}
	if result == nil {
		return nil
	}
	resultDeref := *result
	_, err = io.Copy(cmd.OutOrStdout(), resultDeref)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to write result bytes to stdout")
	}
	return resultDeref.Close()
}

// Commands for SomeHeaderAuthService

type CLISomeHeaderAuthServiceClientProvider interface {
	Get(ctx context.Context, flags *pflag.FlagSet) (SomeHeaderAuthServiceClient, error)
}

type defaultCLISomeHeaderAuthServiceClientProvider struct{}

func NewDefaultCLISomeHeaderAuthServiceClientProvider() CLISomeHeaderAuthServiceClientProvider {
	return defaultCLISomeHeaderAuthServiceClientProvider{}
}

func (d defaultCLISomeHeaderAuthServiceClientProvider) Get(ctx context.Context, flags *pflag.FlagSet) (SomeHeaderAuthServiceClient, error) {
	conf, err := loadCLIConfig(ctx, flags)
	if err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "failed to load CLI configuration file")
	}
	client, err := httpclient.NewClient(httpclient.WithConfig(conf.Client))
	if err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "failed to create client with provided config")
	}
	return NewSomeHeaderAuthServiceClient(client), nil
}

type SomeHeaderAuthServiceCLICommand struct {
	clientProvider CLISomeHeaderAuthServiceClientProvider
}

func NewSomeHeaderAuthServiceCLICommand() *cobra.Command {
	return NewSomeHeaderAuthServiceCLICommandWithClientProvider(NewDefaultCLISomeHeaderAuthServiceClientProvider())
}

func NewSomeHeaderAuthServiceCLICommandWithClientProvider(clientProvider CLISomeHeaderAuthServiceClientProvider) *cobra.Command {
	rootCmd := &cobra.Command{
		Short: "Runs commands on the SomeHeaderAuthService",
		Use:   "someHeaderAuthService",
	}
	rootCmd.PersistentFlags().String("conf", "var/conf/configuration.yml", "The configuration file is optional. The default path is ./var/conf/configuration.yml.")
	rootCmd.PersistentFlags().BoolP("verbose", "v", false, "Enables verbose mode for debugging client connections.")

	cliCommand := SomeHeaderAuthServiceCLICommand{clientProvider: clientProvider}

	someHeaderAuthService_Default_Cmd := &cobra.Command{
		RunE:  cliCommand.someHeaderAuthService_Default_CmdRun,
		Short: "Calls the default endpoint.",
		Use:   "default",
	}
	rootCmd.AddCommand(someHeaderAuthService_Default_Cmd)
	someHeaderAuthService_Default_Cmd.Flags().String("bearer_token", "", "bearer_token is a required field.")

	someHeaderAuthService_None_Cmd := &cobra.Command{
		RunE:  cliCommand.someHeaderAuthService_None_CmdRun,
		Short: "Calls the none endpoint.",
		Use:   "none",
	}
	rootCmd.AddCommand(someHeaderAuthService_None_Cmd)

	return rootCmd
}

func (c SomeHeaderAuthServiceCLICommand) someHeaderAuthService_Default_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	bearer_tokenRaw, err := flags.GetString("bearer_token")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument __authVar")
	}
	if bearer_tokenRaw == "" {
		return werror.ErrorWithContextParams(ctx, "bearer_token is a required argument")
	}
	__authVarArg := bearertoken.Token(bearer_tokenRaw)
	result, err := client.Default(ctx, __authVarArg)
	if err != nil {
		return err
	}
	fmt.Fprintf(cmd.OutOrStdout(), "%v\n", result)
	return nil
}

func (c SomeHeaderAuthServiceCLICommand) someHeaderAuthService_None_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	return client.None(ctx)
}

func loadCLIConfig(ctx context.Context, flags *pflag.FlagSet) (CLIConfig, error) {
	var emptyConfig CLIConfig
	configPath, err := flags.GetString("conf")
	if err != nil || configPath == "" {
		return emptyConfig, werror.WrapWithContextParams(ctx, err, "config file location must be specified")
	}
	confBytes, err := os.ReadFile(configPath)
	if err != nil {
		return emptyConfig, err
	}
	var conf CLIConfig
	err = yaml.Unmarshal(confBytes, &conf)
	if err != nil {
		return emptyConfig, err
	}
	return conf, nil
}

func getCLIContext(flags *pflag.FlagSet) context.Context {
	ctx := context.Background()
	logProvider := wlog.NewNoopLoggerProvider()
	logWriter := io.Discard
	verbose, err := flags.GetBool("verbose")
	if verbose && err == nil {
		logProvider = wlogzap.LoggerProvider()
		logWriter = os.Stdout
	}
	wlog.SetDefaultLoggerProvider(logProvider)
	ctx = svc1log.WithLogger(ctx, svc1log.New(logWriter, wlog.DebugLevel))
	traceLogger := trc1log.New(logWriter)
	ctx = trc1log.WithLogger(ctx, traceLogger)
	ctx = evt2log.WithLogger(ctx, evt2log.New(logWriter))
	tracer, err := wzipkin.NewTracer(traceLogger)
	if err != nil {
		return ctx
	}
	return wtracing.ContextWithTracer(ctx, tracer)
}
