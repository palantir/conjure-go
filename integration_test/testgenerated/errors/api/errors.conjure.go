// This file was generated by Conjure and should not be manually edited.

package api

import (
	"encoding/json"
	"fmt"
	"io"
	"reflect"

	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	dj "github.com/palantir/conjure-go/v6/dj"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	"github.com/palantir/pkg/uuid"
	werror "github.com/palantir/witchcraft-go-error"
)

type myInternal struct {
	// This is safeArgA doc.
	SafeArgA Basic `conjure-docs:"This is safeArgA doc." json:"safeArgA"`
	// This is safeArgB doc.
	SafeArgB []int `conjure-docs:"This is safeArgB doc." json:"safeArgB"`
	// A field named with a go keyword
	Type       string  `conjure-docs:"A field named with a go keyword" json:"type"`
	UnsafeArgA string  `json:"unsafeArgA"`
	UnsafeArgB *string `json:"unsafeArgB"`
	MyInternal string  `json:"myInternal"`
}

func (o myInternal) MarshalJSON() ([]byte, error) {
	out := make([]byte, 0)
	if _, err := o.WriteJSON(dj.NewAppender(&out)); err != nil {
		return nil, err
	}
	return out, dj.Valid(out)
}

func (o myInternal) WriteJSON(w io.Writer) (int, error) {
	var out int
	if n, err := dj.WriteOpenObject(w); err != nil {
		return 0, err
	} else {
		out += n
	}
	{
		if n, err := dj.WriteLiteral(w, "\"safeArgA\":"); err != nil {
			return 0, err
		} else {
			out += n
		}
		if n, err := o.SafeArgA.WriteJSON(w); err != nil {
			return 0, err
		} else {
			out += n
		}
	}
	{
		if n, err := dj.WriteComma(w); err != nil {
			return 0, err
		} else {
			out += n
		}
		if n, err := dj.WriteLiteral(w, "\"safeArgB\":"); err != nil {
			return 0, err
		} else {
			out += n
		}
		if n, err := dj.WriteOpenArray(w); err != nil {
			return 0, err
		} else {
			out += n
		}
		for i := range o.SafeArgB {
			if n, err := dj.WriteInt(w, int64(o.SafeArgB[i])); err != nil {
				return 0, err
			} else {
				out += n
			}
			if i < len(o.SafeArgB)-1 {
				if n, err := dj.WriteComma(w); err != nil {
					return 0, err
				} else {
					out += n
				}
			}
		}
		if n, err := dj.WriteCloseArray(w); err != nil {
			return 0, err
		} else {
			out += n
		}
	}
	{
		if n, err := dj.WriteComma(w); err != nil {
			return 0, err
		} else {
			out += n
		}
		if n, err := dj.WriteLiteral(w, "\"type\":"); err != nil {
			return 0, err
		} else {
			out += n
		}
		if n, err := dj.WriteString(w, o.Type); err != nil {
			return 0, err
		} else {
			out += n
		}
	}
	{
		if n, err := dj.WriteComma(w); err != nil {
			return 0, err
		} else {
			out += n
		}
		if n, err := dj.WriteLiteral(w, "\"unsafeArgA\":"); err != nil {
			return 0, err
		} else {
			out += n
		}
		if n, err := dj.WriteString(w, o.UnsafeArgA); err != nil {
			return 0, err
		} else {
			out += n
		}
	}
	if o.UnsafeArgB != nil {
		if n, err := dj.WriteComma(w); err != nil {
			return 0, err
		} else {
			out += n
		}
		if n, err := dj.WriteLiteral(w, "\"unsafeArgB\":"); err != nil {
			return 0, err
		} else {
			out += n
		}
		optVal := *o.UnsafeArgB
		if n, err := dj.WriteString(w, optVal); err != nil {
			return 0, err
		} else {
			out += n
		}
	}
	{
		if n, err := dj.WriteComma(w); err != nil {
			return 0, err
		} else {
			out += n
		}
		if n, err := dj.WriteLiteral(w, "\"myInternal\":"); err != nil {
			return 0, err
		} else {
			out += n
		}
		if n, err := dj.WriteString(w, o.MyInternal); err != nil {
			return 0, err
		} else {
			out += n
		}
	}
	if n, err := dj.WriteCloseObject(w); err != nil {
		return 0, err
	} else {
		out += n
	}
	return out, nil
}

func (o *myInternal) UnmarshalJSON(data []byte) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return o.UnmarshalJSONResult(value, false)
}

func (o *myInternal) UnmarshalJSONStrict(data []byte) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return o.UnmarshalJSONResult(value, true)
}

func (o *myInternal) UnmarshalJSONString(data string) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return o.UnmarshalJSONResult(value, false)
}

func (o *myInternal) UnmarshalJSONStringStrict(data string) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return o.UnmarshalJSONResult(value, true)
}

func (o *myInternal) UnmarshalJSONResult(value dj.Result, disallowUnknownFields bool) error {
	var seenSafeArgA bool
	var seenSafeArgB bool
	var seenType bool
	var seenUnsafeArgA bool
	var seenUnsafeArgB bool
	var seenMyInternal bool
	var unknownFields []string
	iter, idx, err := value.ObjectIterator(0)
	if err != nil {
		return err
	}
	for iter.HasNext(value, idx) {
		var fieldKey, fieldValue dj.Result
		fieldKey, fieldValue, idx, err = iter.Next(value, idx)
		if err != nil {
			return err
		}
		switch fieldKey.Str {
		case "safeArgA":
			if seenSafeArgA {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "myInternal", Field: "safeArgA"}
			}
			seenSafeArgA = true
			if err := o.SafeArgA.UnmarshalJSONResult(fieldValue, disallowUnknownFields); err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "myInternal", Field: "safeArgA", Err: err})
			}
		case "safeArgB":
			if seenSafeArgB {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "myInternal", Field: "safeArgB"}
			}
			seenSafeArgB = true
			if o.SafeArgB == nil {
				o.SafeArgB = make([]int, 0)
			}
			iter, idx, err := fieldValue.ArrayIterator(0)
			if err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "myInternal", Field: "safeArgB", Err: err})
			}
			for iter.HasNext(fieldValue, idx) {
				var arrayValue1 dj.Result
				arrayValue1, idx, err = iter.Next(fieldValue, idx)
				if err != nil {
					return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "myInternal", Field: "safeArgB", Err: err})
				}
				var listElement1 int
				intVal2, err := arrayValue1.Int()
				if err != nil {
					return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "myInternal", Field: "safeArgB", Err: err})
				}
				listElement1 = int(intVal2)
				o.SafeArgB = append(o.SafeArgB, listElement1)
			}
		case "type":
			if seenType {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "myInternal", Field: "type"}
			}
			seenType = true
			o.Type, err = fieldValue.String()
			if err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "myInternal", Field: "type", Err: err})
			}
		case "unsafeArgA":
			if seenUnsafeArgA {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "myInternal", Field: "unsafeArgA"}
			}
			seenUnsafeArgA = true
			o.UnsafeArgA, err = fieldValue.String()
			if err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "myInternal", Field: "unsafeArgA", Err: err})
			}
		case "unsafeArgB":
			if seenUnsafeArgB {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "myInternal", Field: "unsafeArgB"}
			}
			seenUnsafeArgB = true
			if fieldValue.Type != dj.Null {
				var optVal string
				optVal, err = fieldValue.String()
				if err != nil {
					return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "myInternal", Field: "unsafeArgB", Err: err})
				}
				o.UnsafeArgB = &optVal
			}
		case "myInternal":
			if seenMyInternal {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "myInternal", Field: "myInternal"}
			}
			seenMyInternal = true
			o.MyInternal, err = fieldValue.String()
			if err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "myInternal", Field: "myInternal", Err: err})
			}
		default:
			if disallowUnknownFields {
				unknownFields = append(unknownFields, fieldKey.Str)
			}
		}
	}
	var missingFields []string
	if !seenSafeArgA {
		missingFields = append(missingFields, "safeArgA")
	}
	if !seenSafeArgB {
		o.SafeArgB = make([]int, 0)
	}
	if !seenType {
		missingFields = append(missingFields, "type")
	}
	if !seenUnsafeArgA {
		missingFields = append(missingFields, "unsafeArgA")
	}
	if !seenMyInternal {
		missingFields = append(missingFields, "myInternal")
	}
	if len(missingFields) > 0 {
		return werror.Convert(dj.UnmarshalMissingFieldsError{Index: value.Index, Type: "myInternal", Fields: missingFields})
	}
	if disallowUnknownFields && len(unknownFields) > 0 {
		return werror.Convert(dj.UnmarshalUnknownFieldsError{Index: value.Index, Type: "myInternal", Fields: unknownFields})
	}
	return nil
}

func (o myInternal) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *myInternal) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewMyInternal returns new instance of MyInternal error.
func NewMyInternal(safeArgAArg Basic, safeArgBArg []int, typeArg string, unsafeArgAArg string, unsafeArgBArg *string, myInternalArg string) *MyInternal {
	return &MyInternal{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), myInternal: myInternal{SafeArgA: safeArgAArg, SafeArgB: safeArgBArg, Type: typeArg, UnsafeArgA: unsafeArgAArg, UnsafeArgB: unsafeArgBArg, MyInternal: myInternalArg}}
}

// WrapWithMyInternal returns new instance of MyInternal error wrapping an existing error.
func WrapWithMyInternal(err error, safeArgAArg Basic, safeArgBArg []int, typeArg string, unsafeArgAArg string, unsafeArgBArg *string, myInternalArg string) *MyInternal {
	return &MyInternal{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, myInternal: myInternal{SafeArgA: safeArgAArg, SafeArgB: safeArgBArg, Type: typeArg, UnsafeArgA: unsafeArgAArg, UnsafeArgB: unsafeArgBArg, MyInternal: myInternalArg}}
}

// MyInternal is an error type.
// Internal server error.
type MyInternal struct {
	errorInstanceID uuid.UUID
	myInternal
	cause error
	stack werror.StackTrace
}

// IsMyInternal returns true if err is an instance of MyInternal.
func IsMyInternal(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*MyInternal)
	return ok
}

func (e *MyInternal) Error() string {
	return fmt.Sprintf("INTERNAL MyNamespace:MyInternal (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *MyInternal) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *MyInternal) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *MyInternal) Message() string {
	return "INTERNAL MyNamespace:MyInternal"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *MyInternal) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *MyInternal) Code() errors.ErrorCode {
	return errors.Internal
}

// Name returns an error name identifying error type.
func (e *MyInternal) Name() string {
	return "MyNamespace:MyInternal"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *MyInternal) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *MyInternal) Parameters() map[string]interface{} {
	return map[string]interface{}{"safeArgA": e.SafeArgA, "safeArgB": e.SafeArgB, "type": e.Type, "unsafeArgA": e.UnsafeArgA, "unsafeArgB": e.UnsafeArgB, "myInternal": e.MyInternal}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *MyInternal) safeParams() map[string]interface{} {
	return map[string]interface{}{"safeArgA": e.SafeArgA, "safeArgB": e.SafeArgB, "type": e.Type, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *MyInternal) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *MyInternal) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"unsafeArgA": e.UnsafeArgA, "unsafeArgB": e.UnsafeArgB, "myInternal": e.MyInternal}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *MyInternal) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e MyInternal) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.myInternal)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.Internal, ErrorName: "MyNamespace:MyInternal", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *MyInternal) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters myInternal
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.myInternal = parameters
	return nil
}

type myNotFound struct {
	// This is safeArgA doc.
	SafeArgA Basic `conjure-docs:"This is safeArgA doc." json:"safeArgA"`
	// This is safeArgB doc.
	SafeArgB []int `conjure-docs:"This is safeArgB doc." json:"safeArgB"`
	// A field named with a go keyword
	Type       string  `conjure-docs:"A field named with a go keyword" json:"type"`
	UnsafeArgA string  `json:"unsafeArgA"`
	UnsafeArgB *string `json:"unsafeArgB"`
}

func (o myNotFound) MarshalJSON() ([]byte, error) {
	out := make([]byte, 0)
	if _, err := o.WriteJSON(dj.NewAppender(&out)); err != nil {
		return nil, err
	}
	return out, dj.Valid(out)
}

func (o myNotFound) WriteJSON(w io.Writer) (int, error) {
	var out int
	if n, err := dj.WriteOpenObject(w); err != nil {
		return 0, err
	} else {
		out += n
	}
	{
		if n, err := dj.WriteLiteral(w, "\"safeArgA\":"); err != nil {
			return 0, err
		} else {
			out += n
		}
		if n, err := o.SafeArgA.WriteJSON(w); err != nil {
			return 0, err
		} else {
			out += n
		}
	}
	{
		if n, err := dj.WriteComma(w); err != nil {
			return 0, err
		} else {
			out += n
		}
		if n, err := dj.WriteLiteral(w, "\"safeArgB\":"); err != nil {
			return 0, err
		} else {
			out += n
		}
		if n, err := dj.WriteOpenArray(w); err != nil {
			return 0, err
		} else {
			out += n
		}
		for i := range o.SafeArgB {
			if n, err := dj.WriteInt(w, int64(o.SafeArgB[i])); err != nil {
				return 0, err
			} else {
				out += n
			}
			if i < len(o.SafeArgB)-1 {
				if n, err := dj.WriteComma(w); err != nil {
					return 0, err
				} else {
					out += n
				}
			}
		}
		if n, err := dj.WriteCloseArray(w); err != nil {
			return 0, err
		} else {
			out += n
		}
	}
	{
		if n, err := dj.WriteComma(w); err != nil {
			return 0, err
		} else {
			out += n
		}
		if n, err := dj.WriteLiteral(w, "\"type\":"); err != nil {
			return 0, err
		} else {
			out += n
		}
		if n, err := dj.WriteString(w, o.Type); err != nil {
			return 0, err
		} else {
			out += n
		}
	}
	{
		if n, err := dj.WriteComma(w); err != nil {
			return 0, err
		} else {
			out += n
		}
		if n, err := dj.WriteLiteral(w, "\"unsafeArgA\":"); err != nil {
			return 0, err
		} else {
			out += n
		}
		if n, err := dj.WriteString(w, o.UnsafeArgA); err != nil {
			return 0, err
		} else {
			out += n
		}
	}
	if o.UnsafeArgB != nil {
		if n, err := dj.WriteComma(w); err != nil {
			return 0, err
		} else {
			out += n
		}
		if n, err := dj.WriteLiteral(w, "\"unsafeArgB\":"); err != nil {
			return 0, err
		} else {
			out += n
		}
		optVal := *o.UnsafeArgB
		if n, err := dj.WriteString(w, optVal); err != nil {
			return 0, err
		} else {
			out += n
		}
	}
	if n, err := dj.WriteCloseObject(w); err != nil {
		return 0, err
	} else {
		out += n
	}
	return out, nil
}

func (o *myNotFound) UnmarshalJSON(data []byte) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return o.UnmarshalJSONResult(value, false)
}

func (o *myNotFound) UnmarshalJSONStrict(data []byte) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return o.UnmarshalJSONResult(value, true)
}

func (o *myNotFound) UnmarshalJSONString(data string) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return o.UnmarshalJSONResult(value, false)
}

func (o *myNotFound) UnmarshalJSONStringStrict(data string) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return o.UnmarshalJSONResult(value, true)
}

func (o *myNotFound) UnmarshalJSONResult(value dj.Result, disallowUnknownFields bool) error {
	var seenSafeArgA bool
	var seenSafeArgB bool
	var seenType bool
	var seenUnsafeArgA bool
	var seenUnsafeArgB bool
	var unknownFields []string
	iter, idx, err := value.ObjectIterator(0)
	if err != nil {
		return err
	}
	for iter.HasNext(value, idx) {
		var fieldKey, fieldValue dj.Result
		fieldKey, fieldValue, idx, err = iter.Next(value, idx)
		if err != nil {
			return err
		}
		switch fieldKey.Str {
		case "safeArgA":
			if seenSafeArgA {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "myNotFound", Field: "safeArgA"}
			}
			seenSafeArgA = true
			if err := o.SafeArgA.UnmarshalJSONResult(fieldValue, disallowUnknownFields); err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "myNotFound", Field: "safeArgA", Err: err})
			}
		case "safeArgB":
			if seenSafeArgB {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "myNotFound", Field: "safeArgB"}
			}
			seenSafeArgB = true
			if o.SafeArgB == nil {
				o.SafeArgB = make([]int, 0)
			}
			iter, idx, err := fieldValue.ArrayIterator(0)
			if err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "myNotFound", Field: "safeArgB", Err: err})
			}
			for iter.HasNext(fieldValue, idx) {
				var arrayValue1 dj.Result
				arrayValue1, idx, err = iter.Next(fieldValue, idx)
				if err != nil {
					return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "myNotFound", Field: "safeArgB", Err: err})
				}
				var listElement1 int
				intVal2, err := arrayValue1.Int()
				if err != nil {
					return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "myNotFound", Field: "safeArgB", Err: err})
				}
				listElement1 = int(intVal2)
				o.SafeArgB = append(o.SafeArgB, listElement1)
			}
		case "type":
			if seenType {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "myNotFound", Field: "type"}
			}
			seenType = true
			o.Type, err = fieldValue.String()
			if err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "myNotFound", Field: "type", Err: err})
			}
		case "unsafeArgA":
			if seenUnsafeArgA {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "myNotFound", Field: "unsafeArgA"}
			}
			seenUnsafeArgA = true
			o.UnsafeArgA, err = fieldValue.String()
			if err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "myNotFound", Field: "unsafeArgA", Err: err})
			}
		case "unsafeArgB":
			if seenUnsafeArgB {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "myNotFound", Field: "unsafeArgB"}
			}
			seenUnsafeArgB = true
			if fieldValue.Type != dj.Null {
				var optVal string
				optVal, err = fieldValue.String()
				if err != nil {
					return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "myNotFound", Field: "unsafeArgB", Err: err})
				}
				o.UnsafeArgB = &optVal
			}
		default:
			if disallowUnknownFields {
				unknownFields = append(unknownFields, fieldKey.Str)
			}
		}
	}
	var missingFields []string
	if !seenSafeArgA {
		missingFields = append(missingFields, "safeArgA")
	}
	if !seenSafeArgB {
		o.SafeArgB = make([]int, 0)
	}
	if !seenType {
		missingFields = append(missingFields, "type")
	}
	if !seenUnsafeArgA {
		missingFields = append(missingFields, "unsafeArgA")
	}
	if len(missingFields) > 0 {
		return werror.Convert(dj.UnmarshalMissingFieldsError{Index: value.Index, Type: "myNotFound", Fields: missingFields})
	}
	if disallowUnknownFields && len(unknownFields) > 0 {
		return werror.Convert(dj.UnmarshalUnknownFieldsError{Index: value.Index, Type: "myNotFound", Fields: unknownFields})
	}
	return nil
}

func (o myNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *myNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewMyNotFound returns new instance of MyNotFound error.
func NewMyNotFound(safeArgAArg Basic, safeArgBArg []int, typeArg string, unsafeArgAArg string, unsafeArgBArg *string) *MyNotFound {
	return &MyNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), myNotFound: myNotFound{SafeArgA: safeArgAArg, SafeArgB: safeArgBArg, Type: typeArg, UnsafeArgA: unsafeArgAArg, UnsafeArgB: unsafeArgBArg}}
}

// WrapWithMyNotFound returns new instance of MyNotFound error wrapping an existing error.
func WrapWithMyNotFound(err error, safeArgAArg Basic, safeArgBArg []int, typeArg string, unsafeArgAArg string, unsafeArgBArg *string) *MyNotFound {
	return &MyNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, myNotFound: myNotFound{SafeArgA: safeArgAArg, SafeArgB: safeArgBArg, Type: typeArg, UnsafeArgA: unsafeArgAArg, UnsafeArgB: unsafeArgBArg}}
}

// MyNotFound is an error type.
// Something was not found.
type MyNotFound struct {
	errorInstanceID uuid.UUID
	myNotFound
	cause error
	stack werror.StackTrace
}

// IsMyNotFound returns true if err is an instance of MyNotFound.
func IsMyNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*MyNotFound)
	return ok
}

func (e *MyNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND MyNamespace:MyNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *MyNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *MyNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *MyNotFound) Message() string {
	return "NOT_FOUND MyNamespace:MyNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *MyNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *MyNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *MyNotFound) Name() string {
	return "MyNamespace:MyNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *MyNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *MyNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"safeArgA": e.SafeArgA, "safeArgB": e.SafeArgB, "type": e.Type, "unsafeArgA": e.UnsafeArgA, "unsafeArgB": e.UnsafeArgB}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *MyNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"safeArgA": e.SafeArgA, "safeArgB": e.SafeArgB, "type": e.Type, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *MyNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *MyNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"unsafeArgA": e.UnsafeArgA, "unsafeArgB": e.UnsafeArgB}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *MyNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e MyNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.myNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "MyNamespace:MyNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *MyNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters myNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.myNotFound = parameters
	return nil
}

func init() {
	errors.RegisterErrorType("MyNamespace:MyInternal", reflect.TypeOf(MyInternal{}))
	errors.RegisterErrorType("MyNamespace:MyNotFound", reflect.TypeOf(MyNotFound{}))
}
