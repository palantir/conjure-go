// This file was generated by Conjure and should not be manually edited.

package api

import (
	"encoding/json"
	"fmt"

	"github.com/palantir/conjure-go-runtime/conjure-go-contract/codecs"
	"github.com/palantir/conjure-go-runtime/conjure-go-contract/errors"
	"github.com/palantir/conjure-go-runtime/conjure-go-contract/uuid"
)

type myNotFound struct {
	// This is safeArgA doc.
	SafeArgA Basic `json:"safeArgA" yaml:"safeArgA,omitempty" conjure-docs:"This is safeArgA doc."`
	// This is safeArgB doc.
	SafeArgB   []int   `json:"safeArgB" yaml:"safeArgB,omitempty" conjure-docs:"This is safeArgB doc."`
	UnsafeArgA string  `json:"unsafeArgA" yaml:"unsafeArgA,omitempty"`
	UnsafeArgB *string `json:"unsafeArgB" yaml:"unsafeArgB,omitempty"`
}

func (o myNotFound) MarshalJSON() ([]byte, error) {
	if o.SafeArgB == nil {
		o.SafeArgB = make([]int, 0)
	}
	type myNotFoundAlias myNotFound
	return json.Marshal(myNotFoundAlias(o))
}

func (o *myNotFound) UnmarshalJSON(data []byte) error {
	type myNotFoundAlias myNotFound
	var rawmyNotFound myNotFoundAlias
	if err := json.Unmarshal(data, &rawmyNotFound); err != nil {
		return err
	}
	if rawmyNotFound.SafeArgB == nil {
		rawmyNotFound.SafeArgB = make([]int, 0)
	}
	*o = myNotFound(rawmyNotFound)
	return nil
}

func (o myNotFound) MarshalYAML() (interface{}, error) {
	if o.SafeArgB == nil {
		o.SafeArgB = make([]int, 0)
	}
	type myNotFoundAlias myNotFound
	return myNotFoundAlias(o), nil
}

func (o *myNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	type myNotFoundAlias myNotFound
	var rawmyNotFound myNotFoundAlias
	if err := unmarshal(&rawmyNotFound); err != nil {
		return err
	}
	if rawmyNotFound.SafeArgB == nil {
		rawmyNotFound.SafeArgB = make([]int, 0)
	}
	*o = myNotFound(rawmyNotFound)
	return nil
}

// NewMyNotFound returns new instance of MyNotFound error.
func NewMyNotFound(safeArgA Basic, safeArgB []int, unsafeArgA string, unsafeArgB *string) *MyNotFound {
	return &MyNotFound{errorInstanceID: uuid.NewUUID(), myNotFound: myNotFound{SafeArgA: safeArgA, SafeArgB: safeArgB, UnsafeArgA: unsafeArgA, UnsafeArgB: unsafeArgB}}
}

// MyNotFound is an error type.
//
// Something was not found.
type MyNotFound struct {
	errorInstanceID uuid.UUID
	myNotFound
}

func (e *MyNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND MyNamespace:MyNotFound (%s)", e.errorInstanceID)
}

// Code returns an enum describing error category.
func (e *MyNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *MyNotFound) Name() string {
	return "MyNamespace:MyNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *MyNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *MyNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"safeArgA": e.SafeArgA, "safeArgB": e.SafeArgB, "unsafeArgA": e.UnsafeArgA, "unsafeArgB": e.UnsafeArgB}
}

func (e *MyNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := codecs.JSON.Marshal(e.myNotFound)
	if err != nil {
		return nil, err
	}
	return codecs.JSON.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "MyNamespace:MyNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *MyNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := codecs.JSON.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters myNotFound
	if err := codecs.JSON.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.myNotFound = parameters
	return nil
}
