// This file was generated by Conjure and should not be manually edited.

package api

import (
	"context"
	"net/http"
	"strconv"

	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/codecs"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-server/httpserver"
	werror "github.com/palantir/witchcraft-go-error"
	"github.com/palantir/witchcraft-go-server/v2/witchcraft/wresource"
	"github.com/palantir/witchcraft-go-server/v2/wrouter"
)

type TestService interface {
	Echo(ctx context.Context, inputArg string, repsArg int, optionalArg *string, listParamArg []int, lastParamArg *string) (string, error)
}

// RegisterRoutesTestService registers handlers for the TestService endpoints with a witchcraft wrouter.
// This should typically be called in a witchcraft server's InitFunc.
// impl provides an implementation of each endpoint, which can assume the request parameters have been parsed
// in accordance with the Conjure specification.
func RegisterRoutesTestService(router wrouter.Router, impl TestService, routerParams ...wrouter.RouteParam) error {
	handler := testServiceHandler{impl: impl}
	resource := wresource.New("testservice", router)
	if err := resource.Get("Echo", "/echo", httpserver.NewJSONHandler(handler.HandleEcho, httpserver.StatusCodeMapper, httpserver.ErrHandler), routerParams...); err != nil {
		return werror.Wrap(err, "failed to add echo route")
	}
	return nil
}

type testServiceHandler struct {
	impl TestService
}

func (t *testServiceHandler) HandleEcho(rw http.ResponseWriter, req *http.Request) error {
	inputArg := req.URL.Query().Get("input")
	repsArg, err := strconv.Atoi(req.URL.Query().Get("reps"))
	if err != nil {
		return werror.WrapWithContextParams(req.Context(), errors.WrapWithInvalidArgument(err), "failed to parse \"reps\" as integer")
	}
	var optionalArg *string
	if optionalArgStr := req.URL.Query().Get("optional"); optionalArgStr != "" {
		optionalArgInternal := optionalArgStr
		optionalArg = &optionalArgInternal
	}
	var listParamArg []int
	for _, v := range req.URL.Query()["listParam"] {
		convertedVal, err := strconv.Atoi(v)
		if err != nil {
			return werror.WrapWithContextParams(req.Context(), errors.WrapWithInvalidArgument(err), "failed to parse \"listParam\" as integer")
		}
		listParamArg = append(listParamArg, convertedVal)
	}
	var lastParamArg *string
	if lastParamArgStr := req.URL.Query().Get("lastParam"); lastParamArgStr != "" {
		lastParamArgInternal := lastParamArgStr
		lastParamArg = &lastParamArgInternal
	}
	respArg, err := t.impl.Echo(req.Context(), inputArg, repsArg, optionalArg, listParamArg, lastParamArg)
	if err != nil {
		return err
	}
	rw.Header().Add("Content-Type", codecs.JSON.ContentType())
	return codecs.JSON.Encode(rw, respArg)
}
