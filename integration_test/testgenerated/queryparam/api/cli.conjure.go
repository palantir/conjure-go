// This file was generated by Conjure and should not be manually edited.

package api

import (
	"bytes"
	"context"
	"fmt"
	"io/ioutil"
	"os"
	"strconv"

	"github.com/palantir/conjure-go-runtime/v2/conjure-go-client/httpclient"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/codecs"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	werror "github.com/palantir/witchcraft-go-error"
	"github.com/palantir/witchcraft-go-logging/wlog"
	wlogzap "github.com/palantir/witchcraft-go-logging/wlog-zap"
	"github.com/palantir/witchcraft-go-logging/wlog/evtlog/evt2log"
	"github.com/palantir/witchcraft-go-logging/wlog/svclog/svc1log"
	"github.com/palantir/witchcraft-go-logging/wlog/trclog/trc1log"
	"github.com/palantir/witchcraft-go-tracing/wtracing"
	"github.com/palantir/witchcraft-go-tracing/wzipkin"
	"github.com/spf13/cobra"
	"gopkg.in/yaml.v3"
)

type CLIConfig struct {
	Client httpclient.ClientConfig
}

var configFile *string

// Commands for TestService

var RootTestServiceCmd = &cobra.Command{
	Short: "Runs commands on the TestService",
	Use:   "testService",
}

func getTestServiceClient(ctx context.Context) (TestServiceClient, error) {
	conf, err := loadConfig(ctx)
	if err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "failed to load CLI configuration file")
	}
	client, err := httpclient.NewClient(httpclient.WithConfig(conf.Client))
	if err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "failed to create client with provided config")
	}
	return NewTestServiceClient(client), nil
}

var TestServiceechoCmd = &cobra.Command{
	RunE:  testServiceechoCmdRun,
	Short: "Calls the echo endpoint",
	Use:   "echo",
}

var testService_echo_input *string
var testService_echo_reps *string
var testService_echo_optional *string
var testService_echo_listParam *string
var testService_echo_lastParam *string

func testServiceechoCmdRun(_ *cobra.Command, _ []string) error {
	ctx := getCLIContext()
	client, err := getTestServiceClient(ctx)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	return testServiceechoCmdRunInternal(ctx, client)
}

func testServiceechoCmdRunInternal(ctx context.Context, client TestServiceClient) error {
	var err error

	if testService_echo_input == nil {
		return werror.ErrorWithContextParams(ctx, "inputArg is a required argument")
	}
	inputArg := *testService_echo_input

	if testService_echo_reps == nil {
		return werror.ErrorWithContextParams(ctx, "repsArg is a required argument")
	}
	repsArg, err := strconv.Atoi(*testService_echo_reps)
	if err != nil {
		return werror.WrapWithContextParams(ctx, errors.WrapWithInvalidArgument(err), "failed to parse \"reps\" as integer")
	}

	var testService_echo_optionalDeref string
	if testService_echo_optional != nil {
		testService_echo_optionalDeref = *testService_echo_optional
	}
	var optionalArg *string
	if optionalArgStr := testService_echo_optionalDeref; optionalArgStr != "" {
		optionalArgInternal := optionalArgStr
		optionalArg = &optionalArgInternal
	}

	if testService_echo_listParam == nil {
		return werror.ErrorWithContextParams(ctx, "listParamArg is a required argument")
	}
	var listParamArg []int
	listParamArgBytes := []byte(*testService_echo_listParam)
	if err := codecs.JSON.Decode(bytes.NewReader(listParamArgBytes), &listParamArg); err != nil {
		return errors.WrapWithInvalidArgument(err)
	}

	var testService_echo_lastParamDeref string
	if testService_echo_lastParam != nil {
		testService_echo_lastParamDeref = *testService_echo_lastParam
	}
	var lastParamArg *string
	if lastParamArgStr := testService_echo_lastParamDeref; lastParamArgStr != "" {
		lastParamArgInternal := lastParamArgStr
		lastParamArg = &lastParamArgInternal
	}

	result, err := client.Echo(ctx, inputArg, repsArg, optionalArg, listParamArg, lastParamArg)
	if err != nil {
		return err
	}
	fmt.Printf("%v\n", result)
	return nil
}

func loadConfig(ctx context.Context) (CLIConfig, error) {
	var emptyConfig CLIConfig
	if configFile == nil {
		return emptyConfig, werror.ErrorWithContextParams(ctx, "config file location must be specified")
	}
	confBytes, err := ioutil.ReadFile(*configFile)
	if err != nil {
		return emptyConfig, err
	}
	var conf CLIConfig
	err = yaml.Unmarshal(confBytes, &conf)
	if err != nil {
		return emptyConfig, err
	}
	return conf, nil
}

func getCLIContext() context.Context {
	ctx := context.Background()
	wlog.SetDefaultLoggerProvider(wlogzap.LoggerProvider())
	ctx = svc1log.WithLogger(ctx, svc1log.New(os.Stdout, wlog.DebugLevel))
	traceLogger := trc1log.DefaultLogger()
	ctx = trc1log.WithLogger(ctx, traceLogger)
	ctx = evt2log.WithLogger(ctx, evt2log.New(os.Stdout))
	tracer, err := wzipkin.NewTracer(traceLogger)
	if err != nil {
		return ctx
	}
	return wtracing.ContextWithTracer(ctx, tracer)
}

func RegisterCommands(rootCmd *cobra.Command) {
	rootCmd.AddCommand(RootTestServiceCmd)
}

func init() {
	// TestService commands and flags
	RootTestServiceCmd.PersistentFlags().StringVarP(configFile, "conf", "", "../var/conf/configuration.yml", "The configuration file is optional. The default path is ./var/conf/configuration.yml.")
	RootTestServiceCmd.AddCommand(TestServiceechoCmd)
	TestServiceechoCmd.PersistentFlags().StringVarP(testService_echo_input, "input", "", "", "input is a required param.")
	TestServiceechoCmd.PersistentFlags().StringVarP(testService_echo_reps, "reps", "", "", "reps is a required param.")
	TestServiceechoCmd.PersistentFlags().StringVarP(testService_echo_optional, "optional", "", "", "optional is an optional param.")
	TestServiceechoCmd.PersistentFlags().StringVarP(testService_echo_listParam, "listParam", "", "", "listParam is a required param.")
	TestServiceechoCmd.PersistentFlags().StringVarP(testService_echo_lastParam, "lastParam", "", "", "lastParam is an optional param.")
}
