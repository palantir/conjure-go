// This file was generated by Conjure and should not be manually edited.

package api

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"strconv"
	"strings"

	"github.com/palantir/conjure-go-runtime/v2/conjure-go-client/httpclient"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/codecs"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	"github.com/palantir/pkg/bearertoken"
	"github.com/palantir/pkg/datetime"
	"github.com/palantir/pkg/rid"
	"github.com/palantir/pkg/safelong"
	"github.com/palantir/pkg/uuid"
	werror "github.com/palantir/witchcraft-go-error"
	"github.com/palantir/witchcraft-go-logging/wlog"
	wlogzap "github.com/palantir/witchcraft-go-logging/wlog-zap"
	"github.com/palantir/witchcraft-go-logging/wlog/evtlog/evt2log"
	"github.com/palantir/witchcraft-go-logging/wlog/svclog/svc1log"
	"github.com/palantir/witchcraft-go-logging/wlog/trclog/trc1log"
	"github.com/palantir/witchcraft-go-tracing/wtracing"
	"github.com/palantir/witchcraft-go-tracing/wzipkin"
	"github.com/spf13/cobra"
	pflag "github.com/spf13/pflag"
	"gopkg.in/yaml.v3"
)

type CLIConfig struct {
	Client httpclient.ClientConfig `yaml:",inline"`
}

// Commands for TestService

type CLITestServiceClientProvider interface {
	Get(ctx context.Context, flags *pflag.FlagSet) (TestServiceClient, error)
}

type defaultCLITestServiceClientProvider struct{}

func NewDefaultCLITestServiceClientProvider() CLITestServiceClientProvider {
	return defaultCLITestServiceClientProvider{}
}

func (d defaultCLITestServiceClientProvider) Get(ctx context.Context, flags *pflag.FlagSet) (TestServiceClient, error) {
	conf, err := loadCLIConfig(ctx, flags)
	if err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "failed to load CLI configuration file")
	}
	client, err := httpclient.NewClient(httpclient.WithConfig(conf.Client))
	if err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "failed to create client with provided config")
	}
	return NewTestServiceClient(client), nil
}

type TestServiceCLICommand struct {
	clientProvider CLITestServiceClientProvider
}

func NewTestServiceCLICommand() *cobra.Command {
	return NewTestServiceCLICommandWithClientProvider(NewDefaultCLITestServiceClientProvider())
}

func NewTestServiceCLICommandWithClientProvider(clientProvider CLITestServiceClientProvider) *cobra.Command {
	rootCmd := &cobra.Command{
		Short: "Runs commands on the TestService",
		Use:   "testService",
	}
	rootCmd.PersistentFlags().String("conf", "var/conf/configuration.yml", "The configuration file is optional. The default path is ./var/conf/configuration.yml.")
	rootCmd.PersistentFlags().BoolP("verbose", "v", false, "Enables verbose mode for debugging client connections.")

	cliCommand := TestServiceCLICommand{clientProvider: clientProvider}

	testService_Echo_Cmd := &cobra.Command{
		RunE:  cliCommand.testService_Echo_CmdRun,
		Short: "Calls the echo endpoint.",
		Use:   "echo",
	}
	rootCmd.AddCommand(testService_Echo_Cmd)
	testService_Echo_Cmd.Flags().String("bearer_token", "", "bearer_token is a required field.")

	testService_EchoStrings_Cmd := &cobra.Command{
		RunE:  cliCommand.testService_EchoStrings_CmdRun,
		Short: "Calls the echoStrings endpoint.",
		Use:   "echoStrings",
	}
	rootCmd.AddCommand(testService_EchoStrings_Cmd)
	testService_EchoStrings_Cmd.Flags().String("body", "", "Required. ")

	testService_EchoCustomObject_Cmd := &cobra.Command{
		RunE:  cliCommand.testService_EchoCustomObject_CmdRun,
		Short: "Calls the echoCustomObject endpoint.",
		Use:   "echoCustomObject",
	}
	rootCmd.AddCommand(testService_EchoCustomObject_Cmd)
	testService_EchoCustomObject_Cmd.Flags().String("body", "", "Optional. ")

	testService_EchoOptionalAlias_Cmd := &cobra.Command{
		RunE:  cliCommand.testService_EchoOptionalAlias_CmdRun,
		Short: "Calls the echoOptionalAlias endpoint.",
		Use:   "echoOptionalAlias",
	}
	rootCmd.AddCommand(testService_EchoOptionalAlias_Cmd)
	testService_EchoOptionalAlias_Cmd.Flags().String("body", "", "Optional. ")

	testService_EchoOptionalListAlias_Cmd := &cobra.Command{
		RunE:  cliCommand.testService_EchoOptionalListAlias_CmdRun,
		Short: "Calls the echoOptionalListAlias endpoint.",
		Use:   "echoOptionalListAlias",
	}
	rootCmd.AddCommand(testService_EchoOptionalListAlias_Cmd)
	testService_EchoOptionalListAlias_Cmd.Flags().String("body", "", "Optional. ")

	testService_GetPathParam_Cmd := &cobra.Command{
		RunE:  cliCommand.testService_GetPathParam_CmdRun,
		Short: "Calls the getPathParam endpoint.",
		Use:   "getPathParam",
	}
	rootCmd.AddCommand(testService_GetPathParam_Cmd)
	testService_GetPathParam_Cmd.Flags().String("myPathParam", "", "Required. ")
	testService_GetPathParam_Cmd.Flags().String("bearer_token", "", "bearer_token is a required field.")

	testService_GetPathParamAlias_Cmd := &cobra.Command{
		RunE:  cliCommand.testService_GetPathParamAlias_CmdRun,
		Short: "Calls the getPathParamAlias endpoint.",
		Use:   "getPathParamAlias",
	}
	rootCmd.AddCommand(testService_GetPathParamAlias_Cmd)
	testService_GetPathParamAlias_Cmd.Flags().String("myPathParam", "", "Required. ")
	testService_GetPathParamAlias_Cmd.Flags().String("bearer_token", "", "bearer_token is a required field.")

	testService_QueryParamList_Cmd := &cobra.Command{
		RunE:  cliCommand.testService_QueryParamList_CmdRun,
		Short: "Calls the queryParamList endpoint.",
		Use:   "queryParamList",
	}
	rootCmd.AddCommand(testService_QueryParamList_Cmd)
	testService_QueryParamList_Cmd.Flags().String("myQueryParam1", "", "Required. ")
	testService_QueryParamList_Cmd.Flags().String("bearer_token", "", "bearer_token is a required field.")

	testService_QueryParamListBoolean_Cmd := &cobra.Command{
		RunE:  cliCommand.testService_QueryParamListBoolean_CmdRun,
		Short: "Calls the queryParamListBoolean endpoint.",
		Use:   "queryParamListBoolean",
	}
	rootCmd.AddCommand(testService_QueryParamListBoolean_Cmd)
	testService_QueryParamListBoolean_Cmd.Flags().String("myQueryParam1", "", "Required. ")
	testService_QueryParamListBoolean_Cmd.Flags().String("bearer_token", "", "bearer_token is a required field.")

	testService_QueryParamListDateTime_Cmd := &cobra.Command{
		RunE:  cliCommand.testService_QueryParamListDateTime_CmdRun,
		Short: "Calls the queryParamListDateTime endpoint.",
		Use:   "queryParamListDateTime",
	}
	rootCmd.AddCommand(testService_QueryParamListDateTime_Cmd)
	testService_QueryParamListDateTime_Cmd.Flags().String("myQueryParam1", "", "Required. ")
	testService_QueryParamListDateTime_Cmd.Flags().String("bearer_token", "", "bearer_token is a required field.")

	testService_QueryParamSetDateTime_Cmd := &cobra.Command{
		RunE:  cliCommand.testService_QueryParamSetDateTime_CmdRun,
		Short: "Calls the queryParamSetDateTime endpoint.",
		Use:   "queryParamSetDateTime",
	}
	rootCmd.AddCommand(testService_QueryParamSetDateTime_Cmd)
	testService_QueryParamSetDateTime_Cmd.Flags().String("myQueryParam1", "", "Required. ")
	testService_QueryParamSetDateTime_Cmd.Flags().String("bearer_token", "", "bearer_token is a required field.")

	testService_QueryParamListDouble_Cmd := &cobra.Command{
		RunE:  cliCommand.testService_QueryParamListDouble_CmdRun,
		Short: "Calls the queryParamListDouble endpoint.",
		Use:   "queryParamListDouble",
	}
	rootCmd.AddCommand(testService_QueryParamListDouble_Cmd)
	testService_QueryParamListDouble_Cmd.Flags().String("myQueryParam1", "", "Required. ")
	testService_QueryParamListDouble_Cmd.Flags().String("bearer_token", "", "bearer_token is a required field.")

	testService_QueryParamListInteger_Cmd := &cobra.Command{
		RunE:  cliCommand.testService_QueryParamListInteger_CmdRun,
		Short: "Calls the queryParamListInteger endpoint.",
		Use:   "queryParamListInteger",
	}
	rootCmd.AddCommand(testService_QueryParamListInteger_Cmd)
	testService_QueryParamListInteger_Cmd.Flags().String("myQueryParam1", "", "Required. ")
	testService_QueryParamListInteger_Cmd.Flags().String("bearer_token", "", "bearer_token is a required field.")

	testService_QueryParamListRid_Cmd := &cobra.Command{
		RunE:  cliCommand.testService_QueryParamListRid_CmdRun,
		Short: "Calls the queryParamListRid endpoint.",
		Use:   "queryParamListRid",
	}
	rootCmd.AddCommand(testService_QueryParamListRid_Cmd)
	testService_QueryParamListRid_Cmd.Flags().String("myQueryParam1", "", "Required. ")
	testService_QueryParamListRid_Cmd.Flags().String("bearer_token", "", "bearer_token is a required field.")

	testService_QueryParamListSafeLong_Cmd := &cobra.Command{
		RunE:  cliCommand.testService_QueryParamListSafeLong_CmdRun,
		Short: "Calls the queryParamListSafeLong endpoint.",
		Use:   "queryParamListSafeLong",
	}
	rootCmd.AddCommand(testService_QueryParamListSafeLong_Cmd)
	testService_QueryParamListSafeLong_Cmd.Flags().String("myQueryParam1", "", "Required. ")
	testService_QueryParamListSafeLong_Cmd.Flags().String("bearer_token", "", "bearer_token is a required field.")

	testService_QueryParamListString_Cmd := &cobra.Command{
		RunE:  cliCommand.testService_QueryParamListString_CmdRun,
		Short: "Calls the queryParamListString endpoint.",
		Use:   "queryParamListString",
	}
	rootCmd.AddCommand(testService_QueryParamListString_Cmd)
	testService_QueryParamListString_Cmd.Flags().String("myQueryParam1", "", "Required. ")
	testService_QueryParamListString_Cmd.Flags().String("bearer_token", "", "bearer_token is a required field.")

	testService_QueryParamListUuid_Cmd := &cobra.Command{
		RunE:  cliCommand.testService_QueryParamListUuid_CmdRun,
		Short: "Calls the queryParamListUuid endpoint.",
		Use:   "queryParamListUuid",
	}
	rootCmd.AddCommand(testService_QueryParamListUuid_Cmd)
	testService_QueryParamListUuid_Cmd.Flags().String("myQueryParam1", "", "Required. ")
	testService_QueryParamListUuid_Cmd.Flags().String("bearer_token", "", "bearer_token is a required field.")

	testService_QueryParamExternalString_Cmd := &cobra.Command{
		RunE:  cliCommand.testService_QueryParamExternalString_CmdRun,
		Short: "Calls the queryParamExternalString endpoint.",
		Use:   "queryParamExternalString",
	}
	rootCmd.AddCommand(testService_QueryParamExternalString_Cmd)
	testService_QueryParamExternalString_Cmd.Flags().String("myQueryParam1", "", "Required. ")
	testService_QueryParamExternalString_Cmd.Flags().String("bearer_token", "", "bearer_token is a required field.")

	testService_QueryParamExternalInteger_Cmd := &cobra.Command{
		RunE:  cliCommand.testService_QueryParamExternalInteger_CmdRun,
		Short: "Calls the queryParamExternalInteger endpoint.",
		Use:   "queryParamExternalInteger",
	}
	rootCmd.AddCommand(testService_QueryParamExternalInteger_Cmd)
	testService_QueryParamExternalInteger_Cmd.Flags().String("myQueryParam1", "", "Required. ")
	testService_QueryParamExternalInteger_Cmd.Flags().String("bearer_token", "", "bearer_token is a required field.")

	testService_PathParamExternalString_Cmd := &cobra.Command{
		RunE:  cliCommand.testService_PathParamExternalString_CmdRun,
		Short: "Calls the pathParamExternalString endpoint.",
		Use:   "pathParamExternalString",
	}
	rootCmd.AddCommand(testService_PathParamExternalString_Cmd)
	testService_PathParamExternalString_Cmd.Flags().String("myPathParam1", "", "Required. ")
	testService_PathParamExternalString_Cmd.Flags().String("bearer_token", "", "bearer_token is a required field.")

	testService_PathParamExternalInteger_Cmd := &cobra.Command{
		RunE:  cliCommand.testService_PathParamExternalInteger_CmdRun,
		Short: "Calls the pathParamExternalInteger endpoint.",
		Use:   "pathParamExternalInteger",
	}
	rootCmd.AddCommand(testService_PathParamExternalInteger_Cmd)
	testService_PathParamExternalInteger_Cmd.Flags().String("myPathParam1", "", "Required. ")
	testService_PathParamExternalInteger_Cmd.Flags().String("bearer_token", "", "bearer_token is a required field.")

	testService_PostPathParam_Cmd := &cobra.Command{
		RunE:  cliCommand.testService_PostPathParam_CmdRun,
		Short: "Calls the postPathParam endpoint.",
		Use:   "postPathParam",
	}
	rootCmd.AddCommand(testService_PostPathParam_Cmd)
	testService_PostPathParam_Cmd.Flags().String("myPathParam1", "", "Required. ")
	testService_PostPathParam_Cmd.Flags().String("myPathParam2", "", "Required. ")
	testService_PostPathParam_Cmd.Flags().String("myBodyParam", "", "Required. ")
	testService_PostPathParam_Cmd.Flags().String("myQueryParam1", "", "Required. ")
	testService_PostPathParam_Cmd.Flags().String("myQueryParam2", "", "Required. ")
	testService_PostPathParam_Cmd.Flags().String("myQueryParam3", "", "Required. ")
	testService_PostPathParam_Cmd.Flags().String("myQueryParam4", "", "Optional. ")
	testService_PostPathParam_Cmd.Flags().String("myQueryParam5", "", "Optional. ")
	testService_PostPathParam_Cmd.Flags().String("myQueryParam6", "", "Optional. ")
	testService_PostPathParam_Cmd.Flags().String("myHeaderParam1", "", "Required. ")
	testService_PostPathParam_Cmd.Flags().String("myHeaderParam2", "", "Optional. ")
	testService_PostPathParam_Cmd.Flags().String("bearer_token", "", "bearer_token is a required field.")

	testService_PostSafeParams_Cmd := &cobra.Command{
		RunE:  cliCommand.testService_PostSafeParams_CmdRun,
		Short: "Calls the postSafeParams endpoint.",
		Use:   "postSafeParams",
	}
	rootCmd.AddCommand(testService_PostSafeParams_Cmd)
	testService_PostSafeParams_Cmd.Flags().String("myPathParam1", "", "Required. ")
	testService_PostSafeParams_Cmd.Flags().String("myPathParam2", "", "Required. ")
	testService_PostSafeParams_Cmd.Flags().String("myBodyParam", "", "Required. ")
	testService_PostSafeParams_Cmd.Flags().String("myQueryParam1", "", "Required. ")
	testService_PostSafeParams_Cmd.Flags().String("myQueryParam2", "", "Required. ")
	testService_PostSafeParams_Cmd.Flags().String("myQueryParam3", "", "Required. ")
	testService_PostSafeParams_Cmd.Flags().String("myQueryParam4", "", "Optional. ")
	testService_PostSafeParams_Cmd.Flags().String("myQueryParam5", "", "Optional. ")
	testService_PostSafeParams_Cmd.Flags().String("myHeaderParam1", "", "Required. ")
	testService_PostSafeParams_Cmd.Flags().String("myHeaderParam2", "", "Optional. ")
	testService_PostSafeParams_Cmd.Flags().String("bearer_token", "", "bearer_token is a required field.")

	testService_Bytes_Cmd := &cobra.Command{
		RunE:  cliCommand.testService_Bytes_CmdRun,
		Short: "Calls the bytes endpoint.",
		Use:   "bytes",
	}
	rootCmd.AddCommand(testService_Bytes_Cmd)

	testService_GetBinary_Cmd := &cobra.Command{
		RunE:  cliCommand.testService_GetBinary_CmdRun,
		Short: "Calls the getBinary endpoint.",
		Use:   "getBinary",
	}
	rootCmd.AddCommand(testService_GetBinary_Cmd)

	testService_PostBinary_Cmd := &cobra.Command{
		RunE:  cliCommand.testService_PostBinary_CmdRun,
		Short: "Calls the postBinary endpoint.",
		Use:   "postBinary",
	}
	rootCmd.AddCommand(testService_PostBinary_Cmd)
	testService_PostBinary_Cmd.Flags().String("myBytes", "", "Required. ")

	testService_PutBinary_Cmd := &cobra.Command{
		RunE:  cliCommand.testService_PutBinary_CmdRun,
		Short: "Calls the putBinary endpoint.",
		Use:   "putBinary",
	}
	rootCmd.AddCommand(testService_PutBinary_Cmd)
	testService_PutBinary_Cmd.Flags().String("myBytes", "", "Required. ")

	testService_GetOptionalBinary_Cmd := &cobra.Command{
		RunE:  cliCommand.testService_GetOptionalBinary_CmdRun,
		Short: "Calls the getOptionalBinary endpoint.",
		Use:   "getOptionalBinary",
	}
	rootCmd.AddCommand(testService_GetOptionalBinary_Cmd)

	testService_Chan_Cmd := &cobra.Command{
		RunE:  cliCommand.testService_Chan_CmdRun,
		Short: "An endpoint that uses go keywords",
		Use:   "chan",
	}
	rootCmd.AddCommand(testService_Chan_Cmd)
	testService_Chan_Cmd.Flags().String("var", "", "Required. ")
	testService_Chan_Cmd.Flags().String("import", "", "Required. ")
	testService_Chan_Cmd.Flags().String("type", "", "Required. ")
	testService_Chan_Cmd.Flags().String("return", "", "Required. ")
	testService_Chan_Cmd.Flags().String("http", "", "Required. ")
	testService_Chan_Cmd.Flags().String("json", "", "Required. ")
	testService_Chan_Cmd.Flags().String("req", "", "Required. ")
	testService_Chan_Cmd.Flags().String("rw", "", "Required. ")

	return rootCmd
}

func (c TestServiceCLICommand) testService_Echo_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	bearer_tokenRaw, err := flags.GetString("bearer_token")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument __authVar")
	}
	if bearer_tokenRaw == "" {
		return werror.ErrorWithContextParams(ctx, "bearer_token is a required argument")
	}
	__authVarArg := bearertoken.Token(bearer_tokenRaw)
	return client.Echo(ctx, __authVarArg)
}

func (c TestServiceCLICommand) testService_EchoStrings_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	bodyRaw, err := flags.GetString("body")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument body")
	}
	if bodyRaw == "" {
		return werror.ErrorWithContextParams(ctx, "body is a required argument")
	}
	var bodyArg []string
	var bodyArgReader io.ReadCloser
	switch {
	case bodyRaw == "@-":
		bodyArgReader = io.NopCloser(cmd.InOrStdin())
	case strings.HasPrefix(bodyRaw, "@"):
		bodyArgReader, err = os.Open(strings.TrimSpace(bodyRaw[1:]))
		if err != nil {
			return werror.WrapWithContextParams(ctx, err, "failed to open file for argument body")
		}
	default:
		bodyArgReader = io.NopCloser(bytes.NewReader([]byte(bodyRaw)))
	}
	defer bodyArgReader.Close()
	if err := codecs.JSON.Decode(bodyArgReader, &bodyArg); err != nil {
		return werror.WrapWithContextParams(ctx, err, "invalid value for body argument")
	}

	result, err := client.EchoStrings(ctx, bodyArg)
	if err != nil {
		return err
	}
	resultBytes, err := json.MarshalIndent(result, "", "    ")
	if err != nil {
		fmt.Printf("Failed to marshal to json with err: %v\n\nPrinting as string:\n%v\n", err, result)
		return nil
	}
	fmt.Fprintf(cmd.OutOrStdout(), "%v\n", string(resultBytes))
	return nil
}

func (c TestServiceCLICommand) testService_EchoCustomObject_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	bodyRaw, err := flags.GetString("body")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument body")
	}
	var bodyArg *CustomObject
	if bodyRaw != "" {
		var bodyArgReader io.ReadCloser
		switch {
		case bodyRaw == "@-":
			bodyArgReader = io.NopCloser(cmd.InOrStdin())
		case strings.HasPrefix(bodyRaw, "@"):
			bodyArgReader, err = os.Open(strings.TrimSpace(bodyRaw[1:]))
			if err != nil {
				return werror.WrapWithContextParams(ctx, err, "failed to open file for argument body")
			}
		default:
			bodyArgReader = io.NopCloser(bytes.NewReader([]byte(bodyRaw)))
		}
		defer bodyArgReader.Close()
		if err := codecs.JSON.Decode(bodyArgReader, &bodyArg); err != nil {
			return werror.WrapWithContextParams(ctx, err, "invalid value for body argument")
		}
	}

	result, err := client.EchoCustomObject(ctx, bodyArg)
	if err != nil {
		return err
	}
	resultBytes, err := json.MarshalIndent(result, "", "    ")
	if err != nil {
		fmt.Printf("Failed to marshal to json with err: %v\n\nPrinting as string:\n%v\n", err, result)
		return nil
	}
	fmt.Fprintf(cmd.OutOrStdout(), "%v\n", string(resultBytes))
	return nil
}

func (c TestServiceCLICommand) testService_EchoOptionalAlias_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	bodyRaw, err := flags.GetString("body")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument body")
	}
	var bodyArgValue *int
	if bodyArgValueStr1 := bodyRaw; bodyArgValueStr1 != "" {
		bodyArgValueInternal1, err := strconv.Atoi(bodyArgValueStr1)
		if err != nil {
			return werror.WrapWithContextParams(ctx, errors.WrapWithInvalidArgument(err), "failed to parse \"body\" as integer")
		}
		bodyArgValue = &bodyArgValueInternal1
	}
	bodyArg := OptionalIntegerAlias{Value: bodyArgValue}

	result, err := client.EchoOptionalAlias(ctx, bodyArg)
	if err != nil {
		return err
	}
	resultBytes, err := json.MarshalIndent(result, "", "    ")
	if err != nil {
		fmt.Printf("Failed to marshal to json with err: %v\n\nPrinting as string:\n%v\n", err, result)
		return nil
	}
	fmt.Fprintf(cmd.OutOrStdout(), "%v\n", string(resultBytes))
	return nil
}

func (c TestServiceCLICommand) testService_EchoOptionalListAlias_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	bodyRaw, err := flags.GetString("body")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument body")
	}
	var bodyArg OptionalListAlias
	if bodyRaw != "" {
		var bodyArgReader io.ReadCloser
		switch {
		case bodyRaw == "@-":
			bodyArgReader = io.NopCloser(cmd.InOrStdin())
		case strings.HasPrefix(bodyRaw, "@"):
			bodyArgReader, err = os.Open(strings.TrimSpace(bodyRaw[1:]))
			if err != nil {
				return werror.WrapWithContextParams(ctx, err, "failed to open file for argument body")
			}
		default:
			bodyArgReader = io.NopCloser(bytes.NewReader([]byte(bodyRaw)))
		}
		defer bodyArgReader.Close()
		if err := codecs.JSON.Decode(bodyArgReader, &bodyArg); err != nil {
			return werror.WrapWithContextParams(ctx, err, "invalid value for body argument")
		}
	}

	result, err := client.EchoOptionalListAlias(ctx, bodyArg)
	if err != nil {
		return err
	}
	resultBytes, err := json.MarshalIndent(result, "", "    ")
	if err != nil {
		fmt.Printf("Failed to marshal to json with err: %v\n\nPrinting as string:\n%v\n", err, result)
		return nil
	}
	fmt.Fprintf(cmd.OutOrStdout(), "%v\n", string(resultBytes))
	return nil
}

func (c TestServiceCLICommand) testService_GetPathParam_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	bearer_tokenRaw, err := flags.GetString("bearer_token")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument __authVar")
	}
	if bearer_tokenRaw == "" {
		return werror.ErrorWithContextParams(ctx, "bearer_token is a required argument")
	}
	__authVarArg := bearertoken.Token(bearer_tokenRaw)
	myPathParamRaw, err := flags.GetString("myPathParam")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myPathParam")
	}
	if myPathParamRaw == "" {
		return werror.ErrorWithContextParams(ctx, "myPathParam is a required argument")
	}
	myPathParamArg := myPathParamRaw

	return client.GetPathParam(ctx, __authVarArg, myPathParamArg)
}

func (c TestServiceCLICommand) testService_GetPathParamAlias_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	bearer_tokenRaw, err := flags.GetString("bearer_token")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument __authVar")
	}
	if bearer_tokenRaw == "" {
		return werror.ErrorWithContextParams(ctx, "bearer_token is a required argument")
	}
	__authVarArg := bearertoken.Token(bearer_tokenRaw)
	myPathParamRaw, err := flags.GetString("myPathParam")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myPathParam")
	}
	if myPathParamRaw == "" {
		return werror.ErrorWithContextParams(ctx, "myPathParam is a required argument")
	}
	myPathParamArg := StringAlias(myPathParamRaw)

	return client.GetPathParamAlias(ctx, __authVarArg, myPathParamArg)
}

func (c TestServiceCLICommand) testService_QueryParamList_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	bearer_tokenRaw, err := flags.GetString("bearer_token")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument __authVar")
	}
	if bearer_tokenRaw == "" {
		return werror.ErrorWithContextParams(ctx, "bearer_token is a required argument")
	}
	__authVarArg := bearertoken.Token(bearer_tokenRaw)
	myQueryParam1Raw, err := flags.GetString("myQueryParam1")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myQueryParam1")
	}
	if myQueryParam1Raw == "" {
		return werror.ErrorWithContextParams(ctx, "myQueryParam1 is a required argument")
	}
	var myQueryParam1Arg []string
	var myQueryParam1ArgReader io.ReadCloser
	switch {
	case myQueryParam1Raw == "@-":
		myQueryParam1ArgReader = io.NopCloser(cmd.InOrStdin())
	case strings.HasPrefix(myQueryParam1Raw, "@"):
		myQueryParam1ArgReader, err = os.Open(strings.TrimSpace(myQueryParam1Raw[1:]))
		if err != nil {
			return werror.WrapWithContextParams(ctx, err, "failed to open file for argument myQueryParam1")
		}
	default:
		myQueryParam1ArgReader = io.NopCloser(bytes.NewReader([]byte(myQueryParam1Raw)))
	}
	defer myQueryParam1ArgReader.Close()
	if err := codecs.JSON.Decode(myQueryParam1ArgReader, &myQueryParam1Arg); err != nil {
		return werror.WrapWithContextParams(ctx, err, "invalid value for myQueryParam1 argument")
	}

	return client.QueryParamList(ctx, __authVarArg, myQueryParam1Arg)
}

func (c TestServiceCLICommand) testService_QueryParamListBoolean_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	bearer_tokenRaw, err := flags.GetString("bearer_token")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument __authVar")
	}
	if bearer_tokenRaw == "" {
		return werror.ErrorWithContextParams(ctx, "bearer_token is a required argument")
	}
	__authVarArg := bearertoken.Token(bearer_tokenRaw)
	myQueryParam1Raw, err := flags.GetString("myQueryParam1")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myQueryParam1")
	}
	if myQueryParam1Raw == "" {
		return werror.ErrorWithContextParams(ctx, "myQueryParam1 is a required argument")
	}
	var myQueryParam1Arg []bool
	var myQueryParam1ArgReader io.ReadCloser
	switch {
	case myQueryParam1Raw == "@-":
		myQueryParam1ArgReader = io.NopCloser(cmd.InOrStdin())
	case strings.HasPrefix(myQueryParam1Raw, "@"):
		myQueryParam1ArgReader, err = os.Open(strings.TrimSpace(myQueryParam1Raw[1:]))
		if err != nil {
			return werror.WrapWithContextParams(ctx, err, "failed to open file for argument myQueryParam1")
		}
	default:
		myQueryParam1ArgReader = io.NopCloser(bytes.NewReader([]byte(myQueryParam1Raw)))
	}
	defer myQueryParam1ArgReader.Close()
	if err := codecs.JSON.Decode(myQueryParam1ArgReader, &myQueryParam1Arg); err != nil {
		return werror.WrapWithContextParams(ctx, err, "invalid value for myQueryParam1 argument")
	}

	return client.QueryParamListBoolean(ctx, __authVarArg, myQueryParam1Arg)
}

func (c TestServiceCLICommand) testService_QueryParamListDateTime_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	bearer_tokenRaw, err := flags.GetString("bearer_token")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument __authVar")
	}
	if bearer_tokenRaw == "" {
		return werror.ErrorWithContextParams(ctx, "bearer_token is a required argument")
	}
	__authVarArg := bearertoken.Token(bearer_tokenRaw)
	myQueryParam1Raw, err := flags.GetString("myQueryParam1")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myQueryParam1")
	}
	if myQueryParam1Raw == "" {
		return werror.ErrorWithContextParams(ctx, "myQueryParam1 is a required argument")
	}
	var myQueryParam1Arg []datetime.DateTime
	var myQueryParam1ArgReader io.ReadCloser
	switch {
	case myQueryParam1Raw == "@-":
		myQueryParam1ArgReader = io.NopCloser(cmd.InOrStdin())
	case strings.HasPrefix(myQueryParam1Raw, "@"):
		myQueryParam1ArgReader, err = os.Open(strings.TrimSpace(myQueryParam1Raw[1:]))
		if err != nil {
			return werror.WrapWithContextParams(ctx, err, "failed to open file for argument myQueryParam1")
		}
	default:
		myQueryParam1ArgReader = io.NopCloser(bytes.NewReader([]byte(myQueryParam1Raw)))
	}
	defer myQueryParam1ArgReader.Close()
	if err := codecs.JSON.Decode(myQueryParam1ArgReader, &myQueryParam1Arg); err != nil {
		return werror.WrapWithContextParams(ctx, err, "invalid value for myQueryParam1 argument")
	}

	return client.QueryParamListDateTime(ctx, __authVarArg, myQueryParam1Arg)
}

func (c TestServiceCLICommand) testService_QueryParamSetDateTime_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	bearer_tokenRaw, err := flags.GetString("bearer_token")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument __authVar")
	}
	if bearer_tokenRaw == "" {
		return werror.ErrorWithContextParams(ctx, "bearer_token is a required argument")
	}
	__authVarArg := bearertoken.Token(bearer_tokenRaw)
	myQueryParam1Raw, err := flags.GetString("myQueryParam1")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myQueryParam1")
	}
	if myQueryParam1Raw == "" {
		return werror.ErrorWithContextParams(ctx, "myQueryParam1 is a required argument")
	}
	var myQueryParam1Arg []datetime.DateTime
	var myQueryParam1ArgReader io.ReadCloser
	switch {
	case myQueryParam1Raw == "@-":
		myQueryParam1ArgReader = io.NopCloser(cmd.InOrStdin())
	case strings.HasPrefix(myQueryParam1Raw, "@"):
		myQueryParam1ArgReader, err = os.Open(strings.TrimSpace(myQueryParam1Raw[1:]))
		if err != nil {
			return werror.WrapWithContextParams(ctx, err, "failed to open file for argument myQueryParam1")
		}
	default:
		myQueryParam1ArgReader = io.NopCloser(bytes.NewReader([]byte(myQueryParam1Raw)))
	}
	defer myQueryParam1ArgReader.Close()
	if err := codecs.JSON.Decode(myQueryParam1ArgReader, &myQueryParam1Arg); err != nil {
		return werror.WrapWithContextParams(ctx, err, "invalid value for myQueryParam1 argument")
	}

	result, err := client.QueryParamSetDateTime(ctx, __authVarArg, myQueryParam1Arg)
	if err != nil {
		return err
	}
	resultBytes, err := json.MarshalIndent(result, "", "    ")
	if err != nil {
		fmt.Printf("Failed to marshal to json with err: %v\n\nPrinting as string:\n%v\n", err, result)
		return nil
	}
	fmt.Fprintf(cmd.OutOrStdout(), "%v\n", string(resultBytes))
	return nil
}

func (c TestServiceCLICommand) testService_QueryParamListDouble_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	bearer_tokenRaw, err := flags.GetString("bearer_token")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument __authVar")
	}
	if bearer_tokenRaw == "" {
		return werror.ErrorWithContextParams(ctx, "bearer_token is a required argument")
	}
	__authVarArg := bearertoken.Token(bearer_tokenRaw)
	myQueryParam1Raw, err := flags.GetString("myQueryParam1")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myQueryParam1")
	}
	if myQueryParam1Raw == "" {
		return werror.ErrorWithContextParams(ctx, "myQueryParam1 is a required argument")
	}
	var myQueryParam1Arg []float64
	var myQueryParam1ArgReader io.ReadCloser
	switch {
	case myQueryParam1Raw == "@-":
		myQueryParam1ArgReader = io.NopCloser(cmd.InOrStdin())
	case strings.HasPrefix(myQueryParam1Raw, "@"):
		myQueryParam1ArgReader, err = os.Open(strings.TrimSpace(myQueryParam1Raw[1:]))
		if err != nil {
			return werror.WrapWithContextParams(ctx, err, "failed to open file for argument myQueryParam1")
		}
	default:
		myQueryParam1ArgReader = io.NopCloser(bytes.NewReader([]byte(myQueryParam1Raw)))
	}
	defer myQueryParam1ArgReader.Close()
	if err := codecs.JSON.Decode(myQueryParam1ArgReader, &myQueryParam1Arg); err != nil {
		return werror.WrapWithContextParams(ctx, err, "invalid value for myQueryParam1 argument")
	}

	return client.QueryParamListDouble(ctx, __authVarArg, myQueryParam1Arg)
}

func (c TestServiceCLICommand) testService_QueryParamListInteger_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	bearer_tokenRaw, err := flags.GetString("bearer_token")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument __authVar")
	}
	if bearer_tokenRaw == "" {
		return werror.ErrorWithContextParams(ctx, "bearer_token is a required argument")
	}
	__authVarArg := bearertoken.Token(bearer_tokenRaw)
	myQueryParam1Raw, err := flags.GetString("myQueryParam1")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myQueryParam1")
	}
	if myQueryParam1Raw == "" {
		return werror.ErrorWithContextParams(ctx, "myQueryParam1 is a required argument")
	}
	var myQueryParam1Arg []int
	var myQueryParam1ArgReader io.ReadCloser
	switch {
	case myQueryParam1Raw == "@-":
		myQueryParam1ArgReader = io.NopCloser(cmd.InOrStdin())
	case strings.HasPrefix(myQueryParam1Raw, "@"):
		myQueryParam1ArgReader, err = os.Open(strings.TrimSpace(myQueryParam1Raw[1:]))
		if err != nil {
			return werror.WrapWithContextParams(ctx, err, "failed to open file for argument myQueryParam1")
		}
	default:
		myQueryParam1ArgReader = io.NopCloser(bytes.NewReader([]byte(myQueryParam1Raw)))
	}
	defer myQueryParam1ArgReader.Close()
	if err := codecs.JSON.Decode(myQueryParam1ArgReader, &myQueryParam1Arg); err != nil {
		return werror.WrapWithContextParams(ctx, err, "invalid value for myQueryParam1 argument")
	}

	return client.QueryParamListInteger(ctx, __authVarArg, myQueryParam1Arg)
}

func (c TestServiceCLICommand) testService_QueryParamListRid_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	bearer_tokenRaw, err := flags.GetString("bearer_token")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument __authVar")
	}
	if bearer_tokenRaw == "" {
		return werror.ErrorWithContextParams(ctx, "bearer_token is a required argument")
	}
	__authVarArg := bearertoken.Token(bearer_tokenRaw)
	myQueryParam1Raw, err := flags.GetString("myQueryParam1")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myQueryParam1")
	}
	if myQueryParam1Raw == "" {
		return werror.ErrorWithContextParams(ctx, "myQueryParam1 is a required argument")
	}
	var myQueryParam1Arg []rid.ResourceIdentifier
	var myQueryParam1ArgReader io.ReadCloser
	switch {
	case myQueryParam1Raw == "@-":
		myQueryParam1ArgReader = io.NopCloser(cmd.InOrStdin())
	case strings.HasPrefix(myQueryParam1Raw, "@"):
		myQueryParam1ArgReader, err = os.Open(strings.TrimSpace(myQueryParam1Raw[1:]))
		if err != nil {
			return werror.WrapWithContextParams(ctx, err, "failed to open file for argument myQueryParam1")
		}
	default:
		myQueryParam1ArgReader = io.NopCloser(bytes.NewReader([]byte(myQueryParam1Raw)))
	}
	defer myQueryParam1ArgReader.Close()
	if err := codecs.JSON.Decode(myQueryParam1ArgReader, &myQueryParam1Arg); err != nil {
		return werror.WrapWithContextParams(ctx, err, "invalid value for myQueryParam1 argument")
	}

	return client.QueryParamListRid(ctx, __authVarArg, myQueryParam1Arg)
}

func (c TestServiceCLICommand) testService_QueryParamListSafeLong_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	bearer_tokenRaw, err := flags.GetString("bearer_token")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument __authVar")
	}
	if bearer_tokenRaw == "" {
		return werror.ErrorWithContextParams(ctx, "bearer_token is a required argument")
	}
	__authVarArg := bearertoken.Token(bearer_tokenRaw)
	myQueryParam1Raw, err := flags.GetString("myQueryParam1")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myQueryParam1")
	}
	if myQueryParam1Raw == "" {
		return werror.ErrorWithContextParams(ctx, "myQueryParam1 is a required argument")
	}
	var myQueryParam1Arg []safelong.SafeLong
	var myQueryParam1ArgReader io.ReadCloser
	switch {
	case myQueryParam1Raw == "@-":
		myQueryParam1ArgReader = io.NopCloser(cmd.InOrStdin())
	case strings.HasPrefix(myQueryParam1Raw, "@"):
		myQueryParam1ArgReader, err = os.Open(strings.TrimSpace(myQueryParam1Raw[1:]))
		if err != nil {
			return werror.WrapWithContextParams(ctx, err, "failed to open file for argument myQueryParam1")
		}
	default:
		myQueryParam1ArgReader = io.NopCloser(bytes.NewReader([]byte(myQueryParam1Raw)))
	}
	defer myQueryParam1ArgReader.Close()
	if err := codecs.JSON.Decode(myQueryParam1ArgReader, &myQueryParam1Arg); err != nil {
		return werror.WrapWithContextParams(ctx, err, "invalid value for myQueryParam1 argument")
	}

	return client.QueryParamListSafeLong(ctx, __authVarArg, myQueryParam1Arg)
}

func (c TestServiceCLICommand) testService_QueryParamListString_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	bearer_tokenRaw, err := flags.GetString("bearer_token")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument __authVar")
	}
	if bearer_tokenRaw == "" {
		return werror.ErrorWithContextParams(ctx, "bearer_token is a required argument")
	}
	__authVarArg := bearertoken.Token(bearer_tokenRaw)
	myQueryParam1Raw, err := flags.GetString("myQueryParam1")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myQueryParam1")
	}
	if myQueryParam1Raw == "" {
		return werror.ErrorWithContextParams(ctx, "myQueryParam1 is a required argument")
	}
	var myQueryParam1Arg []string
	var myQueryParam1ArgReader io.ReadCloser
	switch {
	case myQueryParam1Raw == "@-":
		myQueryParam1ArgReader = io.NopCloser(cmd.InOrStdin())
	case strings.HasPrefix(myQueryParam1Raw, "@"):
		myQueryParam1ArgReader, err = os.Open(strings.TrimSpace(myQueryParam1Raw[1:]))
		if err != nil {
			return werror.WrapWithContextParams(ctx, err, "failed to open file for argument myQueryParam1")
		}
	default:
		myQueryParam1ArgReader = io.NopCloser(bytes.NewReader([]byte(myQueryParam1Raw)))
	}
	defer myQueryParam1ArgReader.Close()
	if err := codecs.JSON.Decode(myQueryParam1ArgReader, &myQueryParam1Arg); err != nil {
		return werror.WrapWithContextParams(ctx, err, "invalid value for myQueryParam1 argument")
	}

	return client.QueryParamListString(ctx, __authVarArg, myQueryParam1Arg)
}

func (c TestServiceCLICommand) testService_QueryParamListUuid_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	bearer_tokenRaw, err := flags.GetString("bearer_token")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument __authVar")
	}
	if bearer_tokenRaw == "" {
		return werror.ErrorWithContextParams(ctx, "bearer_token is a required argument")
	}
	__authVarArg := bearertoken.Token(bearer_tokenRaw)
	myQueryParam1Raw, err := flags.GetString("myQueryParam1")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myQueryParam1")
	}
	if myQueryParam1Raw == "" {
		return werror.ErrorWithContextParams(ctx, "myQueryParam1 is a required argument")
	}
	var myQueryParam1Arg []uuid.UUID
	var myQueryParam1ArgReader io.ReadCloser
	switch {
	case myQueryParam1Raw == "@-":
		myQueryParam1ArgReader = io.NopCloser(cmd.InOrStdin())
	case strings.HasPrefix(myQueryParam1Raw, "@"):
		myQueryParam1ArgReader, err = os.Open(strings.TrimSpace(myQueryParam1Raw[1:]))
		if err != nil {
			return werror.WrapWithContextParams(ctx, err, "failed to open file for argument myQueryParam1")
		}
	default:
		myQueryParam1ArgReader = io.NopCloser(bytes.NewReader([]byte(myQueryParam1Raw)))
	}
	defer myQueryParam1ArgReader.Close()
	if err := codecs.JSON.Decode(myQueryParam1ArgReader, &myQueryParam1Arg); err != nil {
		return werror.WrapWithContextParams(ctx, err, "invalid value for myQueryParam1 argument")
	}

	return client.QueryParamListUuid(ctx, __authVarArg, myQueryParam1Arg)
}

func (c TestServiceCLICommand) testService_QueryParamExternalString_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	bearer_tokenRaw, err := flags.GetString("bearer_token")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument __authVar")
	}
	if bearer_tokenRaw == "" {
		return werror.ErrorWithContextParams(ctx, "bearer_token is a required argument")
	}
	__authVarArg := bearertoken.Token(bearer_tokenRaw)
	myQueryParam1Raw, err := flags.GetString("myQueryParam1")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myQueryParam1")
	}
	if myQueryParam1Raw == "" {
		return werror.ErrorWithContextParams(ctx, "myQueryParam1 is a required argument")
	}
	myQueryParam1Arg := myQueryParam1Raw

	return client.QueryParamExternalString(ctx, __authVarArg, myQueryParam1Arg)
}

func (c TestServiceCLICommand) testService_QueryParamExternalInteger_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	bearer_tokenRaw, err := flags.GetString("bearer_token")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument __authVar")
	}
	if bearer_tokenRaw == "" {
		return werror.ErrorWithContextParams(ctx, "bearer_token is a required argument")
	}
	__authVarArg := bearertoken.Token(bearer_tokenRaw)
	myQueryParam1Raw, err := flags.GetString("myQueryParam1")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myQueryParam1")
	}
	if myQueryParam1Raw == "" {
		return werror.ErrorWithContextParams(ctx, "myQueryParam1 is a required argument")
	}
	myQueryParam1Arg, err := strconv.Atoi(myQueryParam1Raw)
	if err != nil {
		return werror.WrapWithContextParams(ctx, errors.WrapWithInvalidArgument(err), "failed to parse \"myQueryParam1\" as integer")
	}

	return client.QueryParamExternalInteger(ctx, __authVarArg, myQueryParam1Arg)
}

func (c TestServiceCLICommand) testService_PathParamExternalString_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	bearer_tokenRaw, err := flags.GetString("bearer_token")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument __authVar")
	}
	if bearer_tokenRaw == "" {
		return werror.ErrorWithContextParams(ctx, "bearer_token is a required argument")
	}
	__authVarArg := bearertoken.Token(bearer_tokenRaw)
	myPathParam1Raw, err := flags.GetString("myPathParam1")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myPathParam1")
	}
	if myPathParam1Raw == "" {
		return werror.ErrorWithContextParams(ctx, "myPathParam1 is a required argument")
	}
	myPathParam1Arg := myPathParam1Raw

	return client.PathParamExternalString(ctx, __authVarArg, myPathParam1Arg)
}

func (c TestServiceCLICommand) testService_PathParamExternalInteger_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	bearer_tokenRaw, err := flags.GetString("bearer_token")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument __authVar")
	}
	if bearer_tokenRaw == "" {
		return werror.ErrorWithContextParams(ctx, "bearer_token is a required argument")
	}
	__authVarArg := bearertoken.Token(bearer_tokenRaw)
	myPathParam1Raw, err := flags.GetString("myPathParam1")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myPathParam1")
	}
	if myPathParam1Raw == "" {
		return werror.ErrorWithContextParams(ctx, "myPathParam1 is a required argument")
	}
	myPathParam1Arg, err := strconv.Atoi(myPathParam1Raw)
	if err != nil {
		return werror.WrapWithContextParams(ctx, errors.WrapWithInvalidArgument(err), "failed to parse \"myPathParam1\" as integer")
	}

	return client.PathParamExternalInteger(ctx, __authVarArg, myPathParam1Arg)
}

func (c TestServiceCLICommand) testService_PostPathParam_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	bearer_tokenRaw, err := flags.GetString("bearer_token")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument __authVar")
	}
	if bearer_tokenRaw == "" {
		return werror.ErrorWithContextParams(ctx, "bearer_token is a required argument")
	}
	__authVarArg := bearertoken.Token(bearer_tokenRaw)
	myPathParam1Raw, err := flags.GetString("myPathParam1")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myPathParam1")
	}
	if myPathParam1Raw == "" {
		return werror.ErrorWithContextParams(ctx, "myPathParam1 is a required argument")
	}
	myPathParam1Arg := myPathParam1Raw

	myPathParam2Raw, err := flags.GetString("myPathParam2")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myPathParam2")
	}
	if myPathParam2Raw == "" {
		return werror.ErrorWithContextParams(ctx, "myPathParam2 is a required argument")
	}
	myPathParam2Arg, err := strconv.ParseBool(myPathParam2Raw)
	if err != nil {
		return werror.WrapWithContextParams(ctx, errors.WrapWithInvalidArgument(err), "failed to parse \"myPathParam2\" as boolean")
	}

	myBodyParamRaw, err := flags.GetString("myBodyParam")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myBodyParam")
	}
	if myBodyParamRaw == "" {
		return werror.ErrorWithContextParams(ctx, "myBodyParam is a required argument")
	}
	var myBodyParamArg CustomObject
	var myBodyParamArgReader io.ReadCloser
	switch {
	case myBodyParamRaw == "@-":
		myBodyParamArgReader = io.NopCloser(cmd.InOrStdin())
	case strings.HasPrefix(myBodyParamRaw, "@"):
		myBodyParamArgReader, err = os.Open(strings.TrimSpace(myBodyParamRaw[1:]))
		if err != nil {
			return werror.WrapWithContextParams(ctx, err, "failed to open file for argument myBodyParam")
		}
	default:
		myBodyParamArgReader = io.NopCloser(bytes.NewReader([]byte(myBodyParamRaw)))
	}
	defer myBodyParamArgReader.Close()
	if err := codecs.JSON.Decode(myBodyParamArgReader, &myBodyParamArg); err != nil {
		return werror.WrapWithContextParams(ctx, err, "invalid value for myBodyParam argument")
	}

	myQueryParam1Raw, err := flags.GetString("myQueryParam1")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myQueryParam1")
	}
	if myQueryParam1Raw == "" {
		return werror.ErrorWithContextParams(ctx, "myQueryParam1 is a required argument")
	}
	myQueryParam1Arg := myQueryParam1Raw

	myQueryParam2Raw, err := flags.GetString("myQueryParam2")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myQueryParam2")
	}
	if myQueryParam2Raw == "" {
		return werror.ErrorWithContextParams(ctx, "myQueryParam2 is a required argument")
	}
	myQueryParam2Arg := myQueryParam2Raw

	myQueryParam3Raw, err := flags.GetString("myQueryParam3")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myQueryParam3")
	}
	if myQueryParam3Raw == "" {
		return werror.ErrorWithContextParams(ctx, "myQueryParam3 is a required argument")
	}
	myQueryParam3Arg, err := strconv.ParseFloat(myQueryParam3Raw, 64)
	if err != nil {
		return werror.WrapWithContextParams(ctx, errors.WrapWithInvalidArgument(err), "failed to parse \"myQueryParam3\" as double")
	}

	myQueryParam4Raw, err := flags.GetString("myQueryParam4")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myQueryParam4")
	}
	var myQueryParam4Arg *safelong.SafeLong
	if myQueryParam4ArgStr := myQueryParam4Raw; myQueryParam4ArgStr != "" {
		myQueryParam4ArgInternal, err := safelong.ParseSafeLong(myQueryParam4ArgStr)
		if err != nil {
			return werror.WrapWithContextParams(ctx, errors.WrapWithInvalidArgument(err), "failed to parse \"myQueryParam4\" as safelong")
		}
		myQueryParam4Arg = &myQueryParam4ArgInternal
	}

	myQueryParam5Raw, err := flags.GetString("myQueryParam5")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myQueryParam5")
	}
	var myQueryParam5Arg *string
	if myQueryParam5ArgStr := myQueryParam5Raw; myQueryParam5ArgStr != "" {
		myQueryParam5ArgInternal := myQueryParam5ArgStr
		myQueryParam5Arg = &myQueryParam5ArgInternal
	}

	myQueryParam6Raw, err := flags.GetString("myQueryParam6")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myQueryParam6")
	}
	var myQueryParam6ArgValue *int
	if myQueryParam6ArgValueStr1 := myQueryParam6Raw; myQueryParam6ArgValueStr1 != "" {
		myQueryParam6ArgValueInternal1, err := strconv.Atoi(myQueryParam6ArgValueStr1)
		if err != nil {
			return werror.WrapWithContextParams(ctx, errors.WrapWithInvalidArgument(err), "failed to parse \"myQueryParam6\" as integer")
		}
		myQueryParam6ArgValue = &myQueryParam6ArgValueInternal1
	}
	myQueryParam6Arg := OptionalIntegerAlias{Value: myQueryParam6ArgValue}

	myHeaderParam1Raw, err := flags.GetString("myHeaderParam1")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myHeaderParam1")
	}
	if myHeaderParam1Raw == "" {
		return werror.ErrorWithContextParams(ctx, "myHeaderParam1 is a required argument")
	}
	myHeaderParam1Arg, err := safelong.ParseSafeLong(myHeaderParam1Raw)
	if err != nil {
		return werror.WrapWithContextParams(ctx, errors.WrapWithInvalidArgument(err), "failed to parse \"myHeaderParam1\" as safelong")
	}

	myHeaderParam2Raw, err := flags.GetString("myHeaderParam2")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myHeaderParam2")
	}
	var myHeaderParam2Arg *uuid.UUID
	if myHeaderParam2ArgStr := myHeaderParam2Raw; myHeaderParam2ArgStr != "" {
		myHeaderParam2ArgInternal, err := uuid.ParseUUID(myHeaderParam2ArgStr)
		if err != nil {
			return werror.WrapWithContextParams(ctx, errors.WrapWithInvalidArgument(err), "failed to parse \"myHeaderParam2\" as uuid")
		}
		myHeaderParam2Arg = &myHeaderParam2ArgInternal
	}

	result, err := client.PostPathParam(ctx, __authVarArg, myPathParam1Arg, myPathParam2Arg, myBodyParamArg, myQueryParam1Arg, myQueryParam2Arg, myQueryParam3Arg, myQueryParam4Arg, myQueryParam5Arg, myQueryParam6Arg, myHeaderParam1Arg, myHeaderParam2Arg)
	if err != nil {
		return err
	}
	resultBytes, err := json.MarshalIndent(result, "", "    ")
	if err != nil {
		fmt.Printf("Failed to marshal to json with err: %v\n\nPrinting as string:\n%v\n", err, result)
		return nil
	}
	fmt.Fprintf(cmd.OutOrStdout(), "%v\n", string(resultBytes))
	return nil
}

func (c TestServiceCLICommand) testService_PostSafeParams_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	bearer_tokenRaw, err := flags.GetString("bearer_token")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument __authVar")
	}
	if bearer_tokenRaw == "" {
		return werror.ErrorWithContextParams(ctx, "bearer_token is a required argument")
	}
	__authVarArg := bearertoken.Token(bearer_tokenRaw)
	myPathParam1Raw, err := flags.GetString("myPathParam1")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myPathParam1")
	}
	if myPathParam1Raw == "" {
		return werror.ErrorWithContextParams(ctx, "myPathParam1 is a required argument")
	}
	myPathParam1Arg := myPathParam1Raw

	myPathParam2Raw, err := flags.GetString("myPathParam2")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myPathParam2")
	}
	if myPathParam2Raw == "" {
		return werror.ErrorWithContextParams(ctx, "myPathParam2 is a required argument")
	}
	myPathParam2Arg, err := strconv.ParseBool(myPathParam2Raw)
	if err != nil {
		return werror.WrapWithContextParams(ctx, errors.WrapWithInvalidArgument(err), "failed to parse \"myPathParam2\" as boolean")
	}

	myBodyParamRaw, err := flags.GetString("myBodyParam")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myBodyParam")
	}
	if myBodyParamRaw == "" {
		return werror.ErrorWithContextParams(ctx, "myBodyParam is a required argument")
	}
	var myBodyParamArg CustomObject
	var myBodyParamArgReader io.ReadCloser
	switch {
	case myBodyParamRaw == "@-":
		myBodyParamArgReader = io.NopCloser(cmd.InOrStdin())
	case strings.HasPrefix(myBodyParamRaw, "@"):
		myBodyParamArgReader, err = os.Open(strings.TrimSpace(myBodyParamRaw[1:]))
		if err != nil {
			return werror.WrapWithContextParams(ctx, err, "failed to open file for argument myBodyParam")
		}
	default:
		myBodyParamArgReader = io.NopCloser(bytes.NewReader([]byte(myBodyParamRaw)))
	}
	defer myBodyParamArgReader.Close()
	if err := codecs.JSON.Decode(myBodyParamArgReader, &myBodyParamArg); err != nil {
		return werror.WrapWithContextParams(ctx, err, "invalid value for myBodyParam argument")
	}

	myQueryParam1Raw, err := flags.GetString("myQueryParam1")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myQueryParam1")
	}
	if myQueryParam1Raw == "" {
		return werror.ErrorWithContextParams(ctx, "myQueryParam1 is a required argument")
	}
	myQueryParam1Arg := myQueryParam1Raw

	myQueryParam2Raw, err := flags.GetString("myQueryParam2")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myQueryParam2")
	}
	if myQueryParam2Raw == "" {
		return werror.ErrorWithContextParams(ctx, "myQueryParam2 is a required argument")
	}
	myQueryParam2Arg := myQueryParam2Raw

	myQueryParam3Raw, err := flags.GetString("myQueryParam3")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myQueryParam3")
	}
	if myQueryParam3Raw == "" {
		return werror.ErrorWithContextParams(ctx, "myQueryParam3 is a required argument")
	}
	myQueryParam3Arg, err := strconv.ParseFloat(myQueryParam3Raw, 64)
	if err != nil {
		return werror.WrapWithContextParams(ctx, errors.WrapWithInvalidArgument(err), "failed to parse \"myQueryParam3\" as double")
	}

	myQueryParam4Raw, err := flags.GetString("myQueryParam4")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myQueryParam4")
	}
	var myQueryParam4Arg *safelong.SafeLong
	if myQueryParam4ArgStr := myQueryParam4Raw; myQueryParam4ArgStr != "" {
		myQueryParam4ArgInternal, err := safelong.ParseSafeLong(myQueryParam4ArgStr)
		if err != nil {
			return werror.WrapWithContextParams(ctx, errors.WrapWithInvalidArgument(err), "failed to parse \"myQueryParam4\" as safelong")
		}
		myQueryParam4Arg = &myQueryParam4ArgInternal
	}

	myQueryParam5Raw, err := flags.GetString("myQueryParam5")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myQueryParam5")
	}
	var myQueryParam5Arg *string
	if myQueryParam5ArgStr := myQueryParam5Raw; myQueryParam5ArgStr != "" {
		myQueryParam5ArgInternal := myQueryParam5ArgStr
		myQueryParam5Arg = &myQueryParam5ArgInternal
	}

	myHeaderParam1Raw, err := flags.GetString("myHeaderParam1")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myHeaderParam1")
	}
	if myHeaderParam1Raw == "" {
		return werror.ErrorWithContextParams(ctx, "myHeaderParam1 is a required argument")
	}
	myHeaderParam1Arg, err := safelong.ParseSafeLong(myHeaderParam1Raw)
	if err != nil {
		return werror.WrapWithContextParams(ctx, errors.WrapWithInvalidArgument(err), "failed to parse \"myHeaderParam1\" as safelong")
	}

	myHeaderParam2Raw, err := flags.GetString("myHeaderParam2")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myHeaderParam2")
	}
	var myHeaderParam2Arg *uuid.UUID
	if myHeaderParam2ArgStr := myHeaderParam2Raw; myHeaderParam2ArgStr != "" {
		myHeaderParam2ArgInternal, err := uuid.ParseUUID(myHeaderParam2ArgStr)
		if err != nil {
			return werror.WrapWithContextParams(ctx, errors.WrapWithInvalidArgument(err), "failed to parse \"myHeaderParam2\" as uuid")
		}
		myHeaderParam2Arg = &myHeaderParam2ArgInternal
	}

	return client.PostSafeParams(ctx, __authVarArg, myPathParam1Arg, myPathParam2Arg, myBodyParamArg, myQueryParam1Arg, myQueryParam2Arg, myQueryParam3Arg, myQueryParam4Arg, myQueryParam5Arg, myHeaderParam1Arg, myHeaderParam2Arg)
}

func (c TestServiceCLICommand) testService_Bytes_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	result, err := client.Bytes(ctx)
	if err != nil {
		return err
	}
	resultBytes, err := json.MarshalIndent(result, "", "    ")
	if err != nil {
		fmt.Printf("Failed to marshal to json with err: %v\n\nPrinting as string:\n%v\n", err, result)
		return nil
	}
	fmt.Fprintf(cmd.OutOrStdout(), "%v\n", string(resultBytes))
	return nil
}

func (c TestServiceCLICommand) testService_GetBinary_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	result, err := client.GetBinary(ctx)
	if err != nil {
		return err
	}
	_, err = io.Copy(cmd.OutOrStdout(), result)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to write result bytes to stdout")
	}
	return result.Close()
}

func (c TestServiceCLICommand) testService_PostBinary_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	myBytesRaw, err := flags.GetString("myBytes")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myBytes")
	}
	if myBytesRaw == "" {
		return werror.ErrorWithContextParams(ctx, "myBytes is a required argument")
	}
	var myBytesArg func() io.ReadCloser
	var myBytesArgReader io.ReadCloser
	switch {
	case myBytesRaw == "@-":
		myBytesArgReader = io.NopCloser(cmd.InOrStdin())
	case strings.HasPrefix(myBytesRaw, "@"):
		myBytesArgReader, err = os.Open(strings.TrimSpace(myBytesRaw[1:]))
		if err != nil {
			return werror.WrapWithContextParams(ctx, err, "failed to open file for argument myBytes")
		}
	default:
		myBytesArgReader = io.NopCloser(base64.NewDecoder(base64.StdEncoding, bytes.NewReader([]byte(myBytesRaw))))
	}
	myBytesArg = func() io.ReadCloser {
		return myBytesArgReader
	}

	result, err := client.PostBinary(ctx, myBytesArg)
	if err != nil {
		return err
	}
	_, err = io.Copy(cmd.OutOrStdout(), result)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to write result bytes to stdout")
	}
	return result.Close()
}

func (c TestServiceCLICommand) testService_PutBinary_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	myBytesRaw, err := flags.GetString("myBytes")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument myBytes")
	}
	if myBytesRaw == "" {
		return werror.ErrorWithContextParams(ctx, "myBytes is a required argument")
	}
	var myBytesArg func() io.ReadCloser
	var myBytesArgReader io.ReadCloser
	switch {
	case myBytesRaw == "@-":
		myBytesArgReader = io.NopCloser(cmd.InOrStdin())
	case strings.HasPrefix(myBytesRaw, "@"):
		myBytesArgReader, err = os.Open(strings.TrimSpace(myBytesRaw[1:]))
		if err != nil {
			return werror.WrapWithContextParams(ctx, err, "failed to open file for argument myBytes")
		}
	default:
		myBytesArgReader = io.NopCloser(base64.NewDecoder(base64.StdEncoding, bytes.NewReader([]byte(myBytesRaw))))
	}
	myBytesArg = func() io.ReadCloser {
		return myBytesArgReader
	}

	return client.PutBinary(ctx, myBytesArg)
}

func (c TestServiceCLICommand) testService_GetOptionalBinary_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	result, err := client.GetOptionalBinary(ctx)
	if err != nil {
		return err
	}
	if result == nil {
		return nil
	}
	resultDeref := *result
	_, err = io.Copy(cmd.OutOrStdout(), resultDeref)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to write result bytes to stdout")
	}
	return resultDeref.Close()
}

func (c TestServiceCLICommand) testService_Chan_CmdRun(cmd *cobra.Command, _ []string) error {
	flags := cmd.Flags()
	ctx := getCLIContext(flags)
	client, err := c.clientProvider.Get(ctx, flags)
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to initialize client")
	}
	varRaw, err := flags.GetString("var")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument var")
	}
	if varRaw == "" {
		return werror.ErrorWithContextParams(ctx, "var is a required argument")
	}
	varArg := varRaw

	importRaw, err := flags.GetString("import")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument import")
	}
	if importRaw == "" {
		return werror.ErrorWithContextParams(ctx, "import is a required argument")
	}
	var importArg map[string]string
	var importArgReader io.ReadCloser
	switch {
	case importRaw == "@-":
		importArgReader = io.NopCloser(cmd.InOrStdin())
	case strings.HasPrefix(importRaw, "@"):
		importArgReader, err = os.Open(strings.TrimSpace(importRaw[1:]))
		if err != nil {
			return werror.WrapWithContextParams(ctx, err, "failed to open file for argument import")
		}
	default:
		importArgReader = io.NopCloser(bytes.NewReader([]byte(importRaw)))
	}
	defer importArgReader.Close()
	if err := codecs.JSON.Decode(importArgReader, &importArg); err != nil {
		return werror.WrapWithContextParams(ctx, err, "invalid value for import argument")
	}

	typeRaw, err := flags.GetString("type")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument type")
	}
	if typeRaw == "" {
		return werror.ErrorWithContextParams(ctx, "type is a required argument")
	}
	typeArg := typeRaw

	returnRaw, err := flags.GetString("return")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument return")
	}
	if returnRaw == "" {
		return werror.ErrorWithContextParams(ctx, "return is a required argument")
	}
	returnArg, err := safelong.ParseSafeLong(returnRaw)
	if err != nil {
		return werror.WrapWithContextParams(ctx, errors.WrapWithInvalidArgument(err), "failed to parse \"return\" as safelong")
	}

	httpRaw, err := flags.GetString("http")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument http")
	}
	if httpRaw == "" {
		return werror.ErrorWithContextParams(ctx, "http is a required argument")
	}
	httpArg := httpRaw

	jsonRaw, err := flags.GetString("json")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument json")
	}
	if jsonRaw == "" {
		return werror.ErrorWithContextParams(ctx, "json is a required argument")
	}
	jsonArg := jsonRaw

	reqRaw, err := flags.GetString("req")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument req")
	}
	if reqRaw == "" {
		return werror.ErrorWithContextParams(ctx, "req is a required argument")
	}
	reqArg := reqRaw

	rwRaw, err := flags.GetString("rw")
	if err != nil {
		return werror.WrapWithContextParams(ctx, err, "failed to parse argument rw")
	}
	if rwRaw == "" {
		return werror.ErrorWithContextParams(ctx, "rw is a required argument")
	}
	rwArg := rwRaw

	return client.Chan(ctx, varArg, importArg, typeArg, returnArg, httpArg, jsonArg, reqArg, rwArg)
}

func loadCLIConfig(ctx context.Context, flags *pflag.FlagSet) (CLIConfig, error) {
	var emptyConfig CLIConfig
	configPath, err := flags.GetString("conf")
	if err != nil || configPath == "" {
		return emptyConfig, werror.WrapWithContextParams(ctx, err, "config file location must be specified")
	}
	confBytes, err := os.ReadFile(configPath)
	if err != nil {
		return emptyConfig, err
	}
	var conf CLIConfig
	err = yaml.Unmarshal(confBytes, &conf)
	if err != nil {
		return emptyConfig, err
	}
	return conf, nil
}

func getCLIContext(flags *pflag.FlagSet) context.Context {
	ctx := context.Background()
	logProvider := wlog.NewNoopLoggerProvider()
	logWriter := io.Discard
	verbose, err := flags.GetBool("verbose")
	if verbose && err == nil {
		logProvider = wlogzap.LoggerProvider()
		logWriter = os.Stdout
	}
	wlog.SetDefaultLoggerProvider(logProvider)
	ctx = svc1log.WithLogger(ctx, svc1log.New(logWriter, wlog.DebugLevel))
	traceLogger := trc1log.New(logWriter)
	ctx = trc1log.WithLogger(ctx, traceLogger)
	ctx = evt2log.WithLogger(ctx, evt2log.New(logWriter))
	tracer, err := wzipkin.NewTracer(traceLogger)
	if err != nil {
		return ctx
	}
	return wtracing.ContextWithTracer(ctx, tracer)
}
