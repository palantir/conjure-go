// This file was generated by Conjure and should not be manually edited.

package api

import (
	"net/http"
	"strconv"

	"github.com/palantir/conjure-go-runtime/conjure-go-contract/codecs"
	"github.com/palantir/conjure-go-runtime/conjure-go-server/rest"
	"github.com/palantir/pkg/safelong"
	"github.com/palantir/pkg/uuid"
	"github.com/palantir/witchcraft-go-error"
	"github.com/palantir/witchcraft-go-server/witchcraft/wresource"
	"github.com/palantir/witchcraft-go-server/wrouter"
)

// RegisterRoutesTestService registers handlers for the TestService endpoints with a witchcraft wrouter.
// This should typically be called in a witchcraft server's InitFunc.
// impl provides an implementation of each endpoint, which can assume the request parameters have been parsed
// in accordance with the Conjure specification.
func RegisterRoutesTestService(router wrouter.Router, impl TestService) error {
	handler := testServiceHandler{impl: impl}
	resource := wresource.New("testservice", router)
	if err := resource.Get("Echo", "/echo", rest.HandlerFunc(handler.HandleEcho)); err != nil {
		return werror.Wrap(err, "failed to add route", werror.SafeParam("routeName", "Echo"))
	}
	if err := resource.Get("GetPathParam", "/path/{myPathParam}", rest.HandlerFunc(handler.HandleGetPathParam)); err != nil {
		return werror.Wrap(err, "failed to add route", werror.SafeParam("routeName", "GetPathParam"))
	}
	if err := resource.Post("PostPathParam", "/path/{myPathParam1}/{myPathParam2}", rest.HandlerFunc(handler.HandlePostPathParam)); err != nil {
		return werror.Wrap(err, "failed to add route", werror.SafeParam("routeName", "PostPathParam"))
	}
	if err := resource.Get("Bytes", "/bytes", rest.HandlerFunc(handler.HandleBytes)); err != nil {
		return werror.Wrap(err, "failed to add route", werror.SafeParam("routeName", "Bytes"))
	}
	if err := resource.Get("GetBinary", "/binary", rest.HandlerFunc(handler.HandleGetBinary)); err != nil {
		return werror.Wrap(err, "failed to add route", werror.SafeParam("routeName", "GetBinary"))
	}
	if err := resource.Post("PostBinary", "/binary", rest.HandlerFunc(handler.HandlePostBinary)); err != nil {
		return werror.Wrap(err, "failed to add route", werror.SafeParam("routeName", "PostBinary"))
	}
	if err := resource.Put("PutBinary", "/binary", rest.HandlerFunc(handler.HandlePutBinary)); err != nil {
		return werror.Wrap(err, "failed to add route", werror.SafeParam("routeName", "PutBinary"))
	}
	return nil
}

type testServiceHandler struct {
	impl TestService
}

func (t *testServiceHandler) HandleEcho(rw http.ResponseWriter, req *http.Request) error {
	cookieToken, err := rest.ParseBearerTokenCookie(req, "PALANTIR_TOKEN")
	if err != nil {
		return err
	}
	return t.impl.Echo(req.Context(), cookieToken)
}

func (t *testServiceHandler) HandleGetPathParam(rw http.ResponseWriter, req *http.Request) error {
	authHeader, err := rest.ParseBearerTokenHeader(req)
	if err != nil {
		return err
	}
	pathParams := wrouter.PathParams(req)
	if pathParams == nil {
		return werror.Error("path params not found on request: ensure this endpoint is registered with wrouter")
	}
	myPathParam, ok := pathParams["myPathParam"]
	if !ok {
		return werror.Error("path param not present", werror.SafeParam("pathParamName", "myPathParam"))
	}
	return t.impl.GetPathParam(req.Context(), authHeader, myPathParam)
}

func (t *testServiceHandler) HandlePostPathParam(rw http.ResponseWriter, req *http.Request) error {
	authHeader, err := rest.ParseBearerTokenHeader(req)
	if err != nil {
		return err
	}
	pathParams := wrouter.PathParams(req)
	if pathParams == nil {
		return werror.Error("path params not found on request: ensure this endpoint is registered with wrouter")
	}
	myPathParam1, ok := pathParams["myPathParam1"]
	if !ok {
		return werror.Error("path param not present", werror.SafeParam("pathParamName", "myPathParam1"))
	}
	myPathParam2Str, ok := pathParams["myPathParam2"]
	if !ok {
		return werror.Error("path param not present", werror.SafeParam("pathParamName", "myPathParam2"))
	}
	myPathParam2, err := strconv.ParseBool(myPathParam2Str)
	if err != nil {
		return err
	}
	var myBodyParam CustomObject
	if err := codecs.JSON.Decode(req.Body, &myBodyParam); err != nil {
		return werror.Wrap(err, "failed to unmarshal request body", werror.SafeParam("bodyParamName", "myBodyParam"), werror.SafeParam("bodyParamType", "CustomObject"))
	}
	myQueryParam1 := req.URL.Query().Get("query1")
	myQueryParam2 := req.URL.Query().Get("myQueryParam2")
	myQueryParam3, err := strconv.ParseFloat(req.URL.Query().Get("myQueryParam3"), 64)
	if err != nil {
		return err
	}
	var myQueryParam4 *safelong.SafeLong
	if myQueryParam4Str := req.URL.Query().Get("myQueryParam4"); myQueryParam4Str != "" {
		myQueryParam4Internal, err := safelong.ParseSafeLong(myQueryParam4Str)
		if err != nil {
			return err
		}
		myQueryParam4 = &myQueryParam4Internal
	}
	var myQueryParam5 *string
	if myQueryParam5Str := req.URL.Query().Get("myQueryParam5"); myQueryParam5Str != "" {
		myQueryParam5Internal := myQueryParam5Str
		myQueryParam5 = &myQueryParam5Internal
	}
	myHeaderParam1, err := safelong.ParseSafeLong(req.Header.Get("X-My-Header1-Abc"))
	if err != nil {
		return err
	}
	var myHeaderParam2 *uuid.UUID
	if myHeaderParam2Str := req.Header.Get("X-My-Header2"); myHeaderParam2Str != "" {
		myHeaderParam2Internal, err := uuid.ParseUUID(myHeaderParam2Str)
		if err != nil {
			return err
		}
		myHeaderParam2 = &myHeaderParam2Internal
	}
	respArg, err := t.impl.PostPathParam(req.Context(), authHeader, myPathParam1, myPathParam2, myBodyParam, myQueryParam1, myQueryParam2, myQueryParam3, myQueryParam4, myQueryParam5, myHeaderParam1, myHeaderParam2)
	if err != nil {
		return err
	}
	rw.Header().Add("Content-Type", codecs.JSON.ContentType())
	return codecs.JSON.Encode(rw, respArg)
}

func (t *testServiceHandler) HandleBytes(rw http.ResponseWriter, req *http.Request) error {
	respArg, err := t.impl.Bytes(req.Context())
	if err != nil {
		return err
	}
	rw.Header().Add("Content-Type", codecs.JSON.ContentType())
	return codecs.JSON.Encode(rw, respArg)
}

func (t *testServiceHandler) HandleGetBinary(rw http.ResponseWriter, req *http.Request) error {
	respArg, err := t.impl.GetBinary(req.Context())
	if err != nil {
		return err
	}
	rw.Header().Add("Content-Type", codecs.Binary.ContentType())
	return codecs.Binary.Encode(rw, respArg)
}

func (t *testServiceHandler) HandlePostBinary(rw http.ResponseWriter, req *http.Request) error {
	myBytes := req.Body
	respArg, err := t.impl.PostBinary(req.Context(), myBytes)
	if err != nil {
		return err
	}
	rw.Header().Add("Content-Type", codecs.Binary.ContentType())
	return codecs.Binary.Encode(rw, respArg)
}

func (t *testServiceHandler) HandlePutBinary(rw http.ResponseWriter, req *http.Request) error {
	myBytes := req.Body
	return t.impl.PutBinary(req.Context(), myBytes)
}
