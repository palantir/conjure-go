// This file was generated by Conjure and should not be manually edited.

package api

import (
	"context"
	"io"
	"net/http"

	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/codecs"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-server/httpserver"
	werror "github.com/palantir/witchcraft-go-error"
	"github.com/palantir/witchcraft-go-server/v2/witchcraft/wresource"
	"github.com/palantir/witchcraft-go-server/v2/wrouter"
)

type TestService interface {
	BinaryAlias(ctx context.Context, bodyArg io.ReadCloser) (io.ReadCloser, error)
	BinaryAliasOptional(ctx context.Context) (*io.ReadCloser, error)
	BinaryAliasAlias(ctx context.Context, bodyArg *io.ReadCloser) (*io.ReadCloser, error)
	Binary(ctx context.Context, bodyArg io.ReadCloser) (io.ReadCloser, error)
	BinaryOptional(ctx context.Context) (*io.ReadCloser, error)
	BinaryOptionalAlias(ctx context.Context, bodyArg *io.ReadCloser) (*io.ReadCloser, error)
	BinaryList(ctx context.Context, bodyArg [][]byte) ([][]byte, error)
	Bytes(ctx context.Context, bodyArg CustomObject) (CustomObject, error)
}

// RegisterRoutesTestService registers handlers for the TestService endpoints with a witchcraft wrouter.
// This should typically be called in a witchcraft server's InitFunc.
// impl provides an implementation of each endpoint, which can assume the request parameters have been parsed
// in accordance with the Conjure specification.
func RegisterRoutesTestService(router wrouter.Router, impl TestService, routerParams ...wrouter.RouteParam) error {
	handler := testServiceHandler{impl: impl}
	resource := wresource.New("testservice", router)
	if err := resource.Post("BinaryAlias", "/binaryAlias", httpserver.NewJSONHandler(handler.HandleBinaryAlias, httpserver.StatusCodeMapper, httpserver.ErrHandler), routerParams...); err != nil {
		return werror.Wrap(err, "failed to add binaryAlias route")
	}
	if err := resource.Post("BinaryAliasOptional", "/binaryAliasOptional", httpserver.NewJSONHandler(handler.HandleBinaryAliasOptional, httpserver.StatusCodeMapper, httpserver.ErrHandler), routerParams...); err != nil {
		return werror.Wrap(err, "failed to add binaryAliasOptional route")
	}
	if err := resource.Post("BinaryAliasAlias", "/binaryAliasAlias", httpserver.NewJSONHandler(handler.HandleBinaryAliasAlias, httpserver.StatusCodeMapper, httpserver.ErrHandler), routerParams...); err != nil {
		return werror.Wrap(err, "failed to add binaryAliasAlias route")
	}
	if err := resource.Post("Binary", "/binary", httpserver.NewJSONHandler(handler.HandleBinary, httpserver.StatusCodeMapper, httpserver.ErrHandler), routerParams...); err != nil {
		return werror.Wrap(err, "failed to add binary route")
	}
	if err := resource.Post("BinaryOptional", "/binaryOptional", httpserver.NewJSONHandler(handler.HandleBinaryOptional, httpserver.StatusCodeMapper, httpserver.ErrHandler), routerParams...); err != nil {
		return werror.Wrap(err, "failed to add binaryOptional route")
	}
	if err := resource.Post("BinaryOptionalAlias", "/binaryOptionalAlias", httpserver.NewJSONHandler(handler.HandleBinaryOptionalAlias, httpserver.StatusCodeMapper, httpserver.ErrHandler), routerParams...); err != nil {
		return werror.Wrap(err, "failed to add binaryOptionalAlias route")
	}
	if err := resource.Post("BinaryList", "/binaryList", httpserver.NewJSONHandler(handler.HandleBinaryList, httpserver.StatusCodeMapper, httpserver.ErrHandler), routerParams...); err != nil {
		return werror.Wrap(err, "failed to add binaryList route")
	}
	if err := resource.Post("Bytes", "/bytes", httpserver.NewJSONHandler(handler.HandleBytes, httpserver.StatusCodeMapper, httpserver.ErrHandler), routerParams...); err != nil {
		return werror.Wrap(err, "failed to add bytes route")
	}
	return nil
}

type testServiceHandler struct {
	impl TestService
}

func (t *testServiceHandler) HandleBinaryAlias(rw http.ResponseWriter, req *http.Request) error {
	bodyArg := req.Body
	respArg, err := t.impl.BinaryAlias(req.Context(), bodyArg)
	if err != nil {
		return err
	}
	rw.Header().Add("Content-Type", codecs.Binary.ContentType())
	return codecs.Binary.Encode(rw, respArg)
}

func (t *testServiceHandler) HandleBinaryAliasOptional(rw http.ResponseWriter, req *http.Request) error {
	respArg, err := t.impl.BinaryAliasOptional(req.Context())
	if err != nil {
		return err
	}
	if respArg == nil {
		rw.WriteHeader(http.StatusNoContent)
		return nil
	}
	rw.Header().Add("Content-Type", codecs.Binary.ContentType())
	return codecs.Binary.Encode(rw, *respArg)
}

func (t *testServiceHandler) HandleBinaryAliasAlias(rw http.ResponseWriter, req *http.Request) error {
	var bodyArg *io.ReadCloser
	if req.Body != nil && req.Body != http.NoBody {
		bodyArg = &req.Body
	}
	respArg, err := t.impl.BinaryAliasAlias(req.Context(), bodyArg)
	if err != nil {
		return err
	}
	if respArg == nil {
		rw.WriteHeader(http.StatusNoContent)
		return nil
	}
	rw.Header().Add("Content-Type", codecs.Binary.ContentType())
	return codecs.Binary.Encode(rw, *respArg)
}

func (t *testServiceHandler) HandleBinary(rw http.ResponseWriter, req *http.Request) error {
	bodyArg := req.Body
	respArg, err := t.impl.Binary(req.Context(), bodyArg)
	if err != nil {
		return err
	}
	rw.Header().Add("Content-Type", codecs.Binary.ContentType())
	return codecs.Binary.Encode(rw, respArg)
}

func (t *testServiceHandler) HandleBinaryOptional(rw http.ResponseWriter, req *http.Request) error {
	respArg, err := t.impl.BinaryOptional(req.Context())
	if err != nil {
		return err
	}
	if respArg == nil {
		rw.WriteHeader(http.StatusNoContent)
		return nil
	}
	rw.Header().Add("Content-Type", codecs.Binary.ContentType())
	return codecs.Binary.Encode(rw, *respArg)
}

func (t *testServiceHandler) HandleBinaryOptionalAlias(rw http.ResponseWriter, req *http.Request) error {
	var bodyArg *io.ReadCloser
	if req.Body != nil && req.Body != http.NoBody {
		bodyArg = &req.Body
	}
	respArg, err := t.impl.BinaryOptionalAlias(req.Context(), bodyArg)
	if err != nil {
		return err
	}
	if respArg == nil {
		rw.WriteHeader(http.StatusNoContent)
		return nil
	}
	rw.Header().Add("Content-Type", codecs.Binary.ContentType())
	return codecs.Binary.Encode(rw, *respArg)
}

func (t *testServiceHandler) HandleBinaryList(rw http.ResponseWriter, req *http.Request) error {
	var bodyArg [][]byte
	if err := codecs.JSON.Decode(req.Body, (*requestBodyTestServiceBinaryList)(&bodyArg)); err != nil {
		return errors.WrapWithInvalidArgument(err)
	}
	respArg, err := t.impl.BinaryList(req.Context(), bodyArg)
	if err != nil {
		return err
	}
	rw.Header().Add("Content-Type", codecs.JSON.ContentType())
	return codecs.JSON.Encode(rw, responseBodyTestServiceBinaryList(respArg))
}

func (t *testServiceHandler) HandleBytes(rw http.ResponseWriter, req *http.Request) error {
	var bodyArg CustomObject
	if err := codecs.JSON.Decode(req.Body, &bodyArg); err != nil {
		return errors.WrapWithInvalidArgument(err)
	}
	respArg, err := t.impl.Bytes(req.Context(), bodyArg)
	if err != nil {
		return err
	}
	rw.Header().Add("Content-Type", codecs.JSON.ContentType())
	return codecs.JSON.Encode(rw, respArg)
}
