// This file was generated by Conjure and should not be manually edited.

package api

import (
	"encoding/base64"
	"strconv"

	binary "github.com/palantir/pkg/binary"
	boolean "github.com/palantir/pkg/boolean"
	safejson "github.com/palantir/pkg/safejson"
	uuid "github.com/palantir/pkg/uuid"
)

type AnyValue struct {
	Value interface{} `json:"value"`
}

func (o AnyValue) MarshalJSON() ([]byte, error) {
	return o.AppendJSON(nil)
}

func (o AnyValue) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	{
		out = append(out, "\"value\":"...)
		if o.Value == nil {
			out = append(out, "null"...)
		} else if jsonBytes, err := safejson.Marshal(o.Value); err != nil {
			return nil, err
		} else {
			out = append(out, jsonBytes...)
		}
	}
	out = append(out, '}')
	return out, nil
}

type Basic struct {
	Data string `json:"data"`
}

func (o Basic) MarshalJSON() ([]byte, error) {
	return o.AppendJSON(nil)
}

func (o Basic) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	{
		out = append(out, "\"data\":"...)
		out = safejson.AppendQuotedString(out, o.Data)
	}
	out = append(out, '}')
	return out, nil
}

type BinaryMap struct {
	Map map[binary.Binary][]byte `json:"map"`
}

func (o BinaryMap) MarshalJSON() ([]byte, error) {
	return o.AppendJSON(nil)
}

func (o BinaryMap) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	{
		out = append(out, "\"map\":"...)
		out = append(out, '{')
		{
			var i int
			for k, v := range o.Map {
				out = safejson.AppendQuotedString(out, string(k))
				out = append(out, ':')
				out = append(out, '"')
				if len(v) > 0 {
					b64out := make([]byte, 0, base64.StdEncoding.EncodedLen(len(v)))
					base64.StdEncoding.Encode(b64out, v)
					out = append(out, b64out...)
				}
				out = append(out, '"')
				i++
				if i < len(o.Map) {
					out = append(out, ',')
				}
			}
		}
		out = append(out, '}')
	}
	out = append(out, '}')
	return out, nil
}

type BooleanIntegerMap struct {
	Map map[boolean.Boolean]int `json:"map"`
}

func (o BooleanIntegerMap) MarshalJSON() ([]byte, error) {
	return o.AppendJSON(nil)
}

func (o BooleanIntegerMap) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	{
		out = append(out, "\"map\":"...)
		out = append(out, '{')
		{
			var i int
			for k, v := range o.Map {
				if k {
					out = append(out, "\"true\""...)
				} else {
					out = append(out, "\"false\""...)
				}
				out = append(out, "\"true\""...)
				out = append(out, "\"false\""...)
				out = append(out, ':')
				out = strconv.AppendInt(out, int64(v), 10)
				i++
				if i < len(o.Map) {
					out = append(out, ',')
				}
			}
		}
		out = append(out, '}')
	}
	out = append(out, '}')
	return out, nil
}

type Collections struct {
	MapVar   map[string][]int   `json:"mapVar"`
	ListVar  []string           `json:"listVar"`
	MultiDim [][]map[string]int `json:"multiDim"`
}

func (o Collections) MarshalJSON() ([]byte, error) {
	return o.AppendJSON(nil)
}

func (o Collections) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	{
		out = append(out, "\"mapVar\":"...)
		out = append(out, '{')
		{
			var i int
			for k, v := range o.MapVar {
				out = safejson.AppendQuotedString(out, k)
				out = append(out, ':')
				out = append(out, '[')
				{
					for i := range v {
						out = strconv.AppendInt(out, int64(v[i]), 10)
						if i < len(v)-1 {
							out = append(out, ',')
						}
					}
				}
				out = append(out, ']')
				i++
				if i < len(o.MapVar) {
					out = append(out, ',')
				}
			}
		}
		out = append(out, '}')
		out = append(out, ',')
	}
	{
		out = append(out, "\"listVar\":"...)
		out = append(out, '[')
		{
			for i := range o.ListVar {
				out = safejson.AppendQuotedString(out, o.ListVar[i])
				if i < len(o.ListVar)-1 {
					out = append(out, ',')
				}
			}
		}
		out = append(out, ']')
		out = append(out, ',')
	}
	{
		out = append(out, "\"multiDim\":"...)
		out = append(out, '[')
		{
			for i := range o.MultiDim {
				out = append(out, '[')
				{
					for i := range o.MultiDim[i] {
						out = append(out, '{')
						{
							var i int
							for k, v := range o.MultiDim[i][i] {
								out = safejson.AppendQuotedString(out, k)
								out = append(out, ':')
								out = strconv.AppendInt(out, int64(v), 10)
								i++
								if i < len(o.MultiDim[i][i]) {
									out = append(out, ',')
								}
							}
						}
						out = append(out, '}')
						if i < len(o.MultiDim[i])-1 {
							out = append(out, ',')
						}
					}
				}
				out = append(out, ']')
				if i < len(o.MultiDim)-1 {
					out = append(out, ',')
				}
			}
		}
		out = append(out, ']')
	}
	out = append(out, '}')
	return out, nil
}

type Compound struct {
	Obj Collections `json:"obj"`
}

func (o Compound) MarshalJSON() ([]byte, error) {
	return o.AppendJSON(nil)
}

func (o Compound) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	{
		out = append(out, "\"obj\":"...)
		var err error
		out, err = o.Obj.AppendJSON(out)
		if err != nil {
			return nil, err
		}
	}
	out = append(out, '}')
	return out, nil
}

type ExampleUuid struct {
	Uid uuid.UUID `json:"uid"`
}

func (o ExampleUuid) MarshalJSON() ([]byte, error) {
	return o.AppendJSON(nil)
}

func (o ExampleUuid) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	{
		out = append(out, "\"uid\":"...)
		out = safejson.AppendQuotedString(out, o.Uid.String())
	}
	out = append(out, '}')
	return out, nil
}

type MapOptional struct {
	Map map[OptionalUuidAlias]string `json:"map"`
}

func (o MapOptional) MarshalJSON() ([]byte, error) {
	return o.AppendJSON(nil)
}

func (o MapOptional) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	{
		out = append(out, "\"map\":"...)
		out = append(out, '{')
		{
			var i int
			for k, v := range o.Map {
				var err error
				out, err = k.AppendJSON(out)
				if err != nil {
					return nil, err
				}
				out = append(out, ':')
				out = safejson.AppendQuotedString(out, v)
				i++
				if i < len(o.Map) {
					out = append(out, ',')
				}
			}
		}
		out = append(out, '}')
	}
	out = append(out, '}')
	return out, nil
}

// A type using go keywords
type Type struct {
	Type []string          `json:"type"`
	Chan map[string]string `json:"chan"`
}

func (o Type) MarshalJSON() ([]byte, error) {
	return o.AppendJSON(nil)
}

func (o Type) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	{
		out = append(out, "\"type\":"...)
		out = append(out, '[')
		{
			for i := range o.Type {
				out = safejson.AppendQuotedString(out, o.Type[i])
				if i < len(o.Type)-1 {
					out = append(out, ',')
				}
			}
		}
		out = append(out, ']')
		out = append(out, ',')
	}
	{
		out = append(out, "\"chan\":"...)
		out = append(out, '{')
		{
			var i int
			for k, v := range o.Chan {
				out = safejson.AppendQuotedString(out, k)
				out = append(out, ':')
				out = safejson.AppendQuotedString(out, v)
				i++
				if i < len(o.Chan) {
					out = append(out, ',')
				}
			}
		}
		out = append(out, '}')
	}
	out = append(out, '}')
	return out, nil
}
