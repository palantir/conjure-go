// This file was generated by Conjure and should not be manually edited.

package api

import (
	"context"
	"encoding/json"
	"fmt"
	"strconv"

	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	werror "github.com/palantir/witchcraft-go-error"
	"github.com/tidwall/gjson"
)

type ExampleUnion struct {
	typ         string
	str         *string
	strOptional **string
	other       *int
}

func (u ExampleUnion) MarshalJSON() ([]byte, error) {
	return u.MarshalJSONBuffer(nil)
}

func (u ExampleUnion) MarshalJSONBuffer(buf []byte) ([]byte, error) {
	buf = append(buf, '{')
	buf = safejson.AppendQuotedString(buf, "type")
	buf = append(buf, ':')
	buf = safejson.AppendQuotedString(buf, u.typ)
	buf = append(buf, ',')
	buf = safejson.AppendQuotedString(buf, "str")
	buf = append(buf, ':')
	if u.str != nil {
		buf = safejson.AppendQuotedString(buf, *u.str)
	} else {
		buf = append(buf, "null"...)
	}
	buf = append(buf, ',')
	buf = safejson.AppendQuotedString(buf, "strOptional")
	buf = append(buf, ':')
	if u.strOptional != nil {
		if *u.strOptional != nil {
			buf = safejson.AppendQuotedString(buf, **u.strOptional)
		} else {
			buf = append(buf, "null"...)
		}
	} else {
		buf = append(buf, "null"...)
	}
	buf = append(buf, ',')
	buf = safejson.AppendQuotedString(buf, "other")
	buf = append(buf, ':')
	if u.other != nil {
		buf = strconv.AppendInt(buf, int64(*u.other), 10)
	} else {
		buf = append(buf, "null"...)
	}
	buf = append(buf, '}')
	return buf, nil
}

func (u *ExampleUnion) UnmarshalJSON(data []byte) error {
	ctx := context.TODO()
	if !gjson.ValidBytes(data) {
		return werror.ErrorWithContextParams(ctx, "invalid json")
	}
	return u.unmarshalGJSON(ctx, gjson.ParseBytes(data), false)
}

func (u *ExampleUnion) UnmarshalJSONString(data string) error {
	ctx := context.TODO()
	if !gjson.Valid(data) {
		return werror.ErrorWithContextParams(ctx, "invalid json")
	}
	return u.unmarshalGJSON(ctx, gjson.Parse(data), false)
}

func (u *ExampleUnion) UnmarshalJSONStrict(data []byte) error {
	ctx := context.TODO()
	if !gjson.ValidBytes(data) {
		return werror.ErrorWithContextParams(ctx, "invalid json")
	}
	return u.unmarshalGJSON(ctx, gjson.ParseBytes(data), true)
}

func (u *ExampleUnion) UnmarshalJSONStringStrict(data string) error {
	ctx := context.TODO()
	if !gjson.Valid(data) {
		return werror.ErrorWithContextParams(ctx, "invalid json")
	}
	return u.unmarshalGJSON(ctx, gjson.Parse(data), true)
}

func (u *ExampleUnion) unmarshalGJSON(ctx context.Context, value gjson.Result, strict bool) error {
	if !value.IsObject() {
		return werror.ErrorWithContextParams(ctx, "type ExampleUnion expected json type Object")
	}
	var seentyp bool
	var unrecognizedFields []string
	var err error
	value.ForEach(func(key, value gjson.Result) bool {
		switch key.Str {
		case "type":
			seentyp = true
			if value.Type != gjson.String {
				err = werror.ErrorWithContextParams(ctx, "field ExampleUnion[\"type\"] expected json type String")
				return false
			}
			u.typ = value.Str
		case "str":
			if value.Type != gjson.Null {
				if value.Type != gjson.String {
					err = werror.ErrorWithContextParams(ctx, "field ExampleUnion[\"str\"] expected json type String")
					return false
				}
				var optionalValue string
				optionalValue = value.Str
				u.str = &optionalValue
			}
		case "strOptional":
			if value.Type != gjson.Null {
				var optionalValue *string
				if value.Type != gjson.Null {
					if value.Type != gjson.String {
						err = werror.ErrorWithContextParams(ctx, "field ExampleUnion[\"strOptional\"] expected json type String")
						return false
					}
					var optionalValue1 string
					optionalValue1 = value.Str
					optionalValue = &optionalValue1
				}
				u.strOptional = &optionalValue
			}
		case "other":
			if value.Type != gjson.Null {
				if value.Type != gjson.Number {
					err = werror.ErrorWithContextParams(ctx, "field ExampleUnion[\"other\"] expected json type Number")
					return false
				}
				var optionalValue int
				optionalValue = int(value.Int())
				u.other = &optionalValue
			}
		default:
			if strict {
				unrecognizedFields = append(unrecognizedFields, key.Str)
			}
		}
		return err == nil
	})
	if err != nil {
		return err
	}
	var missingFields []string
	if !seentyp {
		missingFields = append(missingFields, "type")
	}
	if len(missingFields) > 0 {
		return werror.ErrorWithContextParams(ctx, "type ExampleUnion missing required json fields", werror.SafeParam("missingFields", missingFields))
	}
	if strict && len(unrecognizedFields) > 0 {
		return werror.ErrorWithContextParams(ctx, "type ExampleUnion encountered unrecognized json fields", werror.UnsafeParam("unrecognizedFields", unrecognizedFields))
	}
	return nil
}

func (u ExampleUnion) MarshalYAML() (interface{}, error) {
	jsonBytes, err := json.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ExampleUnion) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return u.UnmarshalJSON(jsonBytes)
}

func (u *ExampleUnion) AcceptFuncs(strFunc func(string) error, strOptionalFunc func(*string) error, otherFunc func(int) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "str":
		return strFunc(*u.str)
	case "strOptional":
		var strOptional *string
		if u.strOptional != nil {
			strOptional = *u.strOptional
		}
		return strOptionalFunc(strOptional)
	case "other":
		return otherFunc(*u.other)
	}
}

func (u *ExampleUnion) StrNoopSuccess(string) error {
	return nil
}

func (u *ExampleUnion) StrOptionalNoopSuccess(*string) error {
	return nil
}

func (u *ExampleUnion) OtherNoopSuccess(int) error {
	return nil
}

func (u *ExampleUnion) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ExampleUnion) Accept(v ExampleUnionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "str":
		return v.VisitStr(*u.str)
	case "strOptional":
		var strOptional *string
		if u.strOptional != nil {
			strOptional = *u.strOptional
		}
		return v.VisitStrOptional(strOptional)
	case "other":
		return v.VisitOther(*u.other)
	}
}

type ExampleUnionVisitor interface {
	VisitStr(v string) error
	VisitStrOptional(v *string) error
	VisitOther(v int) error
	VisitUnknown(typeName string) error
}

func (u *ExampleUnion) AcceptWithContext(ctx context.Context, v ExampleUnionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "str":
		return v.VisitStrWithContext(ctx, *u.str)
	case "strOptional":
		var strOptional *string
		if u.strOptional != nil {
			strOptional = *u.strOptional
		}
		return v.VisitStrOptionalWithContext(ctx, strOptional)
	case "other":
		return v.VisitOtherWithContext(ctx, *u.other)
	}
}

type ExampleUnionVisitorWithContext interface {
	VisitStrWithContext(ctx context.Context, v string) error
	VisitStrOptionalWithContext(ctx context.Context, v *string) error
	VisitOtherWithContext(ctx context.Context, v int) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewExampleUnionFromStr(v string) ExampleUnion {
	return ExampleUnion{typ: "str", str: &v}
}

func NewExampleUnionFromStrOptional(v *string) ExampleUnion {
	return ExampleUnion{typ: "strOptional", strOptional: &v}
}

func NewExampleUnionFromOther(v int) ExampleUnion {
	return ExampleUnion{typ: "other", other: &v}
}
