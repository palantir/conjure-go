// This file was generated by Conjure and should not be manually edited.

package api

import (
	"context"
	"fmt"
	"io"

	dj "github.com/palantir/conjure-go/v6/dj"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	werror "github.com/palantir/witchcraft-go-error"
)

type ExampleUnion struct {
	typ         string
	str         *string
	strOptional **string
	other       *int
}

func (u ExampleUnion) MarshalJSON() ([]byte, error) {
	out := make([]byte, 0)
	if _, err := u.WriteJSON(dj.NewAppender(&out)); err != nil {
		return nil, err
	}
	return out, dj.Valid(out)
}

func (u ExampleUnion) WriteJSON(w io.Writer) (int, error) {
	var out int
	if n, err := dj.WriteOpenObject(w); err != nil {
		return 0, err
	} else {
		out += n
	}
	switch u.typ {
	case "str":
		if n, err := dj.WriteLiteral(w, "\"type\":\"str\""); err != nil {
			return 0, err
		} else {
			out += n
		}
		if u.str != nil {
			if n, err := dj.WriteLiteral(w, ",\"str\":"); err != nil {
				return 0, err
			} else {
				out += n
			}
			unionVal := *u.str
			if n, err := dj.WriteString(w, unionVal); err != nil {
				return 0, err
			} else {
				out += n
			}
		}
	case "strOptional":
		if n, err := dj.WriteLiteral(w, "\"type\":\"strOptional\""); err != nil {
			return 0, err
		} else {
			out += n
		}
		if u.strOptional != nil {
			if n, err := dj.WriteLiteral(w, ",\"strOptional\":"); err != nil {
				return 0, err
			} else {
				out += n
			}
			unionVal := *u.strOptional
			if unionVal != nil {
				optVal := *unionVal
				if n, err := dj.WriteString(w, optVal); err != nil {
					return 0, err
				} else {
					out += n
				}
			} else {
				if n, err := dj.WriteNull(w); err != nil {
					return 0, err
				} else {
					out += n
				}
			}
		}
	case "other":
		if n, err := dj.WriteLiteral(w, "\"type\":\"other\""); err != nil {
			return 0, err
		} else {
			out += n
		}
		if u.other != nil {
			if n, err := dj.WriteLiteral(w, ",\"other\":"); err != nil {
				return 0, err
			} else {
				out += n
			}
			unionVal := *u.other
			if n, err := dj.WriteInt(w, int64(unionVal)); err != nil {
				return 0, err
			} else {
				out += n
			}
		}
	default:
		if n, err := dj.WriteLiteral(w, "\"type\":"); err != nil {
			return 0, err
		} else {
			out += n
		}
		if n, err := dj.WriteString(w, (u.typ)); err != nil {
			return 0, err
		} else {
			out += n
		}
	}
	if n, err := dj.WriteCloseObject(w); err != nil {
		return 0, err
	} else {
		out += n
	}
	return out, nil
}

func (u *ExampleUnion) UnmarshalJSON(data []byte) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return u.UnmarshalJSONResult(value, false)
}

func (u *ExampleUnion) UnmarshalJSONStrict(data []byte) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return u.UnmarshalJSONResult(value, true)
}

func (u *ExampleUnion) UnmarshalJSONString(data string) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return u.UnmarshalJSONResult(value, false)
}

func (u *ExampleUnion) UnmarshalJSONStringStrict(data string) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return u.UnmarshalJSONResult(value, true)
}

func (u *ExampleUnion) UnmarshalJSONResult(value dj.Result, disallowUnknownFields bool) error {
	var seenType bool
	var seenStr bool
	var seenStrOptional bool
	var seenOther bool
	var unknownFields []string
	iter, idx, err := value.ObjectIterator(0)
	if err != nil {
		return err
	}
	for iter.HasNext(value, idx) {
		var fieldKey, fieldValue dj.Result
		fieldKey, fieldValue, idx, err = iter.Next(value, idx)
		if err != nil {
			return err
		}
		switch fieldKey.Str {
		case "type":
			if seenType {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "ExampleUnion", Field: "type"}
			}
			seenType = true
			u.typ, err = fieldValue.String()
			if err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "ExampleUnion", Field: "type", Err: err})
			}
		case "str":
			if seenStr {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "ExampleUnion", Field: "str"}
			}
			seenStr = true
			var unionVal string
			unionVal, err = fieldValue.String()
			if err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "ExampleUnion", Field: "str", Err: err})
			}
			u.str = &unionVal
		case "strOptional":
			if seenStrOptional {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "ExampleUnion", Field: "strOptional"}
			}
			seenStrOptional = true
			var unionVal *string
			if fieldValue.Type != dj.Null {
				var optVal string
				optVal, err = fieldValue.String()
				if err != nil {
					return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "ExampleUnion", Field: "strOptional", Err: err})
				}
				unionVal = &optVal
			}
			u.strOptional = &unionVal
		case "other":
			if seenOther {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "ExampleUnion", Field: "other"}
			}
			seenOther = true
			var unionVal int
			intVal, err := fieldValue.Int()
			if err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "ExampleUnion", Field: "other", Err: err})
			}
			unionVal = int(intVal)
			u.other = &unionVal
		default:
			if disallowUnknownFields {
				unknownFields = append(unknownFields, fieldKey.Str)
			}
		}
	}
	var missingFields []string
	if !seenType {
		missingFields = append(missingFields, "type")
	}
	if u.typ == "str" && !seenStr {
		missingFields = append(missingFields, "str")
	}
	if u.typ == "other" && !seenOther {
		missingFields = append(missingFields, "other")
	}
	if len(missingFields) > 0 {
		return werror.Convert(dj.UnmarshalMissingFieldsError{Index: value.Index, Type: "ExampleUnion", Fields: missingFields})
	}
	if disallowUnknownFields && len(unknownFields) > 0 {
		return werror.Convert(dj.UnmarshalUnknownFieldsError{Index: value.Index, Type: "ExampleUnion", Fields: unknownFields})
	}
	return nil
}

func (u ExampleUnion) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ExampleUnion) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ExampleUnion) AcceptFuncs(strFunc func(string) error, strOptionalFunc func(*string) error, otherFunc func(int) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "str":
		if u.str == nil {
			return fmt.Errorf("field \"str\" is required")
		}
		return strFunc(*u.str)
	case "strOptional":
		var strOptional *string
		if u.strOptional != nil {
			strOptional = *u.strOptional
		}
		return strOptionalFunc(strOptional)
	case "other":
		if u.other == nil {
			return fmt.Errorf("field \"other\" is required")
		}
		return otherFunc(*u.other)
	}
}

func (u *ExampleUnion) StrNoopSuccess(_ string) error {
	return nil
}

func (u *ExampleUnion) StrOptionalNoopSuccess(_ *string) error {
	return nil
}

func (u *ExampleUnion) OtherNoopSuccess(_ int) error {
	return nil
}

func (u *ExampleUnion) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ExampleUnion) Accept(v ExampleUnionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "str":
		if u.str == nil {
			return fmt.Errorf("field \"str\" is required")
		}
		return v.VisitStr(*u.str)
	case "strOptional":
		var strOptional *string
		if u.strOptional != nil {
			strOptional = *u.strOptional
		}
		return v.VisitStrOptional(strOptional)
	case "other":
		if u.other == nil {
			return fmt.Errorf("field \"other\" is required")
		}
		return v.VisitOther(*u.other)
	}
}

type ExampleUnionVisitor interface {
	VisitStr(v string) error
	VisitStrOptional(v *string) error
	VisitOther(v int) error
	VisitUnknown(typeName string) error
}

func (u *ExampleUnion) AcceptWithContext(ctx context.Context, v ExampleUnionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "str":
		if u.str == nil {
			return fmt.Errorf("field \"str\" is required")
		}
		return v.VisitStrWithContext(ctx, *u.str)
	case "strOptional":
		var strOptional *string
		if u.strOptional != nil {
			strOptional = *u.strOptional
		}
		return v.VisitStrOptionalWithContext(ctx, strOptional)
	case "other":
		if u.other == nil {
			return fmt.Errorf("field \"other\" is required")
		}
		return v.VisitOtherWithContext(ctx, *u.other)
	}
}

type ExampleUnionVisitorWithContext interface {
	VisitStrWithContext(ctx context.Context, v string) error
	VisitStrOptionalWithContext(ctx context.Context, v *string) error
	VisitOtherWithContext(ctx context.Context, v int) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewExampleUnionFromStr(v string) ExampleUnion {
	return ExampleUnion{typ: "str", str: &v}
}

func NewExampleUnionFromStrOptional(v *string) ExampleUnion {
	return ExampleUnion{typ: "strOptional", strOptional: &v}
}

func NewExampleUnionFromOther(v int) ExampleUnion {
	return ExampleUnion{typ: "other", other: &v}
}
