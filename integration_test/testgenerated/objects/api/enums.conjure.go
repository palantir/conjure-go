// This file was generated by Conjure and should not be manually edited.

package api

import (
	"regexp"
	"strings"

	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	werror "github.com/palantir/witchcraft-go-error"
	wparams "github.com/palantir/witchcraft-go-params"
)

var enumValuePattern = regexp.MustCompile("^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$")

type Days struct {
	val Days_Value
}

type Days_Value string

const (
	Days_Friday   Days_Value = "FRIDAY"
	Days_Saturday Days_Value = "SATURDAY"
	Days_Unknown  Days_Value = "UNKNOWN"
)

// Days_Values returns all known variants of Days.
func Days_Values() []Days_Value {
	return []Days_Value{Days_Friday, Days_Saturday}
}

func New_Days(value Days_Value) Days {
	return Days{val: value}
}

// IsUnknown returns false for all known variants of Days and true otherwise.
func (e Days) IsUnknown() bool {
	switch e.val {
	case Days_Friday, Days_Saturday:
		return false
	}
	return true
}

func (e Days) Value() Days_Value {
	if e.IsUnknown() {
		return Days_Unknown
	}
	return e.val
}

func (e Days) String() string {
	return string(e.val)
}

func (e Days) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *Days) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		if !enumValuePattern.MatchString(v) {
			return werror.Convert(errors.NewInvalidArgument(wparams.NewSafeAndUnsafeParamStorer(map[string]interface{}{"enumType": "Days", "message": "enum value must match pattern ^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$"}, map[string]interface{}{"enumValue": string(data)})))
		}
		*e = New_Days(Days_Value(v))
	case "FRIDAY":
		*e = New_Days(Days_Friday)
	case "SATURDAY":
		*e = New_Days(Days_Saturday)
	}
	return nil
}

type Enum struct {
	val Enum_Value
}

type Enum_Value string

const (
	Enum_Value1 Enum_Value = "VALUE1"
	// Docs for an enum value
	Enum_Value2  Enum_Value = "VALUE2"
	Enum_Unknown Enum_Value = "UNKNOWN"
)

// Enum_Values returns all known variants of Enum.
func Enum_Values() []Enum_Value {
	return []Enum_Value{Enum_Value1, Enum_Value2}
}

func New_Enum(value Enum_Value) Enum {
	return Enum{val: value}
}

// IsUnknown returns false for all known variants of Enum and true otherwise.
func (e Enum) IsUnknown() bool {
	switch e.val {
	case Enum_Value1, Enum_Value2:
		return false
	}
	return true
}

func (e Enum) Value() Enum_Value {
	if e.IsUnknown() {
		return Enum_Unknown
	}
	return e.val
}

func (e Enum) String() string {
	return string(e.val)
}

func (e Enum) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *Enum) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		if !enumValuePattern.MatchString(v) {
			return werror.Convert(errors.NewInvalidArgument(wparams.NewSafeAndUnsafeParamStorer(map[string]interface{}{"enumType": "Enum", "message": "enum value must match pattern ^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$"}, map[string]interface{}{"enumValue": string(data)})))
		}
		*e = New_Enum(Enum_Value(v))
	case "VALUE1":
		*e = New_Enum(Enum_Value1)
	case "VALUE2":
		*e = New_Enum(Enum_Value2)
	}
	return nil
}
