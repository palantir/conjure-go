// This file was generated by Conjure and should not be manually edited.

package api

import (
	"context"
	"strings"

	safejson "github.com/palantir/pkg/safejson"
	werror "github.com/palantir/witchcraft-go-error"
	gjson "github.com/tidwall/gjson"
)

type Days struct {
	val Days_Value
}

type Days_Value string

const (
	Days_FRIDAY   Days_Value = "FRIDAY"
	Days_SATURDAY Days_Value = "SATURDAY"
	Days_UNKNOWN  Days_Value = "UNKNOWN"
)

// Days_Values returns all known variants of Days.
func Days_Values() []Days_Value {
	return []Days_Value{Days_FRIDAY, Days_SATURDAY}
}

func New_Days(value Days_Value) Days {
	return Days{val: value}
}

// IsUnknown returns false for all known variants of Days and true otherwise.
func (e Days) IsUnknown() bool {
	switch e.val {
	case Days_FRIDAY, Days_SATURDAY:
		return false
	}
	return true
}

func (e Days) Value() Days_Value {
	if e.IsUnknown() {
		return Days_UNKNOWN
	}
	return e.val
}

func (e Days) String() string {
	return string(e.val)
}

func (e *Days) UnmarshalString(data string) error {
	*e = New_Days(Days_Value(strings.ToUpper(data)))
	return nil
}

func (e Days) MarshalJSON() ([]byte, error) {
	return e.AppendJSON(nil)
}

func (e Days) AppendJSON(out []byte) ([]byte, error) {
	out = safejson.AppendQuotedString(out, string(e.val))
	if !gjson.ValidBytes(out) {
		return nil, werror.ErrorWithContextParams(context.TODO(), "generated invalid json: please report this as a bug on github.com/palantir/conjure-go/issues")
	}
	return out, nil
}

func (e *Days) UnmarshalJSON(data []byte) error {
	ctx := context.TODO()
	if !gjson.ValidBytes(data) {
		return werror.ErrorWithContextParams(ctx, "invalid JSON for Days")
	}
	return e.unmarshalJSONResult(ctx, gjson.ParseBytes(data))
}

func (e *Days) UnmarshalJSONString(data string) error {
	ctx := context.TODO()
	if !gjson.Valid(data) {
		return werror.ErrorWithContextParams(ctx, "invalid JSON for Days")
	}
	return e.unmarshalJSONResult(ctx, gjson.Parse(data))
}

func (e *Days) unmarshalJSONResult(ctx context.Context, value gjson.Result) error {
	var err error
	if value.Type != gjson.String {
		err = werror.ErrorWithContextParams(ctx, "type Days expected JSON string")
		return err
	}
	return e.UnmarshalString(value.Str)
}

type Enum struct {
	val Enum_Value
}

type Enum_Value string

const (
	Enum_VALUE      Enum_Value = "VALUE"
	Enum_VALUES     Enum_Value = "VALUES"
	Enum_VALUES_1   Enum_Value = "VALUES_1"
	Enum_VALUES_1_1 Enum_Value = "VALUES_1_1"
	Enum_VALUE1     Enum_Value = "VALUE1"
	// Docs for an enum value
	Enum_VALUE2  Enum_Value = "VALUE2"
	Enum_UNKNOWN Enum_Value = "UNKNOWN"
)

// Enum_Values returns all known variants of Enum.
func Enum_Values() []Enum_Value {
	return []Enum_Value{Enum_VALUE, Enum_VALUES, Enum_VALUES_1, Enum_VALUES_1_1, Enum_VALUE1, Enum_VALUE2}
}

func New_Enum(value Enum_Value) Enum {
	return Enum{val: value}
}

// IsUnknown returns false for all known variants of Enum and true otherwise.
func (e Enum) IsUnknown() bool {
	switch e.val {
	case Enum_VALUE, Enum_VALUES, Enum_VALUES_1, Enum_VALUES_1_1, Enum_VALUE1, Enum_VALUE2:
		return false
	}
	return true
}

func (e Enum) Value() Enum_Value {
	if e.IsUnknown() {
		return Enum_UNKNOWN
	}
	return e.val
}

func (e Enum) String() string {
	return string(e.val)
}

func (e *Enum) UnmarshalString(data string) error {
	*e = New_Enum(Enum_Value(strings.ToUpper(data)))
	return nil
}

func (e Enum) MarshalJSON() ([]byte, error) {
	return e.AppendJSON(nil)
}

func (e Enum) AppendJSON(out []byte) ([]byte, error) {
	out = safejson.AppendQuotedString(out, string(e.val))
	if !gjson.ValidBytes(out) {
		return nil, werror.ErrorWithContextParams(context.TODO(), "generated invalid json: please report this as a bug on github.com/palantir/conjure-go/issues")
	}
	return out, nil
}

func (e *Enum) UnmarshalJSON(data []byte) error {
	ctx := context.TODO()
	if !gjson.ValidBytes(data) {
		return werror.ErrorWithContextParams(ctx, "invalid JSON for Enum")
	}
	return e.unmarshalJSONResult(ctx, gjson.ParseBytes(data))
}

func (e *Enum) UnmarshalJSONString(data string) error {
	ctx := context.TODO()
	if !gjson.Valid(data) {
		return werror.ErrorWithContextParams(ctx, "invalid JSON for Enum")
	}
	return e.unmarshalJSONResult(ctx, gjson.Parse(data))
}

func (e *Enum) unmarshalJSONResult(ctx context.Context, value gjson.Result) error {
	var err error
	if value.Type != gjson.String {
		err = werror.ErrorWithContextParams(ctx, "type Enum expected JSON string")
		return err
	}
	return e.UnmarshalString(value.Str)
}
