// This file was generated by Conjure and should not be manually edited.

package api

import (
	"context"
	"io"
	"net/http"
	"strconv"

	errors "github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	httpserver "github.com/palantir/conjure-go-runtime/v2/conjure-go-server/httpserver"
	safejson "github.com/palantir/pkg/safejson"
	werror "github.com/palantir/witchcraft-go-error"
	wresource "github.com/palantir/witchcraft-go-server/v2/witchcraft/wresource"
	wrouter "github.com/palantir/witchcraft-go-server/v2/wrouter"
	gjson "github.com/tidwall/gjson"
)

type TestService interface {
	Echo(ctx context.Context, inputArg string) (string, error)
}

// RegisterRoutesTestService registers handlers for the TestService endpoints with a witchcraft wrouter.
// This should typically be called in a witchcraft server's InitFunc.
// impl provides an implementation of each endpoint, which can assume the request parameters have been parsed
// in accordance with the Conjure specification.
func RegisterRoutesTestService(router wrouter.Router, impl TestService) error {
	handler := testServiceHandler{impl: impl}
	resource := wresource.New("testservice", router)
	if err := resource.Post(
		"Echo",
		"/echo",
		httpserver.NewJSONHandler(handler.HandleEcho, httpserver.StatusCodeMapper, httpserver.ErrHandler),
	); err != nil {
		return werror.WrapWithContextParams(context.TODO(), err, "failed to add echo route")
	}
	return nil
}

type testServiceHandler struct {
	impl TestService
}

func (t *testServiceHandler) HandleEcho(rw http.ResponseWriter, req *http.Request) error {
	reqBody, err := io.ReadAll(req.Body)
	if err != nil {
		return errors.WrapWithInternal(err)
	}
	var input string
	if err := func(data []byte) error {
		ctx := req.Context()
		if !gjson.ValidBytes(data) {
			return werror.ErrorWithContextParams(ctx, "invalid JSON for string")
		}
		value := gjson.ParseBytes(data)
		var err error
		if value.Type != gjson.String {
			err = werror.ErrorWithContextParams(ctx, "string expected JSON string")
			return err
		}
		input = value.Str
		return nil
	}(reqBody); err != nil {
		return errors.WrapWithInvalidArgument(err)
	}
	respArg, err := t.impl.Echo(req.Context(), input)
	if err != nil {
		return err
	}
	respBody, err := func(out []byte) ([]byte, error) {
		out = safejson.AppendQuotedString(out, respArg)
		return out, nil
	}(nil)
	if err != nil {
		return errors.WrapWithInternal(err)
	}
	rw.Header().Add("Content-Type", "application/json")
	rw.Header().Add("Content-Length", strconv.Itoa(len(respBody)))
	if _, err := rw.Write(respBody); err != nil {
		return errors.WrapWithInternal(err)
	}
	return nil
}
