// This file was generated by Conjure and should not be manually edited.

package api

import (
	"context"
	"fmt"
	"io"

	dj "github.com/palantir/conjure-go/v6/dj"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	werror "github.com/palantir/witchcraft-go-error"
)

type CustomUnion struct {
	typ       string
	asString  *string
	asInteger *int
}

func (u CustomUnion) MarshalJSON() ([]byte, error) {
	out := make([]byte, 0)
	if _, err := u.WriteJSON(dj.NewAppender(&out)); err != nil {
		return nil, err
	}
	return out, dj.Valid(out)
}

func (u CustomUnion) WriteJSON(w io.Writer) (int, error) {
	var out int
	if n, err := dj.WriteOpenObject(w); err != nil {
		return 0, err
	} else {
		out += n
	}
	switch u.typ {
	case "asString":
		if n, err := dj.WriteLiteral(w, "\"type\":\"asString\""); err != nil {
			return 0, err
		} else {
			out += n
		}
		if u.asString != nil {
			if n, err := dj.WriteLiteral(w, ",\"asString\":"); err != nil {
				return 0, err
			} else {
				out += n
			}
			unionVal := *u.asString
			if n, err := dj.WriteString(w, unionVal); err != nil {
				return 0, err
			} else {
				out += n
			}
		}
	case "asInteger":
		if n, err := dj.WriteLiteral(w, "\"type\":\"asInteger\""); err != nil {
			return 0, err
		} else {
			out += n
		}
		if u.asInteger != nil {
			if n, err := dj.WriteLiteral(w, ",\"asInteger\":"); err != nil {
				return 0, err
			} else {
				out += n
			}
			unionVal := *u.asInteger
			if n, err := dj.WriteInt(w, int64(unionVal)); err != nil {
				return 0, err
			} else {
				out += n
			}
		}
	default:
		if n, err := dj.WriteLiteral(w, "\"type\":"); err != nil {
			return 0, err
		} else {
			out += n
		}
		if n, err := dj.WriteString(w, (u.typ)); err != nil {
			return 0, err
		} else {
			out += n
		}
	}
	if n, err := dj.WriteCloseObject(w); err != nil {
		return 0, err
	} else {
		out += n
	}
	return out, nil
}

func (u *CustomUnion) UnmarshalJSON(data []byte) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return u.UnmarshalJSONResult(value, false)
}

func (u *CustomUnion) UnmarshalJSONStrict(data []byte) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return u.UnmarshalJSONResult(value, true)
}

func (u *CustomUnion) UnmarshalJSONString(data string) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return u.UnmarshalJSONResult(value, false)
}

func (u *CustomUnion) UnmarshalJSONStringStrict(data string) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return u.UnmarshalJSONResult(value, true)
}

func (u *CustomUnion) UnmarshalJSONResult(value dj.Result, disallowUnknownFields bool) error {
	var seenType bool
	var seenAsString bool
	var seenAsInteger bool
	var unknownFields []string
	iter, idx, err := value.ObjectIterator(0)
	if err != nil {
		return err
	}
	for iter.HasNext(value, idx) {
		var fieldKey, fieldValue dj.Result
		fieldKey, fieldValue, idx, err = iter.Next(value, idx)
		if err != nil {
			return err
		}
		switch fieldKey.Str {
		case "type":
			if seenType {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "CustomUnion", Field: "type"}
			}
			seenType = true
			u.typ, err = fieldValue.String()
			if err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "CustomUnion", Field: "type", Err: err})
			}
		case "asString":
			if seenAsString {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "CustomUnion", Field: "asString"}
			}
			seenAsString = true
			var unionVal string
			unionVal, err = fieldValue.String()
			if err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "CustomUnion", Field: "asString", Err: err})
			}
			u.asString = &unionVal
		case "asInteger":
			if seenAsInteger {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "CustomUnion", Field: "asInteger"}
			}
			seenAsInteger = true
			var unionVal int
			intVal, err := fieldValue.Int()
			if err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "CustomUnion", Field: "asInteger", Err: err})
			}
			unionVal = int(intVal)
			u.asInteger = &unionVal
		default:
			if disallowUnknownFields {
				unknownFields = append(unknownFields, fieldKey.Str)
			}
		}
	}
	var missingFields []string
	if !seenType {
		missingFields = append(missingFields, "type")
	}
	if u.typ == "asString" && !seenAsString {
		missingFields = append(missingFields, "asString")
	}
	if u.typ == "asInteger" && !seenAsInteger {
		missingFields = append(missingFields, "asInteger")
	}
	if len(missingFields) > 0 {
		return werror.Convert(dj.UnmarshalMissingFieldsError{Index: value.Index, Type: "CustomUnion", Fields: missingFields})
	}
	if disallowUnknownFields && len(unknownFields) > 0 {
		return werror.Convert(dj.UnmarshalUnknownFieldsError{Index: value.Index, Type: "CustomUnion", Fields: unknownFields})
	}
	return nil
}

func (u CustomUnion) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *CustomUnion) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *CustomUnion) AcceptFuncs(asStringFunc func(string) error, asIntegerFunc func(int) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "asString":
		if u.asString == nil {
			return fmt.Errorf("field \"asString\" is required")
		}
		return asStringFunc(*u.asString)
	case "asInteger":
		if u.asInteger == nil {
			return fmt.Errorf("field \"asInteger\" is required")
		}
		return asIntegerFunc(*u.asInteger)
	}
}

func (u *CustomUnion) AsStringNoopSuccess(_ string) error {
	return nil
}

func (u *CustomUnion) AsIntegerNoopSuccess(_ int) error {
	return nil
}

func (u *CustomUnion) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *CustomUnion) Accept(v CustomUnionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "asString":
		if u.asString == nil {
			return fmt.Errorf("field \"asString\" is required")
		}
		return v.VisitAsString(*u.asString)
	case "asInteger":
		if u.asInteger == nil {
			return fmt.Errorf("field \"asInteger\" is required")
		}
		return v.VisitAsInteger(*u.asInteger)
	}
}

type CustomUnionVisitor interface {
	VisitAsString(v string) error
	VisitAsInteger(v int) error
	VisitUnknown(typeName string) error
}

func (u *CustomUnion) AcceptWithContext(ctx context.Context, v CustomUnionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "asString":
		if u.asString == nil {
			return fmt.Errorf("field \"asString\" is required")
		}
		return v.VisitAsStringWithContext(ctx, *u.asString)
	case "asInteger":
		if u.asInteger == nil {
			return fmt.Errorf("field \"asInteger\" is required")
		}
		return v.VisitAsIntegerWithContext(ctx, *u.asInteger)
	}
}

type CustomUnionVisitorWithContext interface {
	VisitAsStringWithContext(ctx context.Context, v string) error
	VisitAsIntegerWithContext(ctx context.Context, v int) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewCustomUnionFromAsString(v string) CustomUnion {
	return CustomUnion{typ: "asString", asString: &v}
}

func NewCustomUnionFromAsInteger(v int) CustomUnion {
	return CustomUnion{typ: "asInteger", asInteger: &v}
}
