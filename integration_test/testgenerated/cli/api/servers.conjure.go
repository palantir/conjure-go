// This file was generated by Conjure and should not be manually edited.

package api

import (
	"context"
	"io"
	"net/http"
	"strconv"

	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/codecs"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-server/httpserver"
	"github.com/palantir/pkg/bearertoken"
	"github.com/palantir/pkg/datetime"
	"github.com/palantir/pkg/rid"
	"github.com/palantir/pkg/safelong"
	"github.com/palantir/pkg/uuid"
	"github.com/palantir/witchcraft-go-error"
	"github.com/palantir/witchcraft-go-server/v2/witchcraft/wresource"
	"github.com/palantir/witchcraft-go-server/v2/wrouter"
)

type TestService interface {
	Echo(ctx context.Context, cookieToken bearertoken.Token) error
	// These are some endpoint docs
	EchoStrings(ctx context.Context, bodyArg []string) ([]string, error)
	EchoCustomObject(ctx context.Context, bodyArg *CustomObject) (*CustomObject, error)
	EchoOptionalAlias(ctx context.Context, bodyArg OptionalIntegerAlias) (OptionalIntegerAlias, error)
	EchoOptionalListAlias(ctx context.Context, bodyArg OptionalListAlias) (OptionalListAlias, error)
	GetPathParam(ctx context.Context, authHeader bearertoken.Token, myPathParamArg string) error
	GetListBoolean(ctx context.Context, myQueryParam1Arg []bool) ([]bool, error)
	PutMapStringString(ctx context.Context, myParamArg map[string]string) (map[string]string, error)
	PutMapStringAny(ctx context.Context, myParamArg map[string]interface{}) (map[string]interface{}, error)
	GetDateTime(ctx context.Context, myParamArg datetime.DateTime) (datetime.DateTime, error)
	GetDouble(ctx context.Context, myParamArg float64) (float64, error)
	GetRid(ctx context.Context, myParamArg rid.ResourceIdentifier) (rid.ResourceIdentifier, error)
	GetSafeLong(ctx context.Context, myParamArg safelong.SafeLong) (safelong.SafeLong, error)
	GetUuid(ctx context.Context, myParamArg uuid.UUID) (uuid.UUID, error)
	GetEnum(ctx context.Context, myParamArg CustomEnum) (CustomEnum, error)
	PutBinary(ctx context.Context, myParamArg io.ReadCloser) (io.ReadCloser, error)
	GetOptionalBinary(ctx context.Context) (*io.ReadCloser, error)
	PutCustomUnion(ctx context.Context, myParamArg CustomUnion) (CustomUnion, error)
	// An endpoint that uses reserved flag names
	GetReserved(ctx context.Context, confArg string, bearertokenArg string) error
	// An endpoint that uses go keywords
	Chan(ctx context.Context, varArg string, importArg map[string]string, typeArg string, returnArg safelong.SafeLong, httpArg string, jsonArg string, reqArg string, rwArg string) error
}

// RegisterRoutesTestService registers handlers for the TestService endpoints with a witchcraft wrouter.
// This should typically be called in a witchcraft server's InitFunc.
// impl provides an implementation of each endpoint, which can assume the request parameters have been parsed
// in accordance with the Conjure specification.
func RegisterRoutesTestService(router wrouter.Router, impl TestService, routerParams ...wrouter.RouteParam) error {
	handler := testServiceHandler{impl: impl}
	resource := wresource.New("testservice", router)
	if err := resource.Get("Echo", "/echo", httpserver.NewJSONHandler(handler.HandleEcho, httpserver.StatusCodeMapper, httpserver.ErrHandler), routerParams...); err != nil {
		return werror.Wrap(err, "failed to add echo route")
	}
	if err := resource.Post("EchoStrings", "/echo", httpserver.NewJSONHandler(handler.HandleEchoStrings, httpserver.StatusCodeMapper, httpserver.ErrHandler), routerParams...); err != nil {
		return werror.Wrap(err, "failed to add echoStrings route")
	}
	if err := resource.Post("EchoCustomObject", "/echoCustomObject", httpserver.NewJSONHandler(handler.HandleEchoCustomObject, httpserver.StatusCodeMapper, httpserver.ErrHandler), routerParams...); err != nil {
		return werror.Wrap(err, "failed to add echoCustomObject route")
	}
	if err := resource.Post("EchoOptionalAlias", "/optional/alias", httpserver.NewJSONHandler(handler.HandleEchoOptionalAlias, httpserver.StatusCodeMapper, httpserver.ErrHandler), routerParams...); err != nil {
		return werror.Wrap(err, "failed to add echoOptionalAlias route")
	}
	if err := resource.Post("EchoOptionalListAlias", "/optional/list-alias", httpserver.NewJSONHandler(handler.HandleEchoOptionalListAlias, httpserver.StatusCodeMapper, httpserver.ErrHandler), routerParams...); err != nil {
		return werror.Wrap(err, "failed to add echoOptionalListAlias route")
	}
	if err := resource.Get("GetPathParam", "/path/string/{myPathParam}", httpserver.NewJSONHandler(handler.HandleGetPathParam, httpserver.StatusCodeMapper, httpserver.ErrHandler), routerParams...); err != nil {
		return werror.Wrap(err, "failed to add getPathParam route")
	}
	if err := resource.Get("GetListBoolean", "/booleanListQueryVar", httpserver.NewJSONHandler(handler.HandleGetListBoolean, httpserver.StatusCodeMapper, httpserver.ErrHandler), routerParams...); err != nil {
		return werror.Wrap(err, "failed to add getListBoolean route")
	}
	if err := resource.Put("PutMapStringString", "/mapStringString", httpserver.NewJSONHandler(handler.HandlePutMapStringString, httpserver.StatusCodeMapper, httpserver.ErrHandler), routerParams...); err != nil {
		return werror.Wrap(err, "failed to add putMapStringString route")
	}
	if err := resource.Put("PutMapStringAny", "/mapStringAny", httpserver.NewJSONHandler(handler.HandlePutMapStringAny, httpserver.StatusCodeMapper, httpserver.ErrHandler), routerParams...); err != nil {
		return werror.Wrap(err, "failed to add putMapStringAny route")
	}
	if err := resource.Get("GetDateTime", "/getDateTime", httpserver.NewJSONHandler(handler.HandleGetDateTime, httpserver.StatusCodeMapper, httpserver.ErrHandler), routerParams...); err != nil {
		return werror.Wrap(err, "failed to add getDateTime route")
	}
	if err := resource.Get("GetDouble", "/getDouble", httpserver.NewJSONHandler(handler.HandleGetDouble, httpserver.StatusCodeMapper, httpserver.ErrHandler), routerParams...); err != nil {
		return werror.Wrap(err, "failed to add getDouble route")
	}
	if err := resource.Get("GetRid", "/getRid", httpserver.NewJSONHandler(handler.HandleGetRid, httpserver.StatusCodeMapper, httpserver.ErrHandler), routerParams...); err != nil {
		return werror.Wrap(err, "failed to add getRid route")
	}
	if err := resource.Get("GetSafeLong", "/getSafeLong", httpserver.NewJSONHandler(handler.HandleGetSafeLong, httpserver.StatusCodeMapper, httpserver.ErrHandler), routerParams...); err != nil {
		return werror.Wrap(err, "failed to add getSafeLong route")
	}
	if err := resource.Get("GetUuid", "/getUuid", httpserver.NewJSONHandler(handler.HandleGetUuid, httpserver.StatusCodeMapper, httpserver.ErrHandler), routerParams...); err != nil {
		return werror.Wrap(err, "failed to add getUuid route")
	}
	if err := resource.Get("GetEnum", "/getEnum", httpserver.NewJSONHandler(handler.HandleGetEnum, httpserver.StatusCodeMapper, httpserver.ErrHandler), routerParams...); err != nil {
		return werror.Wrap(err, "failed to add getEnum route")
	}
	if err := resource.Put("PutBinary", "/binary", httpserver.NewJSONHandler(handler.HandlePutBinary, httpserver.StatusCodeMapper, httpserver.ErrHandler), routerParams...); err != nil {
		return werror.Wrap(err, "failed to add putBinary route")
	}
	if err := resource.Get("GetOptionalBinary", "/optional/binary", httpserver.NewJSONHandler(handler.HandleGetOptionalBinary, httpserver.StatusCodeMapper, httpserver.ErrHandler), routerParams...); err != nil {
		return werror.Wrap(err, "failed to add getOptionalBinary route")
	}
	if err := resource.Put("PutCustomUnion", "/customUnion", httpserver.NewJSONHandler(handler.HandlePutCustomUnion, httpserver.StatusCodeMapper, httpserver.ErrHandler), routerParams...); err != nil {
		return werror.Wrap(err, "failed to add putCustomUnion route")
	}
	if err := resource.Get("GetReserved", "/getReserved", httpserver.NewJSONHandler(handler.HandleGetReserved, httpserver.StatusCodeMapper, httpserver.ErrHandler), routerParams...); err != nil {
		return werror.Wrap(err, "failed to add getReserved route")
	}
	if err := resource.Post("Chan", "/chan/{var}", httpserver.NewJSONHandler(handler.HandleChan, httpserver.StatusCodeMapper, httpserver.ErrHandler), routerParams...); err != nil {
		return werror.Wrap(err, "failed to add chan route")
	}
	return nil
}

type testServiceHandler struct {
	impl TestService
}

func (t *testServiceHandler) HandleEcho(rw http.ResponseWriter, req *http.Request) error {
	authCookie, err := req.Cookie("PALANTIR_TOKEN")
	if err != nil {
		return errors.WrapWithPermissionDenied(err)
	}
	cookieToken := bearertoken.Token(authCookie.Value)
	if err := t.impl.Echo(req.Context(), cookieToken); err != nil {
		return err
	}
	rw.WriteHeader(http.StatusNoContent)
	return nil
}

func (t *testServiceHandler) HandleEchoStrings(rw http.ResponseWriter, req *http.Request) error {
	var bodyArg []string
	if err := codecs.JSON.Decode(req.Body, &bodyArg); err != nil {
		return errors.WrapWithInvalidArgument(err)
	}
	respArg, err := t.impl.EchoStrings(req.Context(), bodyArg)
	if err != nil {
		return err
	}
	rw.Header().Add("Content-Type", codecs.JSON.ContentType())
	return codecs.JSON.Encode(rw, respArg)
}

func (t *testServiceHandler) HandleEchoCustomObject(rw http.ResponseWriter, req *http.Request) error {
	var bodyArg *CustomObject
	if req.Body != nil && req.Body != http.NoBody {
		if err := codecs.JSON.Decode(req.Body, &bodyArg); err != nil {
			return errors.WrapWithInvalidArgument(err)
		}
	}
	respArg, err := t.impl.EchoCustomObject(req.Context(), bodyArg)
	if err != nil {
		return err
	}
	if respArg == nil {
		rw.WriteHeader(http.StatusNoContent)
		return nil
	}
	rw.Header().Add("Content-Type", codecs.JSON.ContentType())
	return codecs.JSON.Encode(rw, *respArg)
}

func (t *testServiceHandler) HandleEchoOptionalAlias(rw http.ResponseWriter, req *http.Request) error {
	var bodyArg OptionalIntegerAlias
	if req.Body != nil && req.Body != http.NoBody {
		if err := codecs.JSON.Decode(req.Body, &bodyArg); err != nil {
			return errors.WrapWithInvalidArgument(err)
		}
	}
	respArg, err := t.impl.EchoOptionalAlias(req.Context(), bodyArg)
	if err != nil {
		return err
	}
	if respArg.Value == nil {
		rw.WriteHeader(http.StatusNoContent)
		return nil
	}
	rw.Header().Add("Content-Type", codecs.JSON.ContentType())
	return codecs.JSON.Encode(rw, respArg)
}

func (t *testServiceHandler) HandleEchoOptionalListAlias(rw http.ResponseWriter, req *http.Request) error {
	var bodyArg OptionalListAlias
	if req.Body != nil && req.Body != http.NoBody {
		if err := codecs.JSON.Decode(req.Body, &bodyArg); err != nil {
			return errors.WrapWithInvalidArgument(err)
		}
	}
	respArg, err := t.impl.EchoOptionalListAlias(req.Context(), bodyArg)
	if err != nil {
		return err
	}
	if respArg.Value == nil {
		rw.WriteHeader(http.StatusNoContent)
		return nil
	}
	rw.Header().Add("Content-Type", codecs.JSON.ContentType())
	return codecs.JSON.Encode(rw, respArg)
}

func (t *testServiceHandler) HandleGetPathParam(rw http.ResponseWriter, req *http.Request) error {
	authHeader, err := httpserver.ParseBearerTokenHeader(req)
	if err != nil {
		return errors.WrapWithPermissionDenied(err)
	}
	pathParams := wrouter.PathParams(req)
	if pathParams == nil {
		return werror.Wrap(errors.NewInternal(), "path params not found on request: ensure this endpoint is registered with wrouter")
	}
	myPathParamArg, ok := pathParams["myPathParam"]
	if !ok {
		return werror.WrapWithContextParams(req.Context(), errors.NewInvalidArgument(), "path parameter \"myPathParam\" not present")
	}
	if err := t.impl.GetPathParam(req.Context(), bearertoken.Token(authHeader), myPathParamArg); err != nil {
		return err
	}
	rw.WriteHeader(http.StatusNoContent)
	return nil
}

func (t *testServiceHandler) HandleGetListBoolean(rw http.ResponseWriter, req *http.Request) error {
	var myQueryParam1Arg []bool
	for _, v := range req.URL.Query()["myQueryParam1"] {
		convertedVal, err := strconv.ParseBool(v)
		if err != nil {
			return werror.WrapWithContextParams(req.Context(), errors.WrapWithInvalidArgument(err), "failed to parse \"myQueryParam1\" as boolean")
		}
		myQueryParam1Arg = append(myQueryParam1Arg, convertedVal)
	}
	respArg, err := t.impl.GetListBoolean(req.Context(), myQueryParam1Arg)
	if err != nil {
		return err
	}
	rw.Header().Add("Content-Type", codecs.JSON.ContentType())
	return codecs.JSON.Encode(rw, respArg)
}

func (t *testServiceHandler) HandlePutMapStringString(rw http.ResponseWriter, req *http.Request) error {
	var myParamArg map[string]string
	if err := codecs.JSON.Decode(req.Body, &myParamArg); err != nil {
		return errors.WrapWithInvalidArgument(err)
	}
	respArg, err := t.impl.PutMapStringString(req.Context(), myParamArg)
	if err != nil {
		return err
	}
	rw.Header().Add("Content-Type", codecs.JSON.ContentType())
	return codecs.JSON.Encode(rw, respArg)
}

func (t *testServiceHandler) HandlePutMapStringAny(rw http.ResponseWriter, req *http.Request) error {
	var myParamArg map[string]interface{}
	if err := codecs.JSON.Decode(req.Body, &myParamArg); err != nil {
		return errors.WrapWithInvalidArgument(err)
	}
	respArg, err := t.impl.PutMapStringAny(req.Context(), myParamArg)
	if err != nil {
		return err
	}
	rw.Header().Add("Content-Type", codecs.JSON.ContentType())
	return codecs.JSON.Encode(rw, respArg)
}

func (t *testServiceHandler) HandleGetDateTime(rw http.ResponseWriter, req *http.Request) error {
	myParamArg, err := datetime.ParseDateTime(req.URL.Query().Get("myParam"))
	if err != nil {
		return werror.WrapWithContextParams(req.Context(), errors.WrapWithInvalidArgument(err), "failed to parse \"myParam\" as datetime")
	}
	respArg, err := t.impl.GetDateTime(req.Context(), myParamArg)
	if err != nil {
		return err
	}
	rw.Header().Add("Content-Type", codecs.JSON.ContentType())
	return codecs.JSON.Encode(rw, respArg)
}

func (t *testServiceHandler) HandleGetDouble(rw http.ResponseWriter, req *http.Request) error {
	myParamArg, err := strconv.ParseFloat(req.URL.Query().Get("myParam"), 64)
	if err != nil {
		return werror.WrapWithContextParams(req.Context(), errors.WrapWithInvalidArgument(err), "failed to parse \"myParam\" as double")
	}
	respArg, err := t.impl.GetDouble(req.Context(), myParamArg)
	if err != nil {
		return err
	}
	rw.Header().Add("Content-Type", codecs.JSON.ContentType())
	return codecs.JSON.Encode(rw, respArg)
}

func (t *testServiceHandler) HandleGetRid(rw http.ResponseWriter, req *http.Request) error {
	myParamArg, err := rid.ParseRID(req.URL.Query().Get("myParam"))
	if err != nil {
		return werror.WrapWithContextParams(req.Context(), errors.WrapWithInvalidArgument(err), "failed to parse \"myParam\" as rid")
	}
	respArg, err := t.impl.GetRid(req.Context(), myParamArg)
	if err != nil {
		return err
	}
	rw.Header().Add("Content-Type", codecs.JSON.ContentType())
	return codecs.JSON.Encode(rw, respArg)
}

func (t *testServiceHandler) HandleGetSafeLong(rw http.ResponseWriter, req *http.Request) error {
	myParamArg, err := safelong.ParseSafeLong(req.URL.Query().Get("myParam"))
	if err != nil {
		return werror.WrapWithContextParams(req.Context(), errors.WrapWithInvalidArgument(err), "failed to parse \"myParam\" as safelong")
	}
	respArg, err := t.impl.GetSafeLong(req.Context(), myParamArg)
	if err != nil {
		return err
	}
	rw.Header().Add("Content-Type", codecs.JSON.ContentType())
	return codecs.JSON.Encode(rw, respArg)
}

func (t *testServiceHandler) HandleGetUuid(rw http.ResponseWriter, req *http.Request) error {
	myParamArg, err := uuid.ParseUUID(req.URL.Query().Get("myParam"))
	if err != nil {
		return werror.WrapWithContextParams(req.Context(), errors.WrapWithInvalidArgument(err), "failed to parse \"myParam\" as uuid")
	}
	respArg, err := t.impl.GetUuid(req.Context(), myParamArg)
	if err != nil {
		return err
	}
	rw.Header().Add("Content-Type", codecs.JSON.ContentType())
	return codecs.JSON.Encode(rw, respArg)
}

func (t *testServiceHandler) HandleGetEnum(rw http.ResponseWriter, req *http.Request) error {
	var myParamArg CustomEnum
	if err := myParamArg.UnmarshalText([]byte(req.URL.Query().Get("myParam"))); err != nil {
		return werror.WrapWithContextParams(req.Context(), errors.WrapWithInvalidArgument(err), "failed to parse \"myParam\" as CustomEnum")
	}
	respArg, err := t.impl.GetEnum(req.Context(), myParamArg)
	if err != nil {
		return err
	}
	rw.Header().Add("Content-Type", codecs.JSON.ContentType())
	return codecs.JSON.Encode(rw, respArg)
}

func (t *testServiceHandler) HandlePutBinary(rw http.ResponseWriter, req *http.Request) error {
	myParamArg := req.Body
	respArg, err := t.impl.PutBinary(req.Context(), myParamArg)
	if err != nil {
		return err
	}
	rw.Header().Add("Content-Type", codecs.Binary.ContentType())
	return codecs.Binary.Encode(rw, respArg)
}

func (t *testServiceHandler) HandleGetOptionalBinary(rw http.ResponseWriter, req *http.Request) error {
	respArg, err := t.impl.GetOptionalBinary(req.Context())
	if err != nil {
		return err
	}
	if respArg == nil {
		rw.WriteHeader(http.StatusNoContent)
		return nil
	}
	rw.Header().Add("Content-Type", codecs.Binary.ContentType())
	return codecs.Binary.Encode(rw, *respArg)
}

func (t *testServiceHandler) HandlePutCustomUnion(rw http.ResponseWriter, req *http.Request) error {
	var myParamArg CustomUnion
	if err := codecs.JSON.Decode(req.Body, &myParamArg); err != nil {
		return errors.WrapWithInvalidArgument(err)
	}
	respArg, err := t.impl.PutCustomUnion(req.Context(), myParamArg)
	if err != nil {
		return err
	}
	rw.Header().Add("Content-Type", codecs.JSON.ContentType())
	return codecs.JSON.Encode(rw, respArg)
}

func (t *testServiceHandler) HandleGetReserved(rw http.ResponseWriter, req *http.Request) error {
	confArg := req.URL.Query().Get("conf")
	bearertokenArg := req.URL.Query().Get("bearertoken")
	if err := t.impl.GetReserved(req.Context(), confArg, bearertokenArg); err != nil {
		return err
	}
	rw.WriteHeader(http.StatusNoContent)
	return nil
}

func (t *testServiceHandler) HandleChan(rw http.ResponseWriter, req *http.Request) error {
	pathParams := wrouter.PathParams(req)
	if pathParams == nil {
		return werror.Wrap(errors.NewInternal(), "path params not found on request: ensure this endpoint is registered with wrouter")
	}
	varArg, ok := pathParams["var"]
	if !ok {
		return werror.WrapWithContextParams(req.Context(), errors.NewInvalidArgument(), "path parameter \"var\" not present")
	}
	typeArg := req.URL.Query().Get("type")
	httpArg := req.URL.Query().Get("http")
	jsonArg := req.URL.Query().Get("json")
	reqArg := req.URL.Query().Get("req")
	rwArg := req.URL.Query().Get("rw")
	returnArg, err := safelong.ParseSafeLong(req.Header.Get("X-My-Header2"))
	if err != nil {
		return werror.WrapWithContextParams(req.Context(), errors.WrapWithInvalidArgument(err), "failed to parse \"return\" as safelong")
	}
	var importArg map[string]string
	if err := codecs.JSON.Decode(req.Body, &importArg); err != nil {
		return errors.WrapWithInvalidArgument(err)
	}
	if err := t.impl.Chan(req.Context(), varArg, importArg, typeArg, returnArg, httpArg, jsonArg, reqArg, rwArg); err != nil {
		return err
	}
	rw.WriteHeader(http.StatusNoContent)
	return nil
}
