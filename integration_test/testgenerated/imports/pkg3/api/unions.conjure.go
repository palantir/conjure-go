// This file was generated by Conjure and should not be manually edited.

package api

import (
	"context"
	"fmt"
	"io"

	dj "github.com/palantir/conjure-go/v6/dj"
	"github.com/palantir/conjure-go/v6/integration_test/testgenerated/imports/pkg1/api"
	api1 "github.com/palantir/conjure-go/v6/integration_test/testgenerated/imports/pkg2/api"
	v2 "github.com/palantir/conjure-go/v6/integration_test/testgenerated/imports/pkg4/v2"
	v21 "github.com/palantir/conjure-go/v6/integration_test/testgenerated/imports/pkg5/v2"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	werror "github.com/palantir/witchcraft-go-error"
)

type Union struct {
	typ   string
	one   *api.Struct1
	two   *api1.Struct2
	three *v2.ObjectInPackageEndingInVersion
	four  *v21.DifferentPackageEndingInVersion
}

func (u Union) MarshalJSON() ([]byte, error) {
	out := make([]byte, 0)
	if _, err := u.WriteJSON(dj.NewAppender(&out)); err != nil {
		return nil, err
	}
	return out, dj.Valid(out)
}

func (u Union) WriteJSON(w io.Writer) (int, error) {
	var out int
	if n, err := dj.WriteOpenObject(w); err != nil {
		return 0, err
	} else {
		out += n
	}
	switch u.typ {
	case "one":
		if n, err := dj.WriteLiteral(w, "\"type\":\"one\""); err != nil {
			return 0, err
		} else {
			out += n
		}
		if u.one != nil {
			if n, err := dj.WriteLiteral(w, ",\"one\":"); err != nil {
				return 0, err
			} else {
				out += n
			}
			unionVal := *u.one
			if n, err := unionVal.WriteJSON(w); err != nil {
				return 0, err
			} else {
				out += n
			}
		}
	case "two":
		if n, err := dj.WriteLiteral(w, "\"type\":\"two\""); err != nil {
			return 0, err
		} else {
			out += n
		}
		if u.two != nil {
			if n, err := dj.WriteLiteral(w, ",\"two\":"); err != nil {
				return 0, err
			} else {
				out += n
			}
			unionVal := *u.two
			if n, err := unionVal.WriteJSON(w); err != nil {
				return 0, err
			} else {
				out += n
			}
		}
	case "three":
		if n, err := dj.WriteLiteral(w, "\"type\":\"three\""); err != nil {
			return 0, err
		} else {
			out += n
		}
		if u.three != nil {
			if n, err := dj.WriteLiteral(w, ",\"three\":"); err != nil {
				return 0, err
			} else {
				out += n
			}
			unionVal := *u.three
			if n, err := unionVal.WriteJSON(w); err != nil {
				return 0, err
			} else {
				out += n
			}
		}
	case "four":
		if n, err := dj.WriteLiteral(w, "\"type\":\"four\""); err != nil {
			return 0, err
		} else {
			out += n
		}
		if u.four != nil {
			if n, err := dj.WriteLiteral(w, ",\"four\":"); err != nil {
				return 0, err
			} else {
				out += n
			}
			unionVal := *u.four
			if n, err := unionVal.WriteJSON(w); err != nil {
				return 0, err
			} else {
				out += n
			}
		}
	default:
		if n, err := dj.WriteLiteral(w, "\"type\":"); err != nil {
			return 0, err
		} else {
			out += n
		}
		if n, err := dj.WriteString(w, (u.typ)); err != nil {
			return 0, err
		} else {
			out += n
		}
	}
	if n, err := dj.WriteCloseObject(w); err != nil {
		return 0, err
	} else {
		out += n
	}
	return out, nil
}

func (u *Union) UnmarshalJSON(data []byte) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return u.UnmarshalJSONResult(value, false)
}

func (u *Union) UnmarshalJSONStrict(data []byte) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return u.UnmarshalJSONResult(value, true)
}

func (u *Union) UnmarshalJSONString(data string) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return u.UnmarshalJSONResult(value, false)
}

func (u *Union) UnmarshalJSONStringStrict(data string) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return u.UnmarshalJSONResult(value, true)
}

func (u *Union) UnmarshalJSONResult(value dj.Result, disallowUnknownFields bool) error {
	var seenType bool
	var seenOne bool
	var seenTwo bool
	var seenThree bool
	var seenFour bool
	var unknownFields []string
	iter, idx, err := value.ObjectIterator(0)
	if err != nil {
		return err
	}
	for iter.HasNext(value, idx) {
		var fieldKey, fieldValue dj.Result
		fieldKey, fieldValue, idx, err = iter.Next(value, idx)
		if err != nil {
			return err
		}
		switch fieldKey.Str {
		case "type":
			if seenType {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "Union", Field: "type"}
			}
			seenType = true
			u.typ, err = fieldValue.String()
			if err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "Union", Field: "type", Err: err})
			}
		case "one":
			if seenOne {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "Union", Field: "one"}
			}
			seenOne = true
			var unionVal api.Struct1
			if err := unionVal.UnmarshalJSONResult(fieldValue, disallowUnknownFields); err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "Union", Field: "one", Err: err})
			}
			u.one = &unionVal
		case "two":
			if seenTwo {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "Union", Field: "two"}
			}
			seenTwo = true
			var unionVal api1.Struct2
			if err := unionVal.UnmarshalJSONResult(fieldValue, disallowUnknownFields); err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "Union", Field: "two", Err: err})
			}
			u.two = &unionVal
		case "three":
			if seenThree {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "Union", Field: "three"}
			}
			seenThree = true
			var unionVal v2.ObjectInPackageEndingInVersion
			if err := unionVal.UnmarshalJSONResult(fieldValue, disallowUnknownFields); err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "Union", Field: "three", Err: err})
			}
			u.three = &unionVal
		case "four":
			if seenFour {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "Union", Field: "four"}
			}
			seenFour = true
			var unionVal v21.DifferentPackageEndingInVersion
			if err := unionVal.UnmarshalJSONResult(fieldValue, disallowUnknownFields); err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "Union", Field: "four", Err: err})
			}
			u.four = &unionVal
		default:
			if disallowUnknownFields {
				unknownFields = append(unknownFields, fieldKey.Str)
			}
		}
	}
	var missingFields []string
	if !seenType {
		missingFields = append(missingFields, "type")
	}
	if u.typ == "one" && !seenOne {
		missingFields = append(missingFields, "one")
	}
	if u.typ == "two" && !seenTwo {
		missingFields = append(missingFields, "two")
	}
	if u.typ == "three" && !seenThree {
		missingFields = append(missingFields, "three")
	}
	if u.typ == "four" && !seenFour {
		missingFields = append(missingFields, "four")
	}
	if len(missingFields) > 0 {
		return werror.Convert(dj.UnmarshalMissingFieldsError{Index: value.Index, Type: "Union", Fields: missingFields})
	}
	if disallowUnknownFields && len(unknownFields) > 0 {
		return werror.Convert(dj.UnmarshalUnknownFieldsError{Index: value.Index, Type: "Union", Fields: unknownFields})
	}
	return nil
}

func (u Union) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Union) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Union) AcceptFuncs(oneFunc func(api.Struct1) error, twoFunc func(api1.Struct2) error, threeFunc func(v2.ObjectInPackageEndingInVersion) error, fourFunc func(v21.DifferentPackageEndingInVersion) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "one":
		if u.one == nil {
			return fmt.Errorf("field \"one\" is required")
		}
		return oneFunc(*u.one)
	case "two":
		if u.two == nil {
			return fmt.Errorf("field \"two\" is required")
		}
		return twoFunc(*u.two)
	case "three":
		if u.three == nil {
			return fmt.Errorf("field \"three\" is required")
		}
		return threeFunc(*u.three)
	case "four":
		if u.four == nil {
			return fmt.Errorf("field \"four\" is required")
		}
		return fourFunc(*u.four)
	}
}

func (u *Union) OneNoopSuccess(_ api.Struct1) error {
	return nil
}

func (u *Union) TwoNoopSuccess(_ api1.Struct2) error {
	return nil
}

func (u *Union) ThreeNoopSuccess(_ v2.ObjectInPackageEndingInVersion) error {
	return nil
}

func (u *Union) FourNoopSuccess(_ v21.DifferentPackageEndingInVersion) error {
	return nil
}

func (u *Union) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Union) Accept(v UnionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "one":
		if u.one == nil {
			return fmt.Errorf("field \"one\" is required")
		}
		return v.VisitOne(*u.one)
	case "two":
		if u.two == nil {
			return fmt.Errorf("field \"two\" is required")
		}
		return v.VisitTwo(*u.two)
	case "three":
		if u.three == nil {
			return fmt.Errorf("field \"three\" is required")
		}
		return v.VisitThree(*u.three)
	case "four":
		if u.four == nil {
			return fmt.Errorf("field \"four\" is required")
		}
		return v.VisitFour(*u.four)
	}
}

type UnionVisitor interface {
	VisitOne(v api.Struct1) error
	VisitTwo(v api1.Struct2) error
	VisitThree(v v2.ObjectInPackageEndingInVersion) error
	VisitFour(v v21.DifferentPackageEndingInVersion) error
	VisitUnknown(typeName string) error
}

func (u *Union) AcceptWithContext(ctx context.Context, v UnionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "one":
		if u.one == nil {
			return fmt.Errorf("field \"one\" is required")
		}
		return v.VisitOneWithContext(ctx, *u.one)
	case "two":
		if u.two == nil {
			return fmt.Errorf("field \"two\" is required")
		}
		return v.VisitTwoWithContext(ctx, *u.two)
	case "three":
		if u.three == nil {
			return fmt.Errorf("field \"three\" is required")
		}
		return v.VisitThreeWithContext(ctx, *u.three)
	case "four":
		if u.four == nil {
			return fmt.Errorf("field \"four\" is required")
		}
		return v.VisitFourWithContext(ctx, *u.four)
	}
}

type UnionVisitorWithContext interface {
	VisitOneWithContext(ctx context.Context, v api.Struct1) error
	VisitTwoWithContext(ctx context.Context, v api1.Struct2) error
	VisitThreeWithContext(ctx context.Context, v v2.ObjectInPackageEndingInVersion) error
	VisitFourWithContext(ctx context.Context, v v21.DifferentPackageEndingInVersion) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewUnionFromOne(v api.Struct1) Union {
	return Union{typ: "one", one: &v}
}

func NewUnionFromTwo(v api1.Struct2) Union {
	return Union{typ: "two", two: &v}
}

func NewUnionFromThree(v v2.ObjectInPackageEndingInVersion) Union {
	return Union{typ: "three", three: &v}
}

func NewUnionFromFour(v v21.DifferentPackageEndingInVersion) Union {
	return Union{typ: "four", four: &v}
}
