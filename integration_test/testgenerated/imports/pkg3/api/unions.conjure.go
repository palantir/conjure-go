// This file was generated by Conjure and should not be manually edited.

package api

import (
	"context"
	"fmt"

	"github.com/palantir/conjure-go/v6/integration_test/testgenerated/imports/pkg1/api"
	api1 "github.com/palantir/conjure-go/v6/integration_test/testgenerated/imports/pkg2/api"
	v2 "github.com/palantir/conjure-go/v6/integration_test/testgenerated/imports/pkg4/v2"
	v21 "github.com/palantir/conjure-go/v6/integration_test/testgenerated/imports/pkg5/v2"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type Union struct {
	typ   string
	one   *api.Struct1
	two   *api1.Struct2
	three *v2.ObjectInPackageEndingInVersion
	four  *v21.DifferentPackageEndingInVersion
}

type unionDeserializer struct {
	Type  string                               `json:"type"`
	One   *api.Struct1                         `json:"one"`
	Two   *api1.Struct2                        `json:"two"`
	Three *v2.ObjectInPackageEndingInVersion   `json:"three"`
	Four  *v21.DifferentPackageEndingInVersion `json:"four"`
}

func (u *unionDeserializer) toStruct() Union {
	return Union{typ: u.Type, one: u.One, two: u.Two, three: u.Three, four: u.Four}
}

func (u *Union) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %s", u.typ)
	case "one":
		if u.one == nil {
			return nil, fmt.Errorf("field one is required")
		}
		return struct {
			Type string      `json:"type"`
			One  api.Struct1 `json:"one"`
		}{Type: "one", One: *u.one}, nil
	case "two":
		if u.two == nil {
			return nil, fmt.Errorf("field two is required")
		}
		return struct {
			Type string       `json:"type"`
			Two  api1.Struct2 `json:"two"`
		}{Type: "two", Two: *u.two}, nil
	case "three":
		if u.three == nil {
			return nil, fmt.Errorf("field three is required")
		}
		return struct {
			Type  string                            `json:"type"`
			Three v2.ObjectInPackageEndingInVersion `json:"three"`
		}{Type: "three", Three: *u.three}, nil
	case "four":
		if u.four == nil {
			return nil, fmt.Errorf("field four is required")
		}
		return struct {
			Type string                              `json:"type"`
			Four v21.DifferentPackageEndingInVersion `json:"four"`
		}{Type: "four", Four: *u.four}, nil
	}
}

func (u Union) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Union) UnmarshalJSON(data []byte) error {
	var deser unionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	return nil
}

func (u Union) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Union) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Union) AcceptFuncs(oneFunc func(api.Struct1) error, twoFunc func(api1.Struct2) error, threeFunc func(v2.ObjectInPackageEndingInVersion) error, fourFunc func(v21.DifferentPackageEndingInVersion) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "one":
		if u.one == nil {
			return fmt.Errorf("field one is required")
		}
		return oneFunc(*u.one)
	case "two":
		if u.two == nil {
			return fmt.Errorf("field two is required")
		}
		return twoFunc(*u.two)
	case "three":
		if u.three == nil {
			return fmt.Errorf("field three is required")
		}
		return threeFunc(*u.three)
	case "four":
		if u.four == nil {
			return fmt.Errorf("field four is required")
		}
		return fourFunc(*u.four)
	}
}

func (u *Union) OneNoopSuccess(api.Struct1) error {
	return nil
}

func (u *Union) TwoNoopSuccess(api1.Struct2) error {
	return nil
}

func (u *Union) ThreeNoopSuccess(v2.ObjectInPackageEndingInVersion) error {
	return nil
}

func (u *Union) FourNoopSuccess(v21.DifferentPackageEndingInVersion) error {
	return nil
}

func (u *Union) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Union) Accept(v UnionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "one":
		if u.one == nil {
			return fmt.Errorf("field one is required")
		}
		return v.VisitOne(*u.one)
	case "two":
		if u.two == nil {
			return fmt.Errorf("field two is required")
		}
		return v.VisitTwo(*u.two)
	case "three":
		if u.three == nil {
			return fmt.Errorf("field three is required")
		}
		return v.VisitThree(*u.three)
	case "four":
		if u.four == nil {
			return fmt.Errorf("field four is required")
		}
		return v.VisitFour(*u.four)
	}
}

type UnionVisitor interface {
	VisitOne(v api.Struct1) error
	VisitTwo(v api1.Struct2) error
	VisitThree(v v2.ObjectInPackageEndingInVersion) error
	VisitFour(v v21.DifferentPackageEndingInVersion) error
	VisitUnknown(typeName string) error
}

func (u *Union) AcceptWithContext(ctx context.Context, v UnionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "one":
		if u.one == nil {
			return fmt.Errorf("field one is required")
		}
		return v.VisitOneWithContext(ctx, *u.one)
	case "two":
		if u.two == nil {
			return fmt.Errorf("field two is required")
		}
		return v.VisitTwoWithContext(ctx, *u.two)
	case "three":
		if u.three == nil {
			return fmt.Errorf("field three is required")
		}
		return v.VisitThreeWithContext(ctx, *u.three)
	case "four":
		if u.four == nil {
			return fmt.Errorf("field four is required")
		}
		return v.VisitFourWithContext(ctx, *u.four)
	}
}

type UnionVisitorWithContext interface {
	VisitOneWithContext(ctx context.Context, v api.Struct1) error
	VisitTwoWithContext(ctx context.Context, v api1.Struct2) error
	VisitThreeWithContext(ctx context.Context, v v2.ObjectInPackageEndingInVersion) error
	VisitFourWithContext(ctx context.Context, v v21.DifferentPackageEndingInVersion) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewUnionFromOne(v api.Struct1) Union {
	return Union{typ: "one", one: &v}
}

func NewUnionFromTwo(v api1.Struct2) Union {
	return Union{typ: "two", two: &v}
}

func NewUnionFromThree(v v2.ObjectInPackageEndingInVersion) Union {
	return Union{typ: "three", three: &v}
}

func NewUnionFromFour(v v21.DifferentPackageEndingInVersion) Union {
	return Union{typ: "four", four: &v}
}
