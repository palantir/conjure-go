// This file was generated by Conjure and should not be manually edited.

//go:build go1.18

package spec

import (
	"context"
	"fmt"
)

type AuthTypeWithT[T any] AuthType

func (u *AuthTypeWithT[T]) Accept(ctx context.Context, v AuthTypeVisitorWithT[T]) (T, error) {
	switch u.typ {
	default:
		if u.typ == "" {
			var result T
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "header":
		return v.VisitHeader(ctx, *u.header)
	case "cookie":
		return v.VisitCookie(ctx, *u.cookie)
	}
}

type AuthTypeVisitorWithT[T any] interface {
	VisitHeader(ctx context.Context, v HeaderAuthType) (T, error)
	VisitCookie(ctx context.Context, v CookieAuthType) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ParameterTypeWithT[T any] ParameterType

func (u *ParameterTypeWithT[T]) Accept(ctx context.Context, v ParameterTypeVisitorWithT[T]) (T, error) {
	switch u.typ {
	default:
		if u.typ == "" {
			var result T
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "body":
		return v.VisitBody(ctx, *u.body)
	case "header":
		return v.VisitHeader(ctx, *u.header)
	case "path":
		return v.VisitPath(ctx, *u.path)
	case "query":
		return v.VisitQuery(ctx, *u.query)
	}
}

type ParameterTypeVisitorWithT[T any] interface {
	VisitBody(ctx context.Context, v BodyParameterType) (T, error)
	VisitHeader(ctx context.Context, v HeaderParameterType) (T, error)
	VisitPath(ctx context.Context, v PathParameterType) (T, error)
	VisitQuery(ctx context.Context, v QueryParameterType) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type TypeWithT[T any] Type

func (u *TypeWithT[T]) Accept(ctx context.Context, v TypeVisitorWithT[T]) (T, error) {
	switch u.typ {
	default:
		if u.typ == "" {
			var result T
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "primitive":
		return v.VisitPrimitive(ctx, *u.primitive)
	case "optional":
		return v.VisitOptional(ctx, *u.optional)
	case "list":
		return v.VisitList(ctx, *u.list)
	case "set":
		return v.VisitSet(ctx, *u.set)
	case "map":
		return v.VisitMap(ctx, *u.map_)
	case "reference":
		return v.VisitReference(ctx, *u.reference)
	case "external":
		return v.VisitExternal(ctx, *u.external)
	}
}

type TypeVisitorWithT[T any] interface {
	VisitPrimitive(ctx context.Context, v PrimitiveType) (T, error)
	VisitOptional(ctx context.Context, v OptionalType) (T, error)
	VisitList(ctx context.Context, v ListType) (T, error)
	VisitSet(ctx context.Context, v SetType) (T, error)
	VisitMap(ctx context.Context, v MapType) (T, error)
	VisitReference(ctx context.Context, v TypeName) (T, error)
	VisitExternal(ctx context.Context, v ExternalReference) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type TypeDefinitionWithT[T any] TypeDefinition

func (u *TypeDefinitionWithT[T]) Accept(ctx context.Context, v TypeDefinitionVisitorWithT[T]) (T, error) {
	switch u.typ {
	default:
		if u.typ == "" {
			var result T
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "alias":
		return v.VisitAlias(ctx, *u.alias)
	case "enum":
		return v.VisitEnum(ctx, *u.enum)
	case "object":
		return v.VisitObject(ctx, *u.object)
	case "union":
		return v.VisitUnion(ctx, *u.union)
	}
}

type TypeDefinitionVisitorWithT[T any] interface {
	VisitAlias(ctx context.Context, v AliasDefinition) (T, error)
	VisitEnum(ctx context.Context, v EnumDefinition) (T, error)
	VisitObject(ctx context.Context, v ObjectDefinition) (T, error)
	VisitUnion(ctx context.Context, v UnionDefinition) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
