// This file was generated by Conjure and should not be manually edited.

package spec

import (
	"regexp"
	"strings"

	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	werror "github.com/palantir/witchcraft-go-error"
	wparams "github.com/palantir/witchcraft-go-params"
)

var enumValuePattern = regexp.MustCompile("^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$")

type ErrorCode string

const (
	ErrorCodePermissionDenied      ErrorCode = "PERMISSION_DENIED"
	ErrorCodeInvalidArgument       ErrorCode = "INVALID_ARGUMENT"
	ErrorCodeNotFound              ErrorCode = "NOT_FOUND"
	ErrorCodeConflict              ErrorCode = "CONFLICT"
	ErrorCodeRequestEntityTooLarge ErrorCode = "REQUEST_ENTITY_TOO_LARGE"
	ErrorCodeFailedPrecondition    ErrorCode = "FAILED_PRECONDITION"
	ErrorCodeInternal              ErrorCode = "INTERNAL"
	ErrorCodeTimeout               ErrorCode = "TIMEOUT"
	ErrorCodeCustomClient          ErrorCode = "CUSTOM_CLIENT"
	ErrorCodeCustomServer          ErrorCode = "CUSTOM_SERVER"
)

// ErrorCode_Values returns all known variants of ErrorCode.
func ErrorCode_Values() []ErrorCode {
	return []ErrorCode{ErrorCodePermissionDenied, ErrorCodeInvalidArgument, ErrorCodeNotFound, ErrorCodeConflict, ErrorCodeRequestEntityTooLarge, ErrorCodeFailedPrecondition, ErrorCodeInternal, ErrorCodeTimeout, ErrorCodeCustomClient, ErrorCodeCustomServer}
}

// IsUnknown returns false for all known variants of ErrorCode and true otherwise.
func (e ErrorCode) IsUnknown() bool {
	switch e {
	case ErrorCodePermissionDenied, ErrorCodeInvalidArgument, ErrorCodeNotFound, ErrorCodeConflict, ErrorCodeRequestEntityTooLarge, ErrorCodeFailedPrecondition, ErrorCodeInternal, ErrorCodeTimeout, ErrorCodeCustomClient, ErrorCodeCustomServer:
		return false
	}
	return true
}

func (e *ErrorCode) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		if !enumValuePattern.MatchString(v) {
			return werror.Convert(errors.NewInvalidArgument(wparams.NewSafeAndUnsafeParamStorer(map[string]interface{}{"enumType": "ErrorCode", "message": "enum value must match pattern ^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$"}, map[string]interface{}{"enumValue": string(data)})))
		}
		*e = ErrorCode(v)
	case "PERMISSION_DENIED":
		*e = ErrorCodePermissionDenied
	case "INVALID_ARGUMENT":
		*e = ErrorCodeInvalidArgument
	case "NOT_FOUND":
		*e = ErrorCodeNotFound
	case "CONFLICT":
		*e = ErrorCodeConflict
	case "REQUEST_ENTITY_TOO_LARGE":
		*e = ErrorCodeRequestEntityTooLarge
	case "FAILED_PRECONDITION":
		*e = ErrorCodeFailedPrecondition
	case "INTERNAL":
		*e = ErrorCodeInternal
	case "TIMEOUT":
		*e = ErrorCodeTimeout
	case "CUSTOM_CLIENT":
		*e = ErrorCodeCustomClient
	case "CUSTOM_SERVER":
		*e = ErrorCodeCustomServer
	}
	return nil
}

type HttpMethod string

const (
	HttpMethodGet    HttpMethod = "GET"
	HttpMethodPost   HttpMethod = "POST"
	HttpMethodPut    HttpMethod = "PUT"
	HttpMethodDelete HttpMethod = "DELETE"
)

// HttpMethod_Values returns all known variants of HttpMethod.
func HttpMethod_Values() []HttpMethod {
	return []HttpMethod{HttpMethodGet, HttpMethodPost, HttpMethodPut, HttpMethodDelete}
}

// IsUnknown returns false for all known variants of HttpMethod and true otherwise.
func (e HttpMethod) IsUnknown() bool {
	switch e {
	case HttpMethodGet, HttpMethodPost, HttpMethodPut, HttpMethodDelete:
		return false
	}
	return true
}

func (e *HttpMethod) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		if !enumValuePattern.MatchString(v) {
			return werror.Convert(errors.NewInvalidArgument(wparams.NewSafeAndUnsafeParamStorer(map[string]interface{}{"enumType": "HttpMethod", "message": "enum value must match pattern ^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$"}, map[string]interface{}{"enumValue": string(data)})))
		}
		*e = HttpMethod(v)
	case "GET":
		*e = HttpMethodGet
	case "POST":
		*e = HttpMethodPost
	case "PUT":
		*e = HttpMethodPut
	case "DELETE":
		*e = HttpMethodDelete
	}
	return nil
}

type PrimitiveType string

const (
	PrimitiveTypeString      PrimitiveType = "STRING"
	PrimitiveTypeDatetime    PrimitiveType = "DATETIME"
	PrimitiveTypeInteger     PrimitiveType = "INTEGER"
	PrimitiveTypeDouble      PrimitiveType = "DOUBLE"
	PrimitiveTypeSafelong    PrimitiveType = "SAFELONG"
	PrimitiveTypeBinary      PrimitiveType = "BINARY"
	PrimitiveTypeAny         PrimitiveType = "ANY"
	PrimitiveTypeBoolean     PrimitiveType = "BOOLEAN"
	PrimitiveTypeUuid        PrimitiveType = "UUID"
	PrimitiveTypeRid         PrimitiveType = "RID"
	PrimitiveTypeBearertoken PrimitiveType = "BEARERTOKEN"
)

// PrimitiveType_Values returns all known variants of PrimitiveType.
func PrimitiveType_Values() []PrimitiveType {
	return []PrimitiveType{PrimitiveTypeString, PrimitiveTypeDatetime, PrimitiveTypeInteger, PrimitiveTypeDouble, PrimitiveTypeSafelong, PrimitiveTypeBinary, PrimitiveTypeAny, PrimitiveTypeBoolean, PrimitiveTypeUuid, PrimitiveTypeRid, PrimitiveTypeBearertoken}
}

// IsUnknown returns false for all known variants of PrimitiveType and true otherwise.
func (e PrimitiveType) IsUnknown() bool {
	switch e {
	case PrimitiveTypeString, PrimitiveTypeDatetime, PrimitiveTypeInteger, PrimitiveTypeDouble, PrimitiveTypeSafelong, PrimitiveTypeBinary, PrimitiveTypeAny, PrimitiveTypeBoolean, PrimitiveTypeUuid, PrimitiveTypeRid, PrimitiveTypeBearertoken:
		return false
	}
	return true
}

func (e *PrimitiveType) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		if !enumValuePattern.MatchString(v) {
			return werror.Convert(errors.NewInvalidArgument(wparams.NewSafeAndUnsafeParamStorer(map[string]interface{}{"enumType": "PrimitiveType", "message": "enum value must match pattern ^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$"}, map[string]interface{}{"enumValue": string(data)})))
		}
		*e = PrimitiveType(v)
	case "STRING":
		*e = PrimitiveTypeString
	case "DATETIME":
		*e = PrimitiveTypeDatetime
	case "INTEGER":
		*e = PrimitiveTypeInteger
	case "DOUBLE":
		*e = PrimitiveTypeDouble
	case "SAFELONG":
		*e = PrimitiveTypeSafelong
	case "BINARY":
		*e = PrimitiveTypeBinary
	case "ANY":
		*e = PrimitiveTypeAny
	case "BOOLEAN":
		*e = PrimitiveTypeBoolean
	case "UUID":
		*e = PrimitiveTypeUuid
	case "RID":
		*e = PrimitiveTypeRid
	case "BEARERTOKEN":
		*e = PrimitiveTypeBearertoken
	}
	return nil
}
