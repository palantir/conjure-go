// This file was generated by Conjure and should not be manually edited.

package spec

import (
	"regexp"
	"strings"

	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	werror "github.com/palantir/witchcraft-go-error"
	wparams "github.com/palantir/witchcraft-go-params"
)

var enumValuePattern = regexp.MustCompile("^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$")

type ErrorCode struct {
	val ErrorCode_Value
}

type ErrorCode_Value string

const (
	ErrorCode_PermissionDenied      ErrorCode_Value = "PERMISSION_DENIED"
	ErrorCode_InvalidArgument       ErrorCode_Value = "INVALID_ARGUMENT"
	ErrorCode_NotFound              ErrorCode_Value = "NOT_FOUND"
	ErrorCode_Conflict              ErrorCode_Value = "CONFLICT"
	ErrorCode_RequestEntityTooLarge ErrorCode_Value = "REQUEST_ENTITY_TOO_LARGE"
	ErrorCode_FailedPrecondition    ErrorCode_Value = "FAILED_PRECONDITION"
	ErrorCode_Internal              ErrorCode_Value = "INTERNAL"
	ErrorCode_Timeout               ErrorCode_Value = "TIMEOUT"
	ErrorCode_CustomClient          ErrorCode_Value = "CUSTOM_CLIENT"
	ErrorCode_CustomServer          ErrorCode_Value = "CUSTOM_SERVER"
	ErrorCode_Unknown               ErrorCode_Value = "UNKNOWN"
)

// ErrorCode_Values returns all known variants of ErrorCode.
func ErrorCode_Values() []ErrorCode_Value {
	return []ErrorCode_Value{ErrorCode_PermissionDenied, ErrorCode_InvalidArgument, ErrorCode_NotFound, ErrorCode_Conflict, ErrorCode_RequestEntityTooLarge, ErrorCode_FailedPrecondition, ErrorCode_Internal, ErrorCode_Timeout, ErrorCode_CustomClient, ErrorCode_CustomServer}
}

func New_ErrorCode(value ErrorCode_Value) ErrorCode {
	return ErrorCode{val: value}
}

// IsUnknown returns false for all known variants of ErrorCode and true otherwise.
func (e ErrorCode) IsUnknown() bool {
	switch e.val {
	case ErrorCode_PermissionDenied, ErrorCode_InvalidArgument, ErrorCode_NotFound, ErrorCode_Conflict, ErrorCode_RequestEntityTooLarge, ErrorCode_FailedPrecondition, ErrorCode_Internal, ErrorCode_Timeout, ErrorCode_CustomClient, ErrorCode_CustomServer:
		return false
	}
	return true
}

func (e ErrorCode) Value() ErrorCode_Value {
	if e.IsUnknown() {
		return ErrorCode_Unknown
	}
	return e.val
}

func (e ErrorCode) String() string {
	return string(e.val)
}

func (e ErrorCode) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *ErrorCode) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		if !enumValuePattern.MatchString(v) {
			return werror.Convert(errors.NewInvalidArgument(wparams.NewSafeAndUnsafeParamStorer(map[string]interface{}{"enumType": "ErrorCode", "message": "enum value must match pattern ^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$"}, map[string]interface{}{"enumValue": string(data)})))
		}
		*e = New_ErrorCode(ErrorCode_Value(v))
	case "PERMISSION_DENIED":
		*e = New_ErrorCode(ErrorCode_PermissionDenied)
	case "INVALID_ARGUMENT":
		*e = New_ErrorCode(ErrorCode_InvalidArgument)
	case "NOT_FOUND":
		*e = New_ErrorCode(ErrorCode_NotFound)
	case "CONFLICT":
		*e = New_ErrorCode(ErrorCode_Conflict)
	case "REQUEST_ENTITY_TOO_LARGE":
		*e = New_ErrorCode(ErrorCode_RequestEntityTooLarge)
	case "FAILED_PRECONDITION":
		*e = New_ErrorCode(ErrorCode_FailedPrecondition)
	case "INTERNAL":
		*e = New_ErrorCode(ErrorCode_Internal)
	case "TIMEOUT":
		*e = New_ErrorCode(ErrorCode_Timeout)
	case "CUSTOM_CLIENT":
		*e = New_ErrorCode(ErrorCode_CustomClient)
	case "CUSTOM_SERVER":
		*e = New_ErrorCode(ErrorCode_CustomServer)
	}
	return nil
}

type HttpMethod struct {
	val HttpMethod_Value
}

type HttpMethod_Value string

const (
	HttpMethod_Get     HttpMethod_Value = "GET"
	HttpMethod_Post    HttpMethod_Value = "POST"
	HttpMethod_Put     HttpMethod_Value = "PUT"
	HttpMethod_Delete  HttpMethod_Value = "DELETE"
	HttpMethod_Unknown HttpMethod_Value = "UNKNOWN"
)

// HttpMethod_Values returns all known variants of HttpMethod.
func HttpMethod_Values() []HttpMethod_Value {
	return []HttpMethod_Value{HttpMethod_Get, HttpMethod_Post, HttpMethod_Put, HttpMethod_Delete}
}

func New_HttpMethod(value HttpMethod_Value) HttpMethod {
	return HttpMethod{val: value}
}

// IsUnknown returns false for all known variants of HttpMethod and true otherwise.
func (e HttpMethod) IsUnknown() bool {
	switch e.val {
	case HttpMethod_Get, HttpMethod_Post, HttpMethod_Put, HttpMethod_Delete:
		return false
	}
	return true
}

func (e HttpMethod) Value() HttpMethod_Value {
	if e.IsUnknown() {
		return HttpMethod_Unknown
	}
	return e.val
}

func (e HttpMethod) String() string {
	return string(e.val)
}

func (e HttpMethod) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *HttpMethod) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		if !enumValuePattern.MatchString(v) {
			return werror.Convert(errors.NewInvalidArgument(wparams.NewSafeAndUnsafeParamStorer(map[string]interface{}{"enumType": "HttpMethod", "message": "enum value must match pattern ^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$"}, map[string]interface{}{"enumValue": string(data)})))
		}
		*e = New_HttpMethod(HttpMethod_Value(v))
	case "GET":
		*e = New_HttpMethod(HttpMethod_Get)
	case "POST":
		*e = New_HttpMethod(HttpMethod_Post)
	case "PUT":
		*e = New_HttpMethod(HttpMethod_Put)
	case "DELETE":
		*e = New_HttpMethod(HttpMethod_Delete)
	}
	return nil
}

type PrimitiveType struct {
	val PrimitiveType_Value
}

type PrimitiveType_Value string

const (
	PrimitiveType_String      PrimitiveType_Value = "STRING"
	PrimitiveType_Datetime    PrimitiveType_Value = "DATETIME"
	PrimitiveType_Integer     PrimitiveType_Value = "INTEGER"
	PrimitiveType_Double      PrimitiveType_Value = "DOUBLE"
	PrimitiveType_Safelong    PrimitiveType_Value = "SAFELONG"
	PrimitiveType_Binary      PrimitiveType_Value = "BINARY"
	PrimitiveType_Any         PrimitiveType_Value = "ANY"
	PrimitiveType_Boolean     PrimitiveType_Value = "BOOLEAN"
	PrimitiveType_Uuid        PrimitiveType_Value = "UUID"
	PrimitiveType_Rid         PrimitiveType_Value = "RID"
	PrimitiveType_Bearertoken PrimitiveType_Value = "BEARERTOKEN"
	PrimitiveType_Unknown     PrimitiveType_Value = "UNKNOWN"
)

// PrimitiveType_Values returns all known variants of PrimitiveType.
func PrimitiveType_Values() []PrimitiveType_Value {
	return []PrimitiveType_Value{PrimitiveType_String, PrimitiveType_Datetime, PrimitiveType_Integer, PrimitiveType_Double, PrimitiveType_Safelong, PrimitiveType_Binary, PrimitiveType_Any, PrimitiveType_Boolean, PrimitiveType_Uuid, PrimitiveType_Rid, PrimitiveType_Bearertoken}
}

func New_PrimitiveType(value PrimitiveType_Value) PrimitiveType {
	return PrimitiveType{val: value}
}

// IsUnknown returns false for all known variants of PrimitiveType and true otherwise.
func (e PrimitiveType) IsUnknown() bool {
	switch e.val {
	case PrimitiveType_String, PrimitiveType_Datetime, PrimitiveType_Integer, PrimitiveType_Double, PrimitiveType_Safelong, PrimitiveType_Binary, PrimitiveType_Any, PrimitiveType_Boolean, PrimitiveType_Uuid, PrimitiveType_Rid, PrimitiveType_Bearertoken:
		return false
	}
	return true
}

func (e PrimitiveType) Value() PrimitiveType_Value {
	if e.IsUnknown() {
		return PrimitiveType_Unknown
	}
	return e.val
}

func (e PrimitiveType) String() string {
	return string(e.val)
}

func (e PrimitiveType) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *PrimitiveType) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		if !enumValuePattern.MatchString(v) {
			return werror.Convert(errors.NewInvalidArgument(wparams.NewSafeAndUnsafeParamStorer(map[string]interface{}{"enumType": "PrimitiveType", "message": "enum value must match pattern ^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$"}, map[string]interface{}{"enumValue": string(data)})))
		}
		*e = New_PrimitiveType(PrimitiveType_Value(v))
	case "STRING":
		*e = New_PrimitiveType(PrimitiveType_String)
	case "DATETIME":
		*e = New_PrimitiveType(PrimitiveType_Datetime)
	case "INTEGER":
		*e = New_PrimitiveType(PrimitiveType_Integer)
	case "DOUBLE":
		*e = New_PrimitiveType(PrimitiveType_Double)
	case "SAFELONG":
		*e = New_PrimitiveType(PrimitiveType_Safelong)
	case "BINARY":
		*e = New_PrimitiveType(PrimitiveType_Binary)
	case "ANY":
		*e = New_PrimitiveType(PrimitiveType_Any)
	case "BOOLEAN":
		*e = New_PrimitiveType(PrimitiveType_Boolean)
	case "UUID":
		*e = New_PrimitiveType(PrimitiveType_Uuid)
	case "RID":
		*e = New_PrimitiveType(PrimitiveType_Rid)
	case "BEARERTOKEN":
		*e = New_PrimitiveType(PrimitiveType_Bearertoken)
	}
	return nil
}
