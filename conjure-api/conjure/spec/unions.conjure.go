// This file was generated by Conjure and should not be manually edited.

package spec

import (
	"context"
	"fmt"
	"io"

	dj "github.com/palantir/conjure-go/v6/dj"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	werror "github.com/palantir/witchcraft-go-error"
)

type AuthType struct {
	typ    string
	header *HeaderAuthType
	cookie *CookieAuthType
}

func (u AuthType) MarshalJSON() ([]byte, error) {
	out := make([]byte, 0)
	if _, err := u.WriteJSON(dj.NewAppender(&out)); err != nil {
		return nil, err
	}
	return out, dj.Valid(out)
}

func (u AuthType) WriteJSON(w io.Writer) (int, error) {
	var out int
	if n, err := dj.WriteOpenObject(w); err != nil {
		return 0, err
	} else {
		out += n
	}
	switch u.typ {
	case "header":
		if n, err := dj.WriteLiteral(w, "\"type\":\"header\""); err != nil {
			return 0, err
		} else {
			out += n
		}
		if u.header != nil {
			if n, err := dj.WriteLiteral(w, ",\"header\":"); err != nil {
				return 0, err
			} else {
				out += n
			}
			unionVal := *u.header
			if n, err := unionVal.WriteJSON(w); err != nil {
				return 0, err
			} else {
				out += n
			}
		}
	case "cookie":
		if n, err := dj.WriteLiteral(w, "\"type\":\"cookie\""); err != nil {
			return 0, err
		} else {
			out += n
		}
		if u.cookie != nil {
			if n, err := dj.WriteLiteral(w, ",\"cookie\":"); err != nil {
				return 0, err
			} else {
				out += n
			}
			unionVal := *u.cookie
			if n, err := unionVal.WriteJSON(w); err != nil {
				return 0, err
			} else {
				out += n
			}
		}
	default:
		if n, err := dj.WriteLiteral(w, "\"type\":"); err != nil {
			return 0, err
		} else {
			out += n
		}
		if n, err := dj.WriteString(w, (u.typ)); err != nil {
			return 0, err
		} else {
			out += n
		}
	}
	if n, err := dj.WriteCloseObject(w); err != nil {
		return 0, err
	} else {
		out += n
	}
	return out, nil
}

func (u *AuthType) UnmarshalJSON(data []byte) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return u.UnmarshalJSONResult(value, false)
}

func (u *AuthType) UnmarshalJSONStrict(data []byte) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return u.UnmarshalJSONResult(value, true)
}

func (u *AuthType) UnmarshalJSONString(data string) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return u.UnmarshalJSONResult(value, false)
}

func (u *AuthType) UnmarshalJSONStringStrict(data string) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return u.UnmarshalJSONResult(value, true)
}

func (u *AuthType) UnmarshalJSONResult(value dj.Result, disallowUnknownFields bool) error {
	var seenType bool
	var seenHeader bool
	var seenCookie bool
	var unknownFields []string
	iter, idx, err := value.ObjectIterator(0)
	if err != nil {
		return err
	}
	for iter.HasNext(value, idx) {
		var fieldKey, fieldValue dj.Result
		fieldKey, fieldValue, idx, err = iter.Next(value, idx)
		if err != nil {
			return err
		}
		switch fieldKey.Str {
		case "type":
			if seenType {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "AuthType", Field: "type"}
			}
			seenType = true
			u.typ, err = fieldValue.String()
			if err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "AuthType", Field: "type", Err: err})
			}
		case "header":
			if seenHeader {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "AuthType", Field: "header"}
			}
			seenHeader = true
			var unionVal HeaderAuthType
			if err := unionVal.UnmarshalJSONResult(fieldValue, disallowUnknownFields); err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "AuthType", Field: "header", Err: err})
			}
			u.header = &unionVal
		case "cookie":
			if seenCookie {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "AuthType", Field: "cookie"}
			}
			seenCookie = true
			var unionVal CookieAuthType
			if err := unionVal.UnmarshalJSONResult(fieldValue, disallowUnknownFields); err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "AuthType", Field: "cookie", Err: err})
			}
			u.cookie = &unionVal
		default:
			if disallowUnknownFields {
				unknownFields = append(unknownFields, fieldKey.Str)
			}
		}
	}
	var missingFields []string
	if !seenType {
		missingFields = append(missingFields, "type")
	}
	if u.typ == "header" && !seenHeader {
		missingFields = append(missingFields, "header")
	}
	if u.typ == "cookie" && !seenCookie {
		missingFields = append(missingFields, "cookie")
	}
	if len(missingFields) > 0 {
		return werror.Convert(dj.UnmarshalMissingFieldsError{Index: value.Index, Type: "AuthType", Fields: missingFields})
	}
	if disallowUnknownFields && len(unknownFields) > 0 {
		return werror.Convert(dj.UnmarshalUnknownFieldsError{Index: value.Index, Type: "AuthType", Fields: unknownFields})
	}
	return nil
}

func (u AuthType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *AuthType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *AuthType) AcceptFuncs(headerFunc func(HeaderAuthType) error, cookieFunc func(CookieAuthType) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "header":
		if u.header == nil {
			return fmt.Errorf("field \"header\" is required")
		}
		return headerFunc(*u.header)
	case "cookie":
		if u.cookie == nil {
			return fmt.Errorf("field \"cookie\" is required")
		}
		return cookieFunc(*u.cookie)
	}
}

func (u *AuthType) HeaderNoopSuccess(_ HeaderAuthType) error {
	return nil
}

func (u *AuthType) CookieNoopSuccess(_ CookieAuthType) error {
	return nil
}

func (u *AuthType) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *AuthType) Accept(v AuthTypeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "header":
		if u.header == nil {
			return fmt.Errorf("field \"header\" is required")
		}
		return v.VisitHeader(*u.header)
	case "cookie":
		if u.cookie == nil {
			return fmt.Errorf("field \"cookie\" is required")
		}
		return v.VisitCookie(*u.cookie)
	}
}

type AuthTypeVisitor interface {
	VisitHeader(v HeaderAuthType) error
	VisitCookie(v CookieAuthType) error
	VisitUnknown(typeName string) error
}

func (u *AuthType) AcceptWithContext(ctx context.Context, v AuthTypeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "header":
		if u.header == nil {
			return fmt.Errorf("field \"header\" is required")
		}
		return v.VisitHeaderWithContext(ctx, *u.header)
	case "cookie":
		if u.cookie == nil {
			return fmt.Errorf("field \"cookie\" is required")
		}
		return v.VisitCookieWithContext(ctx, *u.cookie)
	}
}

type AuthTypeVisitorWithContext interface {
	VisitHeaderWithContext(ctx context.Context, v HeaderAuthType) error
	VisitCookieWithContext(ctx context.Context, v CookieAuthType) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewAuthTypeFromHeader(v HeaderAuthType) AuthType {
	return AuthType{typ: "header", header: &v}
}

func NewAuthTypeFromCookie(v CookieAuthType) AuthType {
	return AuthType{typ: "cookie", cookie: &v}
}

type ParameterType struct {
	typ    string
	body   *BodyParameterType
	header *HeaderParameterType
	path   *PathParameterType
	query  *QueryParameterType
}

func (u ParameterType) MarshalJSON() ([]byte, error) {
	out := make([]byte, 0)
	if _, err := u.WriteJSON(dj.NewAppender(&out)); err != nil {
		return nil, err
	}
	return out, dj.Valid(out)
}

func (u ParameterType) WriteJSON(w io.Writer) (int, error) {
	var out int
	if n, err := dj.WriteOpenObject(w); err != nil {
		return 0, err
	} else {
		out += n
	}
	switch u.typ {
	case "body":
		if n, err := dj.WriteLiteral(w, "\"type\":\"body\""); err != nil {
			return 0, err
		} else {
			out += n
		}
		if u.body != nil {
			if n, err := dj.WriteLiteral(w, ",\"body\":"); err != nil {
				return 0, err
			} else {
				out += n
			}
			unionVal := *u.body
			if n, err := unionVal.WriteJSON(w); err != nil {
				return 0, err
			} else {
				out += n
			}
		}
	case "header":
		if n, err := dj.WriteLiteral(w, "\"type\":\"header\""); err != nil {
			return 0, err
		} else {
			out += n
		}
		if u.header != nil {
			if n, err := dj.WriteLiteral(w, ",\"header\":"); err != nil {
				return 0, err
			} else {
				out += n
			}
			unionVal := *u.header
			if n, err := unionVal.WriteJSON(w); err != nil {
				return 0, err
			} else {
				out += n
			}
		}
	case "path":
		if n, err := dj.WriteLiteral(w, "\"type\":\"path\""); err != nil {
			return 0, err
		} else {
			out += n
		}
		if u.path != nil {
			if n, err := dj.WriteLiteral(w, ",\"path\":"); err != nil {
				return 0, err
			} else {
				out += n
			}
			unionVal := *u.path
			if n, err := unionVal.WriteJSON(w); err != nil {
				return 0, err
			} else {
				out += n
			}
		}
	case "query":
		if n, err := dj.WriteLiteral(w, "\"type\":\"query\""); err != nil {
			return 0, err
		} else {
			out += n
		}
		if u.query != nil {
			if n, err := dj.WriteLiteral(w, ",\"query\":"); err != nil {
				return 0, err
			} else {
				out += n
			}
			unionVal := *u.query
			if n, err := unionVal.WriteJSON(w); err != nil {
				return 0, err
			} else {
				out += n
			}
		}
	default:
		if n, err := dj.WriteLiteral(w, "\"type\":"); err != nil {
			return 0, err
		} else {
			out += n
		}
		if n, err := dj.WriteString(w, (u.typ)); err != nil {
			return 0, err
		} else {
			out += n
		}
	}
	if n, err := dj.WriteCloseObject(w); err != nil {
		return 0, err
	} else {
		out += n
	}
	return out, nil
}

func (u *ParameterType) UnmarshalJSON(data []byte) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return u.UnmarshalJSONResult(value, false)
}

func (u *ParameterType) UnmarshalJSONStrict(data []byte) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return u.UnmarshalJSONResult(value, true)
}

func (u *ParameterType) UnmarshalJSONString(data string) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return u.UnmarshalJSONResult(value, false)
}

func (u *ParameterType) UnmarshalJSONStringStrict(data string) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return u.UnmarshalJSONResult(value, true)
}

func (u *ParameterType) UnmarshalJSONResult(value dj.Result, disallowUnknownFields bool) error {
	var seenType bool
	var seenBody bool
	var seenHeader bool
	var seenPath bool
	var seenQuery bool
	var unknownFields []string
	iter, idx, err := value.ObjectIterator(0)
	if err != nil {
		return err
	}
	for iter.HasNext(value, idx) {
		var fieldKey, fieldValue dj.Result
		fieldKey, fieldValue, idx, err = iter.Next(value, idx)
		if err != nil {
			return err
		}
		switch fieldKey.Str {
		case "type":
			if seenType {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "ParameterType", Field: "type"}
			}
			seenType = true
			u.typ, err = fieldValue.String()
			if err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "ParameterType", Field: "type", Err: err})
			}
		case "body":
			if seenBody {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "ParameterType", Field: "body"}
			}
			seenBody = true
			var unionVal BodyParameterType
			if err := unionVal.UnmarshalJSONResult(fieldValue, disallowUnknownFields); err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "ParameterType", Field: "body", Err: err})
			}
			u.body = &unionVal
		case "header":
			if seenHeader {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "ParameterType", Field: "header"}
			}
			seenHeader = true
			var unionVal HeaderParameterType
			if err := unionVal.UnmarshalJSONResult(fieldValue, disallowUnknownFields); err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "ParameterType", Field: "header", Err: err})
			}
			u.header = &unionVal
		case "path":
			if seenPath {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "ParameterType", Field: "path"}
			}
			seenPath = true
			var unionVal PathParameterType
			if err := unionVal.UnmarshalJSONResult(fieldValue, disallowUnknownFields); err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "ParameterType", Field: "path", Err: err})
			}
			u.path = &unionVal
		case "query":
			if seenQuery {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "ParameterType", Field: "query"}
			}
			seenQuery = true
			var unionVal QueryParameterType
			if err := unionVal.UnmarshalJSONResult(fieldValue, disallowUnknownFields); err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "ParameterType", Field: "query", Err: err})
			}
			u.query = &unionVal
		default:
			if disallowUnknownFields {
				unknownFields = append(unknownFields, fieldKey.Str)
			}
		}
	}
	var missingFields []string
	if !seenType {
		missingFields = append(missingFields, "type")
	}
	if u.typ == "body" && !seenBody {
		missingFields = append(missingFields, "body")
	}
	if u.typ == "header" && !seenHeader {
		missingFields = append(missingFields, "header")
	}
	if u.typ == "path" && !seenPath {
		missingFields = append(missingFields, "path")
	}
	if u.typ == "query" && !seenQuery {
		missingFields = append(missingFields, "query")
	}
	if len(missingFields) > 0 {
		return werror.Convert(dj.UnmarshalMissingFieldsError{Index: value.Index, Type: "ParameterType", Fields: missingFields})
	}
	if disallowUnknownFields && len(unknownFields) > 0 {
		return werror.Convert(dj.UnmarshalUnknownFieldsError{Index: value.Index, Type: "ParameterType", Fields: unknownFields})
	}
	return nil
}

func (u ParameterType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ParameterType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ParameterType) AcceptFuncs(bodyFunc func(BodyParameterType) error, headerFunc func(HeaderParameterType) error, pathFunc func(PathParameterType) error, queryFunc func(QueryParameterType) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "body":
		if u.body == nil {
			return fmt.Errorf("field \"body\" is required")
		}
		return bodyFunc(*u.body)
	case "header":
		if u.header == nil {
			return fmt.Errorf("field \"header\" is required")
		}
		return headerFunc(*u.header)
	case "path":
		if u.path == nil {
			return fmt.Errorf("field \"path\" is required")
		}
		return pathFunc(*u.path)
	case "query":
		if u.query == nil {
			return fmt.Errorf("field \"query\" is required")
		}
		return queryFunc(*u.query)
	}
}

func (u *ParameterType) BodyNoopSuccess(_ BodyParameterType) error {
	return nil
}

func (u *ParameterType) HeaderNoopSuccess(_ HeaderParameterType) error {
	return nil
}

func (u *ParameterType) PathNoopSuccess(_ PathParameterType) error {
	return nil
}

func (u *ParameterType) QueryNoopSuccess(_ QueryParameterType) error {
	return nil
}

func (u *ParameterType) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ParameterType) Accept(v ParameterTypeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "body":
		if u.body == nil {
			return fmt.Errorf("field \"body\" is required")
		}
		return v.VisitBody(*u.body)
	case "header":
		if u.header == nil {
			return fmt.Errorf("field \"header\" is required")
		}
		return v.VisitHeader(*u.header)
	case "path":
		if u.path == nil {
			return fmt.Errorf("field \"path\" is required")
		}
		return v.VisitPath(*u.path)
	case "query":
		if u.query == nil {
			return fmt.Errorf("field \"query\" is required")
		}
		return v.VisitQuery(*u.query)
	}
}

type ParameterTypeVisitor interface {
	VisitBody(v BodyParameterType) error
	VisitHeader(v HeaderParameterType) error
	VisitPath(v PathParameterType) error
	VisitQuery(v QueryParameterType) error
	VisitUnknown(typeName string) error
}

func (u *ParameterType) AcceptWithContext(ctx context.Context, v ParameterTypeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "body":
		if u.body == nil {
			return fmt.Errorf("field \"body\" is required")
		}
		return v.VisitBodyWithContext(ctx, *u.body)
	case "header":
		if u.header == nil {
			return fmt.Errorf("field \"header\" is required")
		}
		return v.VisitHeaderWithContext(ctx, *u.header)
	case "path":
		if u.path == nil {
			return fmt.Errorf("field \"path\" is required")
		}
		return v.VisitPathWithContext(ctx, *u.path)
	case "query":
		if u.query == nil {
			return fmt.Errorf("field \"query\" is required")
		}
		return v.VisitQueryWithContext(ctx, *u.query)
	}
}

type ParameterTypeVisitorWithContext interface {
	VisitBodyWithContext(ctx context.Context, v BodyParameterType) error
	VisitHeaderWithContext(ctx context.Context, v HeaderParameterType) error
	VisitPathWithContext(ctx context.Context, v PathParameterType) error
	VisitQueryWithContext(ctx context.Context, v QueryParameterType) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewParameterTypeFromBody(v BodyParameterType) ParameterType {
	return ParameterType{typ: "body", body: &v}
}

func NewParameterTypeFromHeader(v HeaderParameterType) ParameterType {
	return ParameterType{typ: "header", header: &v}
}

func NewParameterTypeFromPath(v PathParameterType) ParameterType {
	return ParameterType{typ: "path", path: &v}
}

func NewParameterTypeFromQuery(v QueryParameterType) ParameterType {
	return ParameterType{typ: "query", query: &v}
}

type Type struct {
	typ       string
	primitive *PrimitiveType
	optional  *OptionalType
	list      *ListType
	set       *SetType
	map_      *MapType
	reference *TypeName
	external  *ExternalReference
}

func (u Type) MarshalJSON() ([]byte, error) {
	out := make([]byte, 0)
	if _, err := u.WriteJSON(dj.NewAppender(&out)); err != nil {
		return nil, err
	}
	return out, dj.Valid(out)
}

func (u Type) WriteJSON(w io.Writer) (int, error) {
	var out int
	if n, err := dj.WriteOpenObject(w); err != nil {
		return 0, err
	} else {
		out += n
	}
	switch u.typ {
	case "primitive":
		if n, err := dj.WriteLiteral(w, "\"type\":\"primitive\""); err != nil {
			return 0, err
		} else {
			out += n
		}
		if u.primitive != nil {
			if n, err := dj.WriteLiteral(w, ",\"primitive\":"); err != nil {
				return 0, err
			} else {
				out += n
			}
			unionVal := *u.primitive
			if n, err := dj.WriteString(w, unionVal.String()); err != nil {
				return 0, err
			} else {
				out += n
			}
		}
	case "optional":
		if n, err := dj.WriteLiteral(w, "\"type\":\"optional\""); err != nil {
			return 0, err
		} else {
			out += n
		}
		if u.optional != nil {
			if n, err := dj.WriteLiteral(w, ",\"optional\":"); err != nil {
				return 0, err
			} else {
				out += n
			}
			unionVal := *u.optional
			if n, err := unionVal.WriteJSON(w); err != nil {
				return 0, err
			} else {
				out += n
			}
		}
	case "list":
		if n, err := dj.WriteLiteral(w, "\"type\":\"list\""); err != nil {
			return 0, err
		} else {
			out += n
		}
		if u.list != nil {
			if n, err := dj.WriteLiteral(w, ",\"list\":"); err != nil {
				return 0, err
			} else {
				out += n
			}
			unionVal := *u.list
			if n, err := unionVal.WriteJSON(w); err != nil {
				return 0, err
			} else {
				out += n
			}
		}
	case "set":
		if n, err := dj.WriteLiteral(w, "\"type\":\"set\""); err != nil {
			return 0, err
		} else {
			out += n
		}
		if u.set != nil {
			if n, err := dj.WriteLiteral(w, ",\"set\":"); err != nil {
				return 0, err
			} else {
				out += n
			}
			unionVal := *u.set
			if n, err := unionVal.WriteJSON(w); err != nil {
				return 0, err
			} else {
				out += n
			}
		}
	case "map":
		if n, err := dj.WriteLiteral(w, "\"type\":\"map\""); err != nil {
			return 0, err
		} else {
			out += n
		}
		if u.map_ != nil {
			if n, err := dj.WriteLiteral(w, ",\"map\":"); err != nil {
				return 0, err
			} else {
				out += n
			}
			unionVal := *u.map_
			if n, err := unionVal.WriteJSON(w); err != nil {
				return 0, err
			} else {
				out += n
			}
		}
	case "reference":
		if n, err := dj.WriteLiteral(w, "\"type\":\"reference\""); err != nil {
			return 0, err
		} else {
			out += n
		}
		if u.reference != nil {
			if n, err := dj.WriteLiteral(w, ",\"reference\":"); err != nil {
				return 0, err
			} else {
				out += n
			}
			unionVal := *u.reference
			if n, err := unionVal.WriteJSON(w); err != nil {
				return 0, err
			} else {
				out += n
			}
		}
	case "external":
		if n, err := dj.WriteLiteral(w, "\"type\":\"external\""); err != nil {
			return 0, err
		} else {
			out += n
		}
		if u.external != nil {
			if n, err := dj.WriteLiteral(w, ",\"external\":"); err != nil {
				return 0, err
			} else {
				out += n
			}
			unionVal := *u.external
			if n, err := unionVal.WriteJSON(w); err != nil {
				return 0, err
			} else {
				out += n
			}
		}
	default:
		if n, err := dj.WriteLiteral(w, "\"type\":"); err != nil {
			return 0, err
		} else {
			out += n
		}
		if n, err := dj.WriteString(w, (u.typ)); err != nil {
			return 0, err
		} else {
			out += n
		}
	}
	if n, err := dj.WriteCloseObject(w); err != nil {
		return 0, err
	} else {
		out += n
	}
	return out, nil
}

func (u *Type) UnmarshalJSON(data []byte) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return u.UnmarshalJSONResult(value, false)
}

func (u *Type) UnmarshalJSONStrict(data []byte) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return u.UnmarshalJSONResult(value, true)
}

func (u *Type) UnmarshalJSONString(data string) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return u.UnmarshalJSONResult(value, false)
}

func (u *Type) UnmarshalJSONStringStrict(data string) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return u.UnmarshalJSONResult(value, true)
}

func (u *Type) UnmarshalJSONResult(value dj.Result, disallowUnknownFields bool) error {
	var seenType bool
	var seenPrimitive bool
	var seenOptional bool
	var seenList bool
	var seenSet bool
	var seenMap bool
	var seenReference bool
	var seenExternal bool
	var unknownFields []string
	iter, idx, err := value.ObjectIterator(0)
	if err != nil {
		return err
	}
	for iter.HasNext(value, idx) {
		var fieldKey, fieldValue dj.Result
		fieldKey, fieldValue, idx, err = iter.Next(value, idx)
		if err != nil {
			return err
		}
		switch fieldKey.Str {
		case "type":
			if seenType {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "Type", Field: "type"}
			}
			seenType = true
			u.typ, err = fieldValue.String()
			if err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "Type", Field: "type", Err: err})
			}
		case "primitive":
			if seenPrimitive {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "Type", Field: "primitive"}
			}
			seenPrimitive = true
			var unionVal PrimitiveType
			enumVal, err := fieldValue.String()
			if err != nil {
				return fmt.Errorf("field field Type[\"primitive\"]: %w", err)
			}
			unionVal = New_PrimitiveType(PrimitiveType_Value(enumVal))
			u.primitive = &unionVal
		case "optional":
			if seenOptional {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "Type", Field: "optional"}
			}
			seenOptional = true
			var unionVal OptionalType
			if err := unionVal.UnmarshalJSONResult(fieldValue, disallowUnknownFields); err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "Type", Field: "optional", Err: err})
			}
			u.optional = &unionVal
		case "list":
			if seenList {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "Type", Field: "list"}
			}
			seenList = true
			var unionVal ListType
			if err := unionVal.UnmarshalJSONResult(fieldValue, disallowUnknownFields); err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "Type", Field: "list", Err: err})
			}
			u.list = &unionVal
		case "set":
			if seenSet {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "Type", Field: "set"}
			}
			seenSet = true
			var unionVal SetType
			if err := unionVal.UnmarshalJSONResult(fieldValue, disallowUnknownFields); err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "Type", Field: "set", Err: err})
			}
			u.set = &unionVal
		case "map":
			if seenMap {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "Type", Field: "map"}
			}
			seenMap = true
			var unionVal MapType
			if err := unionVal.UnmarshalJSONResult(fieldValue, disallowUnknownFields); err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "Type", Field: "map", Err: err})
			}
			u.map_ = &unionVal
		case "reference":
			if seenReference {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "Type", Field: "reference"}
			}
			seenReference = true
			var unionVal TypeName
			if err := unionVal.UnmarshalJSONResult(fieldValue, disallowUnknownFields); err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "Type", Field: "reference", Err: err})
			}
			u.reference = &unionVal
		case "external":
			if seenExternal {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "Type", Field: "external"}
			}
			seenExternal = true
			var unionVal ExternalReference
			if err := unionVal.UnmarshalJSONResult(fieldValue, disallowUnknownFields); err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "Type", Field: "external", Err: err})
			}
			u.external = &unionVal
		default:
			if disallowUnknownFields {
				unknownFields = append(unknownFields, fieldKey.Str)
			}
		}
	}
	var missingFields []string
	if !seenType {
		missingFields = append(missingFields, "type")
	}
	if u.typ == "primitive" && !seenPrimitive {
		missingFields = append(missingFields, "primitive")
	}
	if u.typ == "optional" && !seenOptional {
		missingFields = append(missingFields, "optional")
	}
	if u.typ == "list" && !seenList {
		missingFields = append(missingFields, "list")
	}
	if u.typ == "set" && !seenSet {
		missingFields = append(missingFields, "set")
	}
	if u.typ == "map" && !seenMap {
		missingFields = append(missingFields, "map")
	}
	if u.typ == "reference" && !seenReference {
		missingFields = append(missingFields, "reference")
	}
	if u.typ == "external" && !seenExternal {
		missingFields = append(missingFields, "external")
	}
	if len(missingFields) > 0 {
		return werror.Convert(dj.UnmarshalMissingFieldsError{Index: value.Index, Type: "Type", Fields: missingFields})
	}
	if disallowUnknownFields && len(unknownFields) > 0 {
		return werror.Convert(dj.UnmarshalUnknownFieldsError{Index: value.Index, Type: "Type", Fields: unknownFields})
	}
	return nil
}

func (u Type) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Type) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Type) AcceptFuncs(primitiveFunc func(PrimitiveType) error, optionalFunc func(OptionalType) error, listFunc func(ListType) error, setFunc func(SetType) error, map_Func func(MapType) error, referenceFunc func(TypeName) error, externalFunc func(ExternalReference) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "primitive":
		if u.primitive == nil {
			return fmt.Errorf("field \"primitive\" is required")
		}
		return primitiveFunc(*u.primitive)
	case "optional":
		if u.optional == nil {
			return fmt.Errorf("field \"optional\" is required")
		}
		return optionalFunc(*u.optional)
	case "list":
		if u.list == nil {
			return fmt.Errorf("field \"list\" is required")
		}
		return listFunc(*u.list)
	case "set":
		if u.set == nil {
			return fmt.Errorf("field \"set\" is required")
		}
		return setFunc(*u.set)
	case "map":
		if u.map_ == nil {
			return fmt.Errorf("field \"map\" is required")
		}
		return map_Func(*u.map_)
	case "reference":
		if u.reference == nil {
			return fmt.Errorf("field \"reference\" is required")
		}
		return referenceFunc(*u.reference)
	case "external":
		if u.external == nil {
			return fmt.Errorf("field \"external\" is required")
		}
		return externalFunc(*u.external)
	}
}

func (u *Type) PrimitiveNoopSuccess(_ PrimitiveType) error {
	return nil
}

func (u *Type) OptionalNoopSuccess(_ OptionalType) error {
	return nil
}

func (u *Type) ListNoopSuccess(_ ListType) error {
	return nil
}

func (u *Type) SetNoopSuccess(_ SetType) error {
	return nil
}

func (u *Type) MapNoopSuccess(_ MapType) error {
	return nil
}

func (u *Type) ReferenceNoopSuccess(_ TypeName) error {
	return nil
}

func (u *Type) ExternalNoopSuccess(_ ExternalReference) error {
	return nil
}

func (u *Type) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Type) Accept(v TypeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "primitive":
		if u.primitive == nil {
			return fmt.Errorf("field \"primitive\" is required")
		}
		return v.VisitPrimitive(*u.primitive)
	case "optional":
		if u.optional == nil {
			return fmt.Errorf("field \"optional\" is required")
		}
		return v.VisitOptional(*u.optional)
	case "list":
		if u.list == nil {
			return fmt.Errorf("field \"list\" is required")
		}
		return v.VisitList(*u.list)
	case "set":
		if u.set == nil {
			return fmt.Errorf("field \"set\" is required")
		}
		return v.VisitSet(*u.set)
	case "map":
		if u.map_ == nil {
			return fmt.Errorf("field \"map\" is required")
		}
		return v.VisitMap(*u.map_)
	case "reference":
		if u.reference == nil {
			return fmt.Errorf("field \"reference\" is required")
		}
		return v.VisitReference(*u.reference)
	case "external":
		if u.external == nil {
			return fmt.Errorf("field \"external\" is required")
		}
		return v.VisitExternal(*u.external)
	}
}

type TypeVisitor interface {
	VisitPrimitive(v PrimitiveType) error
	VisitOptional(v OptionalType) error
	VisitList(v ListType) error
	VisitSet(v SetType) error
	VisitMap(v MapType) error
	VisitReference(v TypeName) error
	VisitExternal(v ExternalReference) error
	VisitUnknown(typeName string) error
}

func (u *Type) AcceptWithContext(ctx context.Context, v TypeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "primitive":
		if u.primitive == nil {
			return fmt.Errorf("field \"primitive\" is required")
		}
		return v.VisitPrimitiveWithContext(ctx, *u.primitive)
	case "optional":
		if u.optional == nil {
			return fmt.Errorf("field \"optional\" is required")
		}
		return v.VisitOptionalWithContext(ctx, *u.optional)
	case "list":
		if u.list == nil {
			return fmt.Errorf("field \"list\" is required")
		}
		return v.VisitListWithContext(ctx, *u.list)
	case "set":
		if u.set == nil {
			return fmt.Errorf("field \"set\" is required")
		}
		return v.VisitSetWithContext(ctx, *u.set)
	case "map":
		if u.map_ == nil {
			return fmt.Errorf("field \"map\" is required")
		}
		return v.VisitMapWithContext(ctx, *u.map_)
	case "reference":
		if u.reference == nil {
			return fmt.Errorf("field \"reference\" is required")
		}
		return v.VisitReferenceWithContext(ctx, *u.reference)
	case "external":
		if u.external == nil {
			return fmt.Errorf("field \"external\" is required")
		}
		return v.VisitExternalWithContext(ctx, *u.external)
	}
}

type TypeVisitorWithContext interface {
	VisitPrimitiveWithContext(ctx context.Context, v PrimitiveType) error
	VisitOptionalWithContext(ctx context.Context, v OptionalType) error
	VisitListWithContext(ctx context.Context, v ListType) error
	VisitSetWithContext(ctx context.Context, v SetType) error
	VisitMapWithContext(ctx context.Context, v MapType) error
	VisitReferenceWithContext(ctx context.Context, v TypeName) error
	VisitExternalWithContext(ctx context.Context, v ExternalReference) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewTypeFromPrimitive(v PrimitiveType) Type {
	return Type{typ: "primitive", primitive: &v}
}

func NewTypeFromOptional(v OptionalType) Type {
	return Type{typ: "optional", optional: &v}
}

func NewTypeFromList(v ListType) Type {
	return Type{typ: "list", list: &v}
}

func NewTypeFromSet(v SetType) Type {
	return Type{typ: "set", set: &v}
}

func NewTypeFromMap(v MapType) Type {
	return Type{typ: "map", map_: &v}
}

func NewTypeFromReference(v TypeName) Type {
	return Type{typ: "reference", reference: &v}
}

func NewTypeFromExternal(v ExternalReference) Type {
	return Type{typ: "external", external: &v}
}

type TypeDefinition struct {
	typ    string
	alias  *AliasDefinition
	enum   *EnumDefinition
	object *ObjectDefinition
	union  *UnionDefinition
}

func (u TypeDefinition) MarshalJSON() ([]byte, error) {
	out := make([]byte, 0)
	if _, err := u.WriteJSON(dj.NewAppender(&out)); err != nil {
		return nil, err
	}
	return out, dj.Valid(out)
}

func (u TypeDefinition) WriteJSON(w io.Writer) (int, error) {
	var out int
	if n, err := dj.WriteOpenObject(w); err != nil {
		return 0, err
	} else {
		out += n
	}
	switch u.typ {
	case "alias":
		if n, err := dj.WriteLiteral(w, "\"type\":\"alias\""); err != nil {
			return 0, err
		} else {
			out += n
		}
		if u.alias != nil {
			if n, err := dj.WriteLiteral(w, ",\"alias\":"); err != nil {
				return 0, err
			} else {
				out += n
			}
			unionVal := *u.alias
			if n, err := unionVal.WriteJSON(w); err != nil {
				return 0, err
			} else {
				out += n
			}
		}
	case "enum":
		if n, err := dj.WriteLiteral(w, "\"type\":\"enum\""); err != nil {
			return 0, err
		} else {
			out += n
		}
		if u.enum != nil {
			if n, err := dj.WriteLiteral(w, ",\"enum\":"); err != nil {
				return 0, err
			} else {
				out += n
			}
			unionVal := *u.enum
			if n, err := unionVal.WriteJSON(w); err != nil {
				return 0, err
			} else {
				out += n
			}
		}
	case "object":
		if n, err := dj.WriteLiteral(w, "\"type\":\"object\""); err != nil {
			return 0, err
		} else {
			out += n
		}
		if u.object != nil {
			if n, err := dj.WriteLiteral(w, ",\"object\":"); err != nil {
				return 0, err
			} else {
				out += n
			}
			unionVal := *u.object
			if n, err := unionVal.WriteJSON(w); err != nil {
				return 0, err
			} else {
				out += n
			}
		}
	case "union":
		if n, err := dj.WriteLiteral(w, "\"type\":\"union\""); err != nil {
			return 0, err
		} else {
			out += n
		}
		if u.union != nil {
			if n, err := dj.WriteLiteral(w, ",\"union\":"); err != nil {
				return 0, err
			} else {
				out += n
			}
			unionVal := *u.union
			if n, err := unionVal.WriteJSON(w); err != nil {
				return 0, err
			} else {
				out += n
			}
		}
	default:
		if n, err := dj.WriteLiteral(w, "\"type\":"); err != nil {
			return 0, err
		} else {
			out += n
		}
		if n, err := dj.WriteString(w, (u.typ)); err != nil {
			return 0, err
		} else {
			out += n
		}
	}
	if n, err := dj.WriteCloseObject(w); err != nil {
		return 0, err
	} else {
		out += n
	}
	return out, nil
}

func (u *TypeDefinition) UnmarshalJSON(data []byte) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return u.UnmarshalJSONResult(value, false)
}

func (u *TypeDefinition) UnmarshalJSONStrict(data []byte) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return u.UnmarshalJSONResult(value, true)
}

func (u *TypeDefinition) UnmarshalJSONString(data string) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return u.UnmarshalJSONResult(value, false)
}

func (u *TypeDefinition) UnmarshalJSONStringStrict(data string) error {
	value, err := dj.Parse(data)
	if err != nil {
		return err
	}
	return u.UnmarshalJSONResult(value, true)
}

func (u *TypeDefinition) UnmarshalJSONResult(value dj.Result, disallowUnknownFields bool) error {
	var seenType bool
	var seenAlias bool
	var seenEnum bool
	var seenObject bool
	var seenUnion bool
	var unknownFields []string
	iter, idx, err := value.ObjectIterator(0)
	if err != nil {
		return err
	}
	for iter.HasNext(value, idx) {
		var fieldKey, fieldValue dj.Result
		fieldKey, fieldValue, idx, err = iter.Next(value, idx)
		if err != nil {
			return err
		}
		switch fieldKey.Str {
		case "type":
			if seenType {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "TypeDefinition", Field: "type"}
			}
			seenType = true
			u.typ, err = fieldValue.String()
			if err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "TypeDefinition", Field: "type", Err: err})
			}
		case "alias":
			if seenAlias {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "TypeDefinition", Field: "alias"}
			}
			seenAlias = true
			var unionVal AliasDefinition
			if err := unionVal.UnmarshalJSONResult(fieldValue, disallowUnknownFields); err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "TypeDefinition", Field: "alias", Err: err})
			}
			u.alias = &unionVal
		case "enum":
			if seenEnum {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "TypeDefinition", Field: "enum"}
			}
			seenEnum = true
			var unionVal EnumDefinition
			if err := unionVal.UnmarshalJSONResult(fieldValue, disallowUnknownFields); err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "TypeDefinition", Field: "enum", Err: err})
			}
			u.enum = &unionVal
		case "object":
			if seenObject {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "TypeDefinition", Field: "object"}
			}
			seenObject = true
			var unionVal ObjectDefinition
			if err := unionVal.UnmarshalJSONResult(fieldValue, disallowUnknownFields); err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "TypeDefinition", Field: "object", Err: err})
			}
			u.object = &unionVal
		case "union":
			if seenUnion {
				return dj.UnmarshalDuplicateFieldError{Index: fieldKey.Index, Type: "TypeDefinition", Field: "union"}
			}
			seenUnion = true
			var unionVal UnionDefinition
			if err := unionVal.UnmarshalJSONResult(fieldValue, disallowUnknownFields); err != nil {
				return werror.Convert(dj.UnmarshalFieldError{Index: fieldValue.Index, Type: "TypeDefinition", Field: "union", Err: err})
			}
			u.union = &unionVal
		default:
			if disallowUnknownFields {
				unknownFields = append(unknownFields, fieldKey.Str)
			}
		}
	}
	var missingFields []string
	if !seenType {
		missingFields = append(missingFields, "type")
	}
	if u.typ == "alias" && !seenAlias {
		missingFields = append(missingFields, "alias")
	}
	if u.typ == "enum" && !seenEnum {
		missingFields = append(missingFields, "enum")
	}
	if u.typ == "object" && !seenObject {
		missingFields = append(missingFields, "object")
	}
	if u.typ == "union" && !seenUnion {
		missingFields = append(missingFields, "union")
	}
	if len(missingFields) > 0 {
		return werror.Convert(dj.UnmarshalMissingFieldsError{Index: value.Index, Type: "TypeDefinition", Fields: missingFields})
	}
	if disallowUnknownFields && len(unknownFields) > 0 {
		return werror.Convert(dj.UnmarshalUnknownFieldsError{Index: value.Index, Type: "TypeDefinition", Fields: unknownFields})
	}
	return nil
}

func (u TypeDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *TypeDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *TypeDefinition) AcceptFuncs(aliasFunc func(AliasDefinition) error, enumFunc func(EnumDefinition) error, objectFunc func(ObjectDefinition) error, unionFunc func(UnionDefinition) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "alias":
		if u.alias == nil {
			return fmt.Errorf("field \"alias\" is required")
		}
		return aliasFunc(*u.alias)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	case "object":
		if u.object == nil {
			return fmt.Errorf("field \"object\" is required")
		}
		return objectFunc(*u.object)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return unionFunc(*u.union)
	}
}

func (u *TypeDefinition) AliasNoopSuccess(_ AliasDefinition) error {
	return nil
}

func (u *TypeDefinition) EnumNoopSuccess(_ EnumDefinition) error {
	return nil
}

func (u *TypeDefinition) ObjectNoopSuccess(_ ObjectDefinition) error {
	return nil
}

func (u *TypeDefinition) UnionNoopSuccess(_ UnionDefinition) error {
	return nil
}

func (u *TypeDefinition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *TypeDefinition) Accept(v TypeDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "alias":
		if u.alias == nil {
			return fmt.Errorf("field \"alias\" is required")
		}
		return v.VisitAlias(*u.alias)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(*u.enum)
	case "object":
		if u.object == nil {
			return fmt.Errorf("field \"object\" is required")
		}
		return v.VisitObject(*u.object)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnion(*u.union)
	}
}

type TypeDefinitionVisitor interface {
	VisitAlias(v AliasDefinition) error
	VisitEnum(v EnumDefinition) error
	VisitObject(v ObjectDefinition) error
	VisitUnion(v UnionDefinition) error
	VisitUnknown(typeName string) error
}

func (u *TypeDefinition) AcceptWithContext(ctx context.Context, v TypeDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "alias":
		if u.alias == nil {
			return fmt.Errorf("field \"alias\" is required")
		}
		return v.VisitAliasWithContext(ctx, *u.alias)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnumWithContext(ctx, *u.enum)
	case "object":
		if u.object == nil {
			return fmt.Errorf("field \"object\" is required")
		}
		return v.VisitObjectWithContext(ctx, *u.object)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnionWithContext(ctx, *u.union)
	}
}

type TypeDefinitionVisitorWithContext interface {
	VisitAliasWithContext(ctx context.Context, v AliasDefinition) error
	VisitEnumWithContext(ctx context.Context, v EnumDefinition) error
	VisitObjectWithContext(ctx context.Context, v ObjectDefinition) error
	VisitUnionWithContext(ctx context.Context, v UnionDefinition) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewTypeDefinitionFromAlias(v AliasDefinition) TypeDefinition {
	return TypeDefinition{typ: "alias", alias: &v}
}

func NewTypeDefinitionFromEnum(v EnumDefinition) TypeDefinition {
	return TypeDefinition{typ: "enum", enum: &v}
}

func NewTypeDefinitionFromObject(v ObjectDefinition) TypeDefinition {
	return TypeDefinition{typ: "object", object: &v}
}

func NewTypeDefinitionFromUnion(v UnionDefinition) TypeDefinition {
	return TypeDefinition{typ: "union", union: &v}
}
