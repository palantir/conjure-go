// This file was generated by Conjure and should not be manually edited.

package spec

import (
	"context"
	"fmt"

	safejson "github.com/palantir/pkg/safejson"
)

type AuthType struct {
	typ    string
	header *HeaderAuthType
	cookie *CookieAuthType
}

type authTypeDeserializer struct {
	Type   string          `json:"type"`
	Header *HeaderAuthType `json:"header"`
	Cookie *CookieAuthType `json:"cookie"`
}

func (u *authTypeDeserializer) toStruct() AuthType {
	return AuthType{typ: u.Type, header: u.Header, cookie: u.Cookie}
}

func (u AuthType) MarshalJSON() ([]byte, error) {
	return u.AppendJSON(nil)
}

func (u AuthType) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	switch u.typ {
	default:
		out = append(out, "\"type\":"...)
		out = safejson.AppendQuotedString(out, u.typ)
	case "header":
		out = append(out, "\"type\":\"header\""...)
		if u.header != nil {
			out = append(out, ',')
			out = append(out, "\"header\""...)
			out = append(out, ':')
			var err error
			out, err = u.header.AppendJSON(out)
			if err != nil {
				return nil, err
			}
		}
	case "cookie":
		out = append(out, "\"type\":\"cookie\""...)
		if u.cookie != nil {
			out = append(out, ',')
			out = append(out, "\"cookie\""...)
			out = append(out, ':')
			var err error
			out, err = u.cookie.AppendJSON(out)
			if err != nil {
				return nil, err
			}
		}
	}
	out = append(out, '}')
	return out, nil
}

func (u *AuthType) UnmarshalJSON(data []byte) error {
	var deser authTypeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	return nil
}

func (u *AuthType) AcceptFuncs(headerFunc func(HeaderAuthType) error, cookieFunc func(CookieAuthType) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "header":
		return headerFunc(*u.header)
	case "cookie":
		return cookieFunc(*u.cookie)
	}
}

func (u *AuthType) HeaderNoopSuccess(HeaderAuthType) error {
	return nil
}

func (u *AuthType) CookieNoopSuccess(CookieAuthType) error {
	return nil
}

func (u *AuthType) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *AuthType) Accept(v AuthTypeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "header":
		return v.VisitHeader(*u.header)
	case "cookie":
		return v.VisitCookie(*u.cookie)
	}
}

type AuthTypeVisitor interface {
	VisitHeader(HeaderAuthType) error
	VisitCookie(CookieAuthType) error
	VisitUnknown(typeName string) error
}

func (u *AuthType) AcceptWithContext(ctx context.Context, v AuthTypeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "header":
		return v.VisitHeaderWithContext(ctx, *u.header)
	case "cookie":
		return v.VisitCookieWithContext(ctx, *u.cookie)
	}
}

type AuthTypeVisitorWithContext interface {
	VisitHeaderWithContext(context.Context, HeaderAuthType) error
	VisitCookieWithContext(context.Context, CookieAuthType) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewAuthTypeFromHeader(v HeaderAuthType) AuthType {
	return AuthType{typ: "header", header: &v}
}

func NewAuthTypeFromCookie(v CookieAuthType) AuthType {
	return AuthType{typ: "cookie", cookie: &v}
}

type ParameterType struct {
	typ    string
	body   *BodyParameterType
	header *HeaderParameterType
	path   *PathParameterType
	query  *QueryParameterType
}

type parameterTypeDeserializer struct {
	Type   string               `json:"type"`
	Body   *BodyParameterType   `json:"body"`
	Header *HeaderParameterType `json:"header"`
	Path   *PathParameterType   `json:"path"`
	Query  *QueryParameterType  `json:"query"`
}

func (u *parameterTypeDeserializer) toStruct() ParameterType {
	return ParameterType{typ: u.Type, body: u.Body, header: u.Header, path: u.Path, query: u.Query}
}

func (u ParameterType) MarshalJSON() ([]byte, error) {
	return u.AppendJSON(nil)
}

func (u ParameterType) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	switch u.typ {
	default:
		out = append(out, "\"type\":"...)
		out = safejson.AppendQuotedString(out, u.typ)
	case "body":
		out = append(out, "\"type\":\"body\""...)
		if u.body != nil {
			out = append(out, ',')
			out = append(out, "\"body\""...)
			out = append(out, ':')
			var err error
			out, err = u.body.AppendJSON(out)
			if err != nil {
				return nil, err
			}
		}
	case "header":
		out = append(out, "\"type\":\"header\""...)
		if u.header != nil {
			out = append(out, ',')
			out = append(out, "\"header\""...)
			out = append(out, ':')
			var err error
			out, err = u.header.AppendJSON(out)
			if err != nil {
				return nil, err
			}
		}
	case "path":
		out = append(out, "\"type\":\"path\""...)
		if u.path != nil {
			out = append(out, ',')
			out = append(out, "\"path\""...)
			out = append(out, ':')
			var err error
			out, err = u.path.AppendJSON(out)
			if err != nil {
				return nil, err
			}
		}
	case "query":
		out = append(out, "\"type\":\"query\""...)
		if u.query != nil {
			out = append(out, ',')
			out = append(out, "\"query\""...)
			out = append(out, ':')
			var err error
			out, err = u.query.AppendJSON(out)
			if err != nil {
				return nil, err
			}
		}
	}
	out = append(out, '}')
	return out, nil
}

func (u *ParameterType) UnmarshalJSON(data []byte) error {
	var deser parameterTypeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	return nil
}

func (u *ParameterType) AcceptFuncs(bodyFunc func(BodyParameterType) error, headerFunc func(HeaderParameterType) error, pathFunc func(PathParameterType) error, queryFunc func(QueryParameterType) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "body":
		return bodyFunc(*u.body)
	case "header":
		return headerFunc(*u.header)
	case "path":
		return pathFunc(*u.path)
	case "query":
		return queryFunc(*u.query)
	}
}

func (u *ParameterType) BodyNoopSuccess(BodyParameterType) error {
	return nil
}

func (u *ParameterType) HeaderNoopSuccess(HeaderParameterType) error {
	return nil
}

func (u *ParameterType) PathNoopSuccess(PathParameterType) error {
	return nil
}

func (u *ParameterType) QueryNoopSuccess(QueryParameterType) error {
	return nil
}

func (u *ParameterType) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ParameterType) Accept(v ParameterTypeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "body":
		return v.VisitBody(*u.body)
	case "header":
		return v.VisitHeader(*u.header)
	case "path":
		return v.VisitPath(*u.path)
	case "query":
		return v.VisitQuery(*u.query)
	}
}

type ParameterTypeVisitor interface {
	VisitBody(BodyParameterType) error
	VisitHeader(HeaderParameterType) error
	VisitPath(PathParameterType) error
	VisitQuery(QueryParameterType) error
	VisitUnknown(typeName string) error
}

func (u *ParameterType) AcceptWithContext(ctx context.Context, v ParameterTypeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "body":
		return v.VisitBodyWithContext(ctx, *u.body)
	case "header":
		return v.VisitHeaderWithContext(ctx, *u.header)
	case "path":
		return v.VisitPathWithContext(ctx, *u.path)
	case "query":
		return v.VisitQueryWithContext(ctx, *u.query)
	}
}

type ParameterTypeVisitorWithContext interface {
	VisitBodyWithContext(context.Context, BodyParameterType) error
	VisitHeaderWithContext(context.Context, HeaderParameterType) error
	VisitPathWithContext(context.Context, PathParameterType) error
	VisitQueryWithContext(context.Context, QueryParameterType) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewParameterTypeFromBody(v BodyParameterType) ParameterType {
	return ParameterType{typ: "body", body: &v}
}

func NewParameterTypeFromHeader(v HeaderParameterType) ParameterType {
	return ParameterType{typ: "header", header: &v}
}

func NewParameterTypeFromPath(v PathParameterType) ParameterType {
	return ParameterType{typ: "path", path: &v}
}

func NewParameterTypeFromQuery(v QueryParameterType) ParameterType {
	return ParameterType{typ: "query", query: &v}
}

type Type struct {
	typ       string
	primitive *PrimitiveType
	optional  *OptionalType
	list      *ListType
	set       *SetType
	map_      *MapType
	reference *TypeName
	external  *ExternalReference
}

type typeDeserializer struct {
	Type      string             `json:"type"`
	Primitive *PrimitiveType     `json:"primitive"`
	Optional  *OptionalType      `json:"optional"`
	List      *ListType          `json:"list"`
	Set       *SetType           `json:"set"`
	Map       *MapType           `json:"map"`
	Reference *TypeName          `json:"reference"`
	External  *ExternalReference `json:"external"`
}

func (u *typeDeserializer) toStruct() Type {
	return Type{typ: u.Type, primitive: u.Primitive, optional: u.Optional, list: u.List, set: u.Set, map_: u.Map, reference: u.Reference, external: u.External}
}

func (u Type) MarshalJSON() ([]byte, error) {
	return u.AppendJSON(nil)
}

func (u Type) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	switch u.typ {
	default:
		out = append(out, "\"type\":"...)
		out = safejson.AppendQuotedString(out, u.typ)
	case "primitive":
		out = append(out, "\"type\":\"primitive\""...)
		if u.primitive != nil {
			out = append(out, ',')
			out = append(out, "\"primitive\""...)
			out = append(out, ':')
			var err error
			out, err = u.primitive.AppendJSON(out)
			if err != nil {
				return nil, err
			}
		}
	case "optional":
		out = append(out, "\"type\":\"optional\""...)
		if u.optional != nil {
			out = append(out, ',')
			out = append(out, "\"optional\""...)
			out = append(out, ':')
			var err error
			out, err = u.optional.AppendJSON(out)
			if err != nil {
				return nil, err
			}
		}
	case "list":
		out = append(out, "\"type\":\"list\""...)
		if u.list != nil {
			out = append(out, ',')
			out = append(out, "\"list\""...)
			out = append(out, ':')
			var err error
			out, err = u.list.AppendJSON(out)
			if err != nil {
				return nil, err
			}
		}
	case "set":
		out = append(out, "\"type\":\"set\""...)
		if u.set != nil {
			out = append(out, ',')
			out = append(out, "\"set\""...)
			out = append(out, ':')
			var err error
			out, err = u.set.AppendJSON(out)
			if err != nil {
				return nil, err
			}
		}
	case "map":
		out = append(out, "\"type\":\"map\""...)
		if u.map_ != nil {
			out = append(out, ',')
			out = append(out, "\"map\""...)
			out = append(out, ':')
			var err error
			out, err = u.map_.AppendJSON(out)
			if err != nil {
				return nil, err
			}
		}
	case "reference":
		out = append(out, "\"type\":\"reference\""...)
		if u.reference != nil {
			out = append(out, ',')
			out = append(out, "\"reference\""...)
			out = append(out, ':')
			var err error
			out, err = u.reference.AppendJSON(out)
			if err != nil {
				return nil, err
			}
		}
	case "external":
		out = append(out, "\"type\":\"external\""...)
		if u.external != nil {
			out = append(out, ',')
			out = append(out, "\"external\""...)
			out = append(out, ':')
			var err error
			out, err = u.external.AppendJSON(out)
			if err != nil {
				return nil, err
			}
		}
	}
	out = append(out, '}')
	return out, nil
}

func (u *Type) UnmarshalJSON(data []byte) error {
	var deser typeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	return nil
}

func (u *Type) AcceptFuncs(primitiveFunc func(PrimitiveType) error, optionalFunc func(OptionalType) error, listFunc func(ListType) error, setFunc func(SetType) error, map_Func func(MapType) error, referenceFunc func(TypeName) error, externalFunc func(ExternalReference) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "primitive":
		return primitiveFunc(*u.primitive)
	case "optional":
		return optionalFunc(*u.optional)
	case "list":
		return listFunc(*u.list)
	case "set":
		return setFunc(*u.set)
	case "map":
		return map_Func(*u.map_)
	case "reference":
		return referenceFunc(*u.reference)
	case "external":
		return externalFunc(*u.external)
	}
}

func (u *Type) PrimitiveNoopSuccess(PrimitiveType) error {
	return nil
}

func (u *Type) OptionalNoopSuccess(OptionalType) error {
	return nil
}

func (u *Type) ListNoopSuccess(ListType) error {
	return nil
}

func (u *Type) SetNoopSuccess(SetType) error {
	return nil
}

func (u *Type) MapNoopSuccess(MapType) error {
	return nil
}

func (u *Type) ReferenceNoopSuccess(TypeName) error {
	return nil
}

func (u *Type) ExternalNoopSuccess(ExternalReference) error {
	return nil
}

func (u *Type) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Type) Accept(v TypeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "primitive":
		return v.VisitPrimitive(*u.primitive)
	case "optional":
		return v.VisitOptional(*u.optional)
	case "list":
		return v.VisitList(*u.list)
	case "set":
		return v.VisitSet(*u.set)
	case "map":
		return v.VisitMap(*u.map_)
	case "reference":
		return v.VisitReference(*u.reference)
	case "external":
		return v.VisitExternal(*u.external)
	}
}

type TypeVisitor interface {
	VisitPrimitive(PrimitiveType) error
	VisitOptional(OptionalType) error
	VisitList(ListType) error
	VisitSet(SetType) error
	VisitMap(MapType) error
	VisitReference(TypeName) error
	VisitExternal(ExternalReference) error
	VisitUnknown(typeName string) error
}

func (u *Type) AcceptWithContext(ctx context.Context, v TypeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "primitive":
		return v.VisitPrimitiveWithContext(ctx, *u.primitive)
	case "optional":
		return v.VisitOptionalWithContext(ctx, *u.optional)
	case "list":
		return v.VisitListWithContext(ctx, *u.list)
	case "set":
		return v.VisitSetWithContext(ctx, *u.set)
	case "map":
		return v.VisitMapWithContext(ctx, *u.map_)
	case "reference":
		return v.VisitReferenceWithContext(ctx, *u.reference)
	case "external":
		return v.VisitExternalWithContext(ctx, *u.external)
	}
}

type TypeVisitorWithContext interface {
	VisitPrimitiveWithContext(context.Context, PrimitiveType) error
	VisitOptionalWithContext(context.Context, OptionalType) error
	VisitListWithContext(context.Context, ListType) error
	VisitSetWithContext(context.Context, SetType) error
	VisitMapWithContext(context.Context, MapType) error
	VisitReferenceWithContext(context.Context, TypeName) error
	VisitExternalWithContext(context.Context, ExternalReference) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewTypeFromPrimitive(v PrimitiveType) Type {
	return Type{typ: "primitive", primitive: &v}
}

func NewTypeFromOptional(v OptionalType) Type {
	return Type{typ: "optional", optional: &v}
}

func NewTypeFromList(v ListType) Type {
	return Type{typ: "list", list: &v}
}

func NewTypeFromSet(v SetType) Type {
	return Type{typ: "set", set: &v}
}

func NewTypeFromMap(v MapType) Type {
	return Type{typ: "map", map_: &v}
}

func NewTypeFromReference(v TypeName) Type {
	return Type{typ: "reference", reference: &v}
}

func NewTypeFromExternal(v ExternalReference) Type {
	return Type{typ: "external", external: &v}
}

type TypeDefinition struct {
	typ    string
	alias  *AliasDefinition
	enum   *EnumDefinition
	object *ObjectDefinition
	union  *UnionDefinition
}

type typeDefinitionDeserializer struct {
	Type   string            `json:"type"`
	Alias  *AliasDefinition  `json:"alias"`
	Enum   *EnumDefinition   `json:"enum"`
	Object *ObjectDefinition `json:"object"`
	Union  *UnionDefinition  `json:"union"`
}

func (u *typeDefinitionDeserializer) toStruct() TypeDefinition {
	return TypeDefinition{typ: u.Type, alias: u.Alias, enum: u.Enum, object: u.Object, union: u.Union}
}

func (u TypeDefinition) MarshalJSON() ([]byte, error) {
	return u.AppendJSON(nil)
}

func (u TypeDefinition) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	switch u.typ {
	default:
		out = append(out, "\"type\":"...)
		out = safejson.AppendQuotedString(out, u.typ)
	case "alias":
		out = append(out, "\"type\":\"alias\""...)
		if u.alias != nil {
			out = append(out, ',')
			out = append(out, "\"alias\""...)
			out = append(out, ':')
			var err error
			out, err = u.alias.AppendJSON(out)
			if err != nil {
				return nil, err
			}
		}
	case "enum":
		out = append(out, "\"type\":\"enum\""...)
		if u.enum != nil {
			out = append(out, ',')
			out = append(out, "\"enum\""...)
			out = append(out, ':')
			var err error
			out, err = u.enum.AppendJSON(out)
			if err != nil {
				return nil, err
			}
		}
	case "object":
		out = append(out, "\"type\":\"object\""...)
		if u.object != nil {
			out = append(out, ',')
			out = append(out, "\"object\""...)
			out = append(out, ':')
			var err error
			out, err = u.object.AppendJSON(out)
			if err != nil {
				return nil, err
			}
		}
	case "union":
		out = append(out, "\"type\":\"union\""...)
		if u.union != nil {
			out = append(out, ',')
			out = append(out, "\"union\""...)
			out = append(out, ':')
			var err error
			out, err = u.union.AppendJSON(out)
			if err != nil {
				return nil, err
			}
		}
	}
	out = append(out, '}')
	return out, nil
}

func (u *TypeDefinition) UnmarshalJSON(data []byte) error {
	var deser typeDefinitionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	return nil
}

func (u *TypeDefinition) AcceptFuncs(aliasFunc func(AliasDefinition) error, enumFunc func(EnumDefinition) error, objectFunc func(ObjectDefinition) error, unionFunc func(UnionDefinition) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "alias":
		return aliasFunc(*u.alias)
	case "enum":
		return enumFunc(*u.enum)
	case "object":
		return objectFunc(*u.object)
	case "union":
		return unionFunc(*u.union)
	}
}

func (u *TypeDefinition) AliasNoopSuccess(AliasDefinition) error {
	return nil
}

func (u *TypeDefinition) EnumNoopSuccess(EnumDefinition) error {
	return nil
}

func (u *TypeDefinition) ObjectNoopSuccess(ObjectDefinition) error {
	return nil
}

func (u *TypeDefinition) UnionNoopSuccess(UnionDefinition) error {
	return nil
}

func (u *TypeDefinition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *TypeDefinition) Accept(v TypeDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "alias":
		return v.VisitAlias(*u.alias)
	case "enum":
		return v.VisitEnum(*u.enum)
	case "object":
		return v.VisitObject(*u.object)
	case "union":
		return v.VisitUnion(*u.union)
	}
}

type TypeDefinitionVisitor interface {
	VisitAlias(AliasDefinition) error
	VisitEnum(EnumDefinition) error
	VisitObject(ObjectDefinition) error
	VisitUnion(UnionDefinition) error
	VisitUnknown(typeName string) error
}

func (u *TypeDefinition) AcceptWithContext(ctx context.Context, v TypeDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "alias":
		return v.VisitAliasWithContext(ctx, *u.alias)
	case "enum":
		return v.VisitEnumWithContext(ctx, *u.enum)
	case "object":
		return v.VisitObjectWithContext(ctx, *u.object)
	case "union":
		return v.VisitUnionWithContext(ctx, *u.union)
	}
}

type TypeDefinitionVisitorWithContext interface {
	VisitAliasWithContext(context.Context, AliasDefinition) error
	VisitEnumWithContext(context.Context, EnumDefinition) error
	VisitObjectWithContext(context.Context, ObjectDefinition) error
	VisitUnionWithContext(context.Context, UnionDefinition) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewTypeDefinitionFromAlias(v AliasDefinition) TypeDefinition {
	return TypeDefinition{typ: "alias", alias: &v}
}

func NewTypeDefinitionFromEnum(v EnumDefinition) TypeDefinition {
	return TypeDefinition{typ: "enum", enum: &v}
}

func NewTypeDefinitionFromObject(v ObjectDefinition) TypeDefinition {
	return TypeDefinition{typ: "object", object: &v}
}

func NewTypeDefinitionFromUnion(v UnionDefinition) TypeDefinition {
	return TypeDefinition{typ: "union", union: &v}
}
