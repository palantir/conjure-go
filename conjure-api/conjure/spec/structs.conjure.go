// This file was generated by Conjure and should not be manually edited.

package spec

import (
	"strconv"

	safejson "github.com/palantir/pkg/safejson"
)

type AliasDefinition struct {
	TypeName TypeName       `json:"typeName"`
	Alias    Type           `json:"alias"`
	Docs     *Documentation `json:"docs"`
}

func (o AliasDefinition) MarshalJSON() ([]byte, error) {
	return o.AppendJSON(nil)
}

func (o AliasDefinition) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	{
		out = append(out, "\"typeName\":"...)
		var err error
		out, err = o.TypeName.AppendJSON(out)
		if err != nil {
			return nil, err
		}
		out = append(out, ',')
	}
	{
		out = append(out, "\"alias\":"...)
		var err error
		out, err = o.Alias.AppendJSON(out)
		if err != nil {
			return nil, err
		}
		out = append(out, ',')
	}
	{
		out = append(out, "\"docs\":"...)
		if o.Docs != nil {
			optVal := *o.Docs
			var err error
			out, err = optVal.AppendJSON(out)
			if err != nil {
				return nil, err
			}
		} else {
			out = append(out, "null"...)
		}
	}
	out = append(out, '}')
	return out, nil
}

type ArgumentDefinition struct {
	ArgName   ArgumentName   `json:"argName"`
	Type      Type           `json:"type"`
	ParamType ParameterType  `json:"paramType"`
	Docs      *Documentation `json:"docs"`
	Markers   []Type         `json:"markers"`
	Tags      []string       `json:"tags"`
}

func (o ArgumentDefinition) MarshalJSON() ([]byte, error) {
	return o.AppendJSON(nil)
}

func (o ArgumentDefinition) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	{
		out = append(out, "\"argName\":"...)
		var err error
		out, err = o.ArgName.AppendJSON(out)
		if err != nil {
			return nil, err
		}
		out = append(out, ',')
	}
	{
		out = append(out, "\"type\":"...)
		var err error
		out, err = o.Type.AppendJSON(out)
		if err != nil {
			return nil, err
		}
		out = append(out, ',')
	}
	{
		out = append(out, "\"paramType\":"...)
		var err error
		out, err = o.ParamType.AppendJSON(out)
		if err != nil {
			return nil, err
		}
		out = append(out, ',')
	}
	{
		out = append(out, "\"docs\":"...)
		if o.Docs != nil {
			optVal := *o.Docs
			var err error
			out, err = optVal.AppendJSON(out)
			if err != nil {
				return nil, err
			}
		} else {
			out = append(out, "null"...)
		}
		out = append(out, ',')
	}
	{
		out = append(out, "\"markers\":"...)
		out = append(out, '[')
		{
			for i := range o.Markers {
				var err error
				out, err = o.Markers[i].AppendJSON(out)
				if err != nil {
					return nil, err
				}
				if i < len(o.Markers)-1 {
					out = append(out, ',')
				}
			}
		}
		out = append(out, ']')
		out = append(out, ',')
	}
	{
		out = append(out, "\"tags\":"...)
		out = append(out, '[')
		{
			for i := range o.Tags {
				out = safejson.AppendQuotedString(out, o.Tags[i])
				if i < len(o.Tags)-1 {
					out = append(out, ',')
				}
			}
		}
		out = append(out, ']')
	}
	out = append(out, '}')
	return out, nil
}

type BodyParameterType struct{}

func (o BodyParameterType) MarshalJSON() ([]byte, error) {
	return o.AppendJSON(nil)
}

func (o BodyParameterType) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	out = append(out, '}')
	return out, nil
}

type ConjureDefinition struct {
	Version    int                    `json:"version"`
	Errors     []ErrorDefinition      `json:"errors"`
	Types      []TypeDefinition       `json:"types"`
	Services   []ServiceDefinition    `json:"services"`
	Extensions map[string]interface{} `json:"extensions"`
}

func (o ConjureDefinition) MarshalJSON() ([]byte, error) {
	return o.AppendJSON(nil)
}

func (o ConjureDefinition) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	{
		out = append(out, "\"version\":"...)
		out = strconv.AppendInt(out, int64(o.Version), 10)
		out = append(out, ',')
	}
	{
		out = append(out, "\"errors\":"...)
		out = append(out, '[')
		{
			for i := range o.Errors {
				var err error
				out, err = o.Errors[i].AppendJSON(out)
				if err != nil {
					return nil, err
				}
				if i < len(o.Errors)-1 {
					out = append(out, ',')
				}
			}
		}
		out = append(out, ']')
		out = append(out, ',')
	}
	{
		out = append(out, "\"types\":"...)
		out = append(out, '[')
		{
			for i := range o.Types {
				var err error
				out, err = o.Types[i].AppendJSON(out)
				if err != nil {
					return nil, err
				}
				if i < len(o.Types)-1 {
					out = append(out, ',')
				}
			}
		}
		out = append(out, ']')
		out = append(out, ',')
	}
	{
		out = append(out, "\"services\":"...)
		out = append(out, '[')
		{
			for i := range o.Services {
				var err error
				out, err = o.Services[i].AppendJSON(out)
				if err != nil {
					return nil, err
				}
				if i < len(o.Services)-1 {
					out = append(out, ',')
				}
			}
		}
		out = append(out, ']')
		out = append(out, ',')
	}
	{
		out = append(out, "\"extensions\":"...)
		out = append(out, '{')
		{
			var i int
			for k, v := range o.Extensions {
				out = safejson.AppendQuotedString(out, k)
				out = append(out, ':')
				if v == nil {
					out = append(out, "null"...)
				} else if jsonBytes, err := safejson.Marshal(v); err != nil {
					return nil, err
				} else {
					out = append(out, jsonBytes...)
				}
				i++
				if i < len(o.Extensions) {
					out = append(out, ',')
				}
			}
		}
		out = append(out, '}')
	}
	out = append(out, '}')
	return out, nil
}

type CookieAuthType struct {
	CookieName string `json:"cookieName"`
}

func (o CookieAuthType) MarshalJSON() ([]byte, error) {
	return o.AppendJSON(nil)
}

func (o CookieAuthType) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	{
		out = append(out, "\"cookieName\":"...)
		out = safejson.AppendQuotedString(out, o.CookieName)
	}
	out = append(out, '}')
	return out, nil
}

type EndpointDefinition struct {
	EndpointName EndpointName         `json:"endpointName"`
	HttpMethod   HttpMethod           `json:"httpMethod"`
	HttpPath     HttpPath             `json:"httpPath"`
	Auth         *AuthType            `json:"auth"`
	Args         []ArgumentDefinition `json:"args"`
	Returns      *Type                `json:"returns"`
	Docs         *Documentation       `json:"docs"`
	Deprecated   *Documentation       `json:"deprecated"`
	Markers      []Type               `json:"markers"`
	Tags         []string             `json:"tags"`
}

func (o EndpointDefinition) MarshalJSON() ([]byte, error) {
	return o.AppendJSON(nil)
}

func (o EndpointDefinition) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	{
		out = append(out, "\"endpointName\":"...)
		var err error
		out, err = o.EndpointName.AppendJSON(out)
		if err != nil {
			return nil, err
		}
		out = append(out, ',')
	}
	{
		out = append(out, "\"httpMethod\":"...)
		out = safejson.AppendQuotedString(out, o.HttpMethod.String())
		out = append(out, ',')
	}
	{
		out = append(out, "\"httpPath\":"...)
		var err error
		out, err = o.HttpPath.AppendJSON(out)
		if err != nil {
			return nil, err
		}
		out = append(out, ',')
	}
	{
		out = append(out, "\"auth\":"...)
		if o.Auth != nil {
			optVal := *o.Auth
			var err error
			out, err = optVal.AppendJSON(out)
			if err != nil {
				return nil, err
			}
		} else {
			out = append(out, "null"...)
		}
		out = append(out, ',')
	}
	{
		out = append(out, "\"args\":"...)
		out = append(out, '[')
		{
			for i := range o.Args {
				var err error
				out, err = o.Args[i].AppendJSON(out)
				if err != nil {
					return nil, err
				}
				if i < len(o.Args)-1 {
					out = append(out, ',')
				}
			}
		}
		out = append(out, ']')
		out = append(out, ',')
	}
	{
		out = append(out, "\"returns\":"...)
		if o.Returns != nil {
			optVal := *o.Returns
			var err error
			out, err = optVal.AppendJSON(out)
			if err != nil {
				return nil, err
			}
		} else {
			out = append(out, "null"...)
		}
		out = append(out, ',')
	}
	{
		out = append(out, "\"docs\":"...)
		if o.Docs != nil {
			optVal := *o.Docs
			var err error
			out, err = optVal.AppendJSON(out)
			if err != nil {
				return nil, err
			}
		} else {
			out = append(out, "null"...)
		}
		out = append(out, ',')
	}
	{
		out = append(out, "\"deprecated\":"...)
		if o.Deprecated != nil {
			optVal := *o.Deprecated
			var err error
			out, err = optVal.AppendJSON(out)
			if err != nil {
				return nil, err
			}
		} else {
			out = append(out, "null"...)
		}
		out = append(out, ',')
	}
	{
		out = append(out, "\"markers\":"...)
		out = append(out, '[')
		{
			for i := range o.Markers {
				var err error
				out, err = o.Markers[i].AppendJSON(out)
				if err != nil {
					return nil, err
				}
				if i < len(o.Markers)-1 {
					out = append(out, ',')
				}
			}
		}
		out = append(out, ']')
		out = append(out, ',')
	}
	{
		out = append(out, "\"tags\":"...)
		out = append(out, '[')
		{
			for i := range o.Tags {
				out = safejson.AppendQuotedString(out, o.Tags[i])
				if i < len(o.Tags)-1 {
					out = append(out, ',')
				}
			}
		}
		out = append(out, ']')
	}
	out = append(out, '}')
	return out, nil
}

type EnumDefinition struct {
	TypeName TypeName              `json:"typeName"`
	Values   []EnumValueDefinition `json:"values"`
	Docs     *Documentation        `json:"docs"`
}

func (o EnumDefinition) MarshalJSON() ([]byte, error) {
	return o.AppendJSON(nil)
}

func (o EnumDefinition) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	{
		out = append(out, "\"typeName\":"...)
		var err error
		out, err = o.TypeName.AppendJSON(out)
		if err != nil {
			return nil, err
		}
		out = append(out, ',')
	}
	{
		out = append(out, "\"values\":"...)
		out = append(out, '[')
		{
			for i := range o.Values {
				var err error
				out, err = o.Values[i].AppendJSON(out)
				if err != nil {
					return nil, err
				}
				if i < len(o.Values)-1 {
					out = append(out, ',')
				}
			}
		}
		out = append(out, ']')
		out = append(out, ',')
	}
	{
		out = append(out, "\"docs\":"...)
		if o.Docs != nil {
			optVal := *o.Docs
			var err error
			out, err = optVal.AppendJSON(out)
			if err != nil {
				return nil, err
			}
		} else {
			out = append(out, "null"...)
		}
	}
	out = append(out, '}')
	return out, nil
}

type EnumValueDefinition struct {
	Value      string         `json:"value"`
	Docs       *Documentation `json:"docs"`
	Deprecated *Documentation `json:"deprecated"`
}

func (o EnumValueDefinition) MarshalJSON() ([]byte, error) {
	return o.AppendJSON(nil)
}

func (o EnumValueDefinition) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	{
		out = append(out, "\"value\":"...)
		out = safejson.AppendQuotedString(out, o.Value)
		out = append(out, ',')
	}
	{
		out = append(out, "\"docs\":"...)
		if o.Docs != nil {
			optVal := *o.Docs
			var err error
			out, err = optVal.AppendJSON(out)
			if err != nil {
				return nil, err
			}
		} else {
			out = append(out, "null"...)
		}
		out = append(out, ',')
	}
	{
		out = append(out, "\"deprecated\":"...)
		if o.Deprecated != nil {
			optVal := *o.Deprecated
			var err error
			out, err = optVal.AppendJSON(out)
			if err != nil {
				return nil, err
			}
		} else {
			out = append(out, "null"...)
		}
	}
	out = append(out, '}')
	return out, nil
}

type ErrorDefinition struct {
	ErrorName  TypeName          `json:"errorName"`
	Docs       *Documentation    `json:"docs"`
	Namespace  ErrorNamespace    `json:"namespace"`
	Code       ErrorCode         `json:"code"`
	SafeArgs   []FieldDefinition `json:"safeArgs"`
	UnsafeArgs []FieldDefinition `json:"unsafeArgs"`
}

func (o ErrorDefinition) MarshalJSON() ([]byte, error) {
	return o.AppendJSON(nil)
}

func (o ErrorDefinition) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	{
		out = append(out, "\"errorName\":"...)
		var err error
		out, err = o.ErrorName.AppendJSON(out)
		if err != nil {
			return nil, err
		}
		out = append(out, ',')
	}
	{
		out = append(out, "\"docs\":"...)
		if o.Docs != nil {
			optVal := *o.Docs
			var err error
			out, err = optVal.AppendJSON(out)
			if err != nil {
				return nil, err
			}
		} else {
			out = append(out, "null"...)
		}
		out = append(out, ',')
	}
	{
		out = append(out, "\"namespace\":"...)
		var err error
		out, err = o.Namespace.AppendJSON(out)
		if err != nil {
			return nil, err
		}
		out = append(out, ',')
	}
	{
		out = append(out, "\"code\":"...)
		out = safejson.AppendQuotedString(out, o.Code.String())
		out = append(out, ',')
	}
	{
		out = append(out, "\"safeArgs\":"...)
		out = append(out, '[')
		{
			for i := range o.SafeArgs {
				var err error
				out, err = o.SafeArgs[i].AppendJSON(out)
				if err != nil {
					return nil, err
				}
				if i < len(o.SafeArgs)-1 {
					out = append(out, ',')
				}
			}
		}
		out = append(out, ']')
		out = append(out, ',')
	}
	{
		out = append(out, "\"unsafeArgs\":"...)
		out = append(out, '[')
		{
			for i := range o.UnsafeArgs {
				var err error
				out, err = o.UnsafeArgs[i].AppendJSON(out)
				if err != nil {
					return nil, err
				}
				if i < len(o.UnsafeArgs)-1 {
					out = append(out, ',')
				}
			}
		}
		out = append(out, ']')
	}
	out = append(out, '}')
	return out, nil
}

type ExternalReference struct {
	// An identifier for a non-Conjure type which is already defined in a different language (e.g. Java).
	ExternalReference TypeName `conjure-docs:"An identifier for a non-Conjure type which is already defined in a different language (e.g. Java)." json:"externalReference"`
	// Other language generators may use the provided fallback if the non-Conjure type is not available. The ANY PrimitiveType is permissible for all external types, but a more specific definition is preferable.
	Fallback Type `conjure-docs:"Other language generators may use the provided fallback if the non-Conjure type is not available. The ANY PrimitiveType is permissible for all external types, but a more specific definition is preferable." json:"fallback"`
}

func (o ExternalReference) MarshalJSON() ([]byte, error) {
	return o.AppendJSON(nil)
}

func (o ExternalReference) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	{
		out = append(out, "\"externalReference\":"...)
		var err error
		out, err = o.ExternalReference.AppendJSON(out)
		if err != nil {
			return nil, err
		}
		out = append(out, ',')
	}
	{
		out = append(out, "\"fallback\":"...)
		var err error
		out, err = o.Fallback.AppendJSON(out)
		if err != nil {
			return nil, err
		}
	}
	out = append(out, '}')
	return out, nil
}

type FieldDefinition struct {
	FieldName  FieldName      `json:"fieldName"`
	Type       Type           `json:"type"`
	Docs       *Documentation `json:"docs"`
	Deprecated *Documentation `json:"deprecated"`
}

func (o FieldDefinition) MarshalJSON() ([]byte, error) {
	return o.AppendJSON(nil)
}

func (o FieldDefinition) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	{
		out = append(out, "\"fieldName\":"...)
		var err error
		out, err = o.FieldName.AppendJSON(out)
		if err != nil {
			return nil, err
		}
		out = append(out, ',')
	}
	{
		out = append(out, "\"type\":"...)
		var err error
		out, err = o.Type.AppendJSON(out)
		if err != nil {
			return nil, err
		}
		out = append(out, ',')
	}
	{
		out = append(out, "\"docs\":"...)
		if o.Docs != nil {
			optVal := *o.Docs
			var err error
			out, err = optVal.AppendJSON(out)
			if err != nil {
				return nil, err
			}
		} else {
			out = append(out, "null"...)
		}
		out = append(out, ',')
	}
	{
		out = append(out, "\"deprecated\":"...)
		if o.Deprecated != nil {
			optVal := *o.Deprecated
			var err error
			out, err = optVal.AppendJSON(out)
			if err != nil {
				return nil, err
			}
		} else {
			out = append(out, "null"...)
		}
	}
	out = append(out, '}')
	return out, nil
}

type HeaderAuthType struct{}

func (o HeaderAuthType) MarshalJSON() ([]byte, error) {
	return o.AppendJSON(nil)
}

func (o HeaderAuthType) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	out = append(out, '}')
	return out, nil
}

type HeaderParameterType struct {
	ParamId ParameterId `json:"paramId"`
}

func (o HeaderParameterType) MarshalJSON() ([]byte, error) {
	return o.AppendJSON(nil)
}

func (o HeaderParameterType) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	{
		out = append(out, "\"paramId\":"...)
		var err error
		out, err = o.ParamId.AppendJSON(out)
		if err != nil {
			return nil, err
		}
	}
	out = append(out, '}')
	return out, nil
}

type ListType struct {
	ItemType Type `json:"itemType"`
}

func (o ListType) MarshalJSON() ([]byte, error) {
	return o.AppendJSON(nil)
}

func (o ListType) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	{
		out = append(out, "\"itemType\":"...)
		var err error
		out, err = o.ItemType.AppendJSON(out)
		if err != nil {
			return nil, err
		}
	}
	out = append(out, '}')
	return out, nil
}

type MapType struct {
	KeyType   Type `json:"keyType"`
	ValueType Type `json:"valueType"`
}

func (o MapType) MarshalJSON() ([]byte, error) {
	return o.AppendJSON(nil)
}

func (o MapType) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	{
		out = append(out, "\"keyType\":"...)
		var err error
		out, err = o.KeyType.AppendJSON(out)
		if err != nil {
			return nil, err
		}
		out = append(out, ',')
	}
	{
		out = append(out, "\"valueType\":"...)
		var err error
		out, err = o.ValueType.AppendJSON(out)
		if err != nil {
			return nil, err
		}
	}
	out = append(out, '}')
	return out, nil
}

type ObjectDefinition struct {
	TypeName TypeName          `json:"typeName"`
	Fields   []FieldDefinition `json:"fields"`
	Docs     *Documentation    `json:"docs"`
}

func (o ObjectDefinition) MarshalJSON() ([]byte, error) {
	return o.AppendJSON(nil)
}

func (o ObjectDefinition) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	{
		out = append(out, "\"typeName\":"...)
		var err error
		out, err = o.TypeName.AppendJSON(out)
		if err != nil {
			return nil, err
		}
		out = append(out, ',')
	}
	{
		out = append(out, "\"fields\":"...)
		out = append(out, '[')
		{
			for i := range o.Fields {
				var err error
				out, err = o.Fields[i].AppendJSON(out)
				if err != nil {
					return nil, err
				}
				if i < len(o.Fields)-1 {
					out = append(out, ',')
				}
			}
		}
		out = append(out, ']')
		out = append(out, ',')
	}
	{
		out = append(out, "\"docs\":"...)
		if o.Docs != nil {
			optVal := *o.Docs
			var err error
			out, err = optVal.AppendJSON(out)
			if err != nil {
				return nil, err
			}
		} else {
			out = append(out, "null"...)
		}
	}
	out = append(out, '}')
	return out, nil
}

type OptionalType struct {
	ItemType Type `json:"itemType"`
}

func (o OptionalType) MarshalJSON() ([]byte, error) {
	return o.AppendJSON(nil)
}

func (o OptionalType) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	{
		out = append(out, "\"itemType\":"...)
		var err error
		out, err = o.ItemType.AppendJSON(out)
		if err != nil {
			return nil, err
		}
	}
	out = append(out, '}')
	return out, nil
}

type PathParameterType struct{}

func (o PathParameterType) MarshalJSON() ([]byte, error) {
	return o.AppendJSON(nil)
}

func (o PathParameterType) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	out = append(out, '}')
	return out, nil
}

type QueryParameterType struct {
	ParamId ParameterId `json:"paramId"`
}

func (o QueryParameterType) MarshalJSON() ([]byte, error) {
	return o.AppendJSON(nil)
}

func (o QueryParameterType) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	{
		out = append(out, "\"paramId\":"...)
		var err error
		out, err = o.ParamId.AppendJSON(out)
		if err != nil {
			return nil, err
		}
	}
	out = append(out, '}')
	return out, nil
}

type ServiceDefinition struct {
	ServiceName TypeName             `json:"serviceName"`
	Endpoints   []EndpointDefinition `json:"endpoints"`
	Docs        *Documentation       `json:"docs"`
}

func (o ServiceDefinition) MarshalJSON() ([]byte, error) {
	return o.AppendJSON(nil)
}

func (o ServiceDefinition) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	{
		out = append(out, "\"serviceName\":"...)
		var err error
		out, err = o.ServiceName.AppendJSON(out)
		if err != nil {
			return nil, err
		}
		out = append(out, ',')
	}
	{
		out = append(out, "\"endpoints\":"...)
		out = append(out, '[')
		{
			for i := range o.Endpoints {
				var err error
				out, err = o.Endpoints[i].AppendJSON(out)
				if err != nil {
					return nil, err
				}
				if i < len(o.Endpoints)-1 {
					out = append(out, ',')
				}
			}
		}
		out = append(out, ']')
		out = append(out, ',')
	}
	{
		out = append(out, "\"docs\":"...)
		if o.Docs != nil {
			optVal := *o.Docs
			var err error
			out, err = optVal.AppendJSON(out)
			if err != nil {
				return nil, err
			}
		} else {
			out = append(out, "null"...)
		}
	}
	out = append(out, '}')
	return out, nil
}

type SetType struct {
	ItemType Type `json:"itemType"`
}

func (o SetType) MarshalJSON() ([]byte, error) {
	return o.AppendJSON(nil)
}

func (o SetType) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	{
		out = append(out, "\"itemType\":"...)
		var err error
		out, err = o.ItemType.AppendJSON(out)
		if err != nil {
			return nil, err
		}
	}
	out = append(out, '}')
	return out, nil
}

type TypeName struct {
	// The name of the custom Conjure type or service. It must be in UpperCamelCase. Numbers are permitted, but not at the beginning of a word. Allowed names: "FooBar", "XYCoordinate", "Build2Request". Disallowed names: "fooBar", "2BuildRequest".
	Name string `conjure-docs:"The name of the custom Conjure type or service. It must be in UpperCamelCase. Numbers are permitted, but not at the beginning of a word. Allowed names: "FooBar", "XYCoordinate", "Build2Request". Disallowed names: "fooBar", "2BuildRequest"." json:"name"`
	// A period-delimited string of package names. The package names must be lowercase. Numbers are permitted, but not at the beginning of a package name. Allowed packages: "foo", "com.palantir.bar", "com.palantir.foo.thing2". Disallowed packages: "Foo", "com.palantir.foo.2thing".
	Package string `conjure-docs:"A period-delimited string of package names. The package names must be lowercase. Numbers are permitted, but not at the beginning of a package name. Allowed packages: "foo", "com.palantir.bar", "com.palantir.foo.thing2". Disallowed packages: "Foo", "com.palantir.foo.2thing"." json:"package"`
}

func (o TypeName) MarshalJSON() ([]byte, error) {
	return o.AppendJSON(nil)
}

func (o TypeName) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	{
		out = append(out, "\"name\":"...)
		out = safejson.AppendQuotedString(out, o.Name)
		out = append(out, ',')
	}
	{
		out = append(out, "\"package\":"...)
		out = safejson.AppendQuotedString(out, o.Package)
	}
	out = append(out, '}')
	return out, nil
}

type UnionDefinition struct {
	TypeName TypeName          `json:"typeName"`
	Union    []FieldDefinition `json:"union"`
	Docs     *Documentation    `json:"docs"`
}

func (o UnionDefinition) MarshalJSON() ([]byte, error) {
	return o.AppendJSON(nil)
}

func (o UnionDefinition) AppendJSON(out []byte) ([]byte, error) {
	out = append(out, '{')
	{
		out = append(out, "\"typeName\":"...)
		var err error
		out, err = o.TypeName.AppendJSON(out)
		if err != nil {
			return nil, err
		}
		out = append(out, ',')
	}
	{
		out = append(out, "\"union\":"...)
		out = append(out, '[')
		{
			for i := range o.Union {
				var err error
				out, err = o.Union[i].AppendJSON(out)
				if err != nil {
					return nil, err
				}
				if i < len(o.Union)-1 {
					out = append(out, ',')
				}
			}
		}
		out = append(out, ']')
		out = append(out, ',')
	}
	{
		out = append(out, "\"docs\":"...)
		if o.Docs != nil {
			optVal := *o.Docs
			var err error
			out, err = optVal.AppendJSON(out)
			if err != nil {
				return nil, err
			}
		} else {
			out = append(out, "null"...)
		}
	}
	out = append(out, '}')
	return out, nil
}
