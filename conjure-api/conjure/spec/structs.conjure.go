// This file was generated by Conjure and should not be manually edited.

package spec

import (
	"encoding/json"
)

type ConjureDefinition struct {
	Version  int                 `json:"version" yaml:"version,omitempty"`
	Errors   []ErrorDefinition   `json:"errors" yaml:"errors,omitempty"`
	Types    []TypeDefinition    `json:"types" yaml:"types,omitempty"`
	Services []ServiceDefinition `json:"services" yaml:"services,omitempty"`
}

func (o ConjureDefinition) MarshalJSON() ([]byte, error) {
	if o.Errors == nil {
		o.Errors = make([]ErrorDefinition, 0)
	}
	if o.Types == nil {
		o.Types = make([]TypeDefinition, 0)
	}
	if o.Services == nil {
		o.Services = make([]ServiceDefinition, 0)
	}
	type ConjureDefinitionAlias ConjureDefinition
	return json.Marshal(ConjureDefinitionAlias(o))
}

func (o *ConjureDefinition) UnmarshalJSON(data []byte) error {
	type ConjureDefinitionAlias ConjureDefinition
	var rawConjureDefinition ConjureDefinitionAlias
	if err := json.Unmarshal(data, &rawConjureDefinition); err != nil {
		return err
	}
	if rawConjureDefinition.Errors == nil {
		rawConjureDefinition.Errors = make([]ErrorDefinition, 0)
	}
	if rawConjureDefinition.Types == nil {
		rawConjureDefinition.Types = make([]TypeDefinition, 0)
	}
	if rawConjureDefinition.Services == nil {
		rawConjureDefinition.Services = make([]ServiceDefinition, 0)
	}
	*o = ConjureDefinition(rawConjureDefinition)
	return nil
}

func (o ConjureDefinition) MarshalYAML() (interface{}, error) {
	if o.Errors == nil {
		o.Errors = make([]ErrorDefinition, 0)
	}
	if o.Types == nil {
		o.Types = make([]TypeDefinition, 0)
	}
	if o.Services == nil {
		o.Services = make([]ServiceDefinition, 0)
	}
	type ConjureDefinitionAlias ConjureDefinition
	return ConjureDefinitionAlias(o), nil
}

func (o *ConjureDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	type ConjureDefinitionAlias ConjureDefinition
	var rawConjureDefinition ConjureDefinitionAlias
	if err := unmarshal(&rawConjureDefinition); err != nil {
		return err
	}
	if rawConjureDefinition.Errors == nil {
		rawConjureDefinition.Errors = make([]ErrorDefinition, 0)
	}
	if rawConjureDefinition.Types == nil {
		rawConjureDefinition.Types = make([]TypeDefinition, 0)
	}
	if rawConjureDefinition.Services == nil {
		rawConjureDefinition.Services = make([]ServiceDefinition, 0)
	}
	*o = ConjureDefinition(rawConjureDefinition)
	return nil
}

type TypeName struct {
	// The name of the custom Conjure type or service. It must be in UpperCamelCase. Numbers are permitted, but not at the beginning of a word. Allowed names: "FooBar", "XYCoordinate", "Build2Request". Disallowed names: "fooBar", "2BuildRequest".
	Name string `json:"name" yaml:"name,omitempty" conjure-docs:"The name of the custom Conjure type or service. It must be in UpperCamelCase. Numbers are permitted, but not at the beginning of a word. Allowed names: \"FooBar\", \"XYCoordinate\", \"Build2Request\". Disallowed names: \"fooBar\", \"2BuildRequest\".\n"`
	// A period-delimited string of package names. The package names must be lowercase. Numbers are permitted, but not at the beginning of a package name. Allowed packages: "foo", "com.palantir.bar", "com.palantir.foo.thing2". Disallowed packages: "Foo", "com.palantir.foo.2thing".
	Package string `json:"package" yaml:"package,omitempty" conjure-docs:"A period-delimited string of package names. The package names must be lowercase. Numbers are permitted, but not at the beginning of a package name. Allowed packages: \"foo\", \"com.palantir.bar\", \"com.palantir.foo.thing2\". Disallowed packages: \"Foo\", \"com.palantir.foo.2thing\".\n"`
}

type ErrorDefinition struct {
	ErrorName  TypeName          `json:"errorName" yaml:"errorName,omitempty"`
	Docs       *Documentation    `json:"docs" yaml:"docs,omitempty"`
	Namespace  ErrorNamespace    `json:"namespace" yaml:"namespace,omitempty"`
	Code       ErrorCode         `json:"code" yaml:"code,omitempty"`
	SafeArgs   []FieldDefinition `json:"safeArgs" yaml:"safeArgs,omitempty"`
	UnsafeArgs []FieldDefinition `json:"unsafeArgs" yaml:"unsafeArgs,omitempty"`
}

func (o ErrorDefinition) MarshalJSON() ([]byte, error) {
	if o.SafeArgs == nil {
		o.SafeArgs = make([]FieldDefinition, 0)
	}
	if o.UnsafeArgs == nil {
		o.UnsafeArgs = make([]FieldDefinition, 0)
	}
	type ErrorDefinitionAlias ErrorDefinition
	return json.Marshal(ErrorDefinitionAlias(o))
}

func (o *ErrorDefinition) UnmarshalJSON(data []byte) error {
	type ErrorDefinitionAlias ErrorDefinition
	var rawErrorDefinition ErrorDefinitionAlias
	if err := json.Unmarshal(data, &rawErrorDefinition); err != nil {
		return err
	}
	if rawErrorDefinition.SafeArgs == nil {
		rawErrorDefinition.SafeArgs = make([]FieldDefinition, 0)
	}
	if rawErrorDefinition.UnsafeArgs == nil {
		rawErrorDefinition.UnsafeArgs = make([]FieldDefinition, 0)
	}
	*o = ErrorDefinition(rawErrorDefinition)
	return nil
}

func (o ErrorDefinition) MarshalYAML() (interface{}, error) {
	if o.SafeArgs == nil {
		o.SafeArgs = make([]FieldDefinition, 0)
	}
	if o.UnsafeArgs == nil {
		o.UnsafeArgs = make([]FieldDefinition, 0)
	}
	type ErrorDefinitionAlias ErrorDefinition
	return ErrorDefinitionAlias(o), nil
}

func (o *ErrorDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	type ErrorDefinitionAlias ErrorDefinition
	var rawErrorDefinition ErrorDefinitionAlias
	if err := unmarshal(&rawErrorDefinition); err != nil {
		return err
	}
	if rawErrorDefinition.SafeArgs == nil {
		rawErrorDefinition.SafeArgs = make([]FieldDefinition, 0)
	}
	if rawErrorDefinition.UnsafeArgs == nil {
		rawErrorDefinition.UnsafeArgs = make([]FieldDefinition, 0)
	}
	*o = ErrorDefinition(rawErrorDefinition)
	return nil
}

type ExternalReference struct {
	// An identifier for a non-Conjure type which is already defined in a different language (e.g. Java).
	ExternalReference TypeName `json:"externalReference" yaml:"externalReference,omitempty" conjure-docs:"An identifier for a non-Conjure type which is already defined in a different language (e.g. Java)."`
	// Other language generators may use the provided fallback if the non-Conjure type is not available. The ANY PrimitiveType is permissible for all external types, but a more specific definition is preferrable.
	Fallback Type `json:"fallback" yaml:"fallback,omitempty" conjure-docs:"Other language generators may use the provided fallback if the non-Conjure type is not available. The ANY PrimitiveType is permissible for all external types, but a more specific definition is preferrable.\n"`
}

type OptionalType struct {
	ItemType Type `json:"itemType" yaml:"itemType,omitempty"`
}

type ListType struct {
	ItemType Type `json:"itemType" yaml:"itemType,omitempty"`
}

type SetType struct {
	ItemType Type `json:"itemType" yaml:"itemType,omitempty"`
}

type MapType struct {
	KeyType   Type `json:"keyType" yaml:"keyType,omitempty"`
	ValueType Type `json:"valueType" yaml:"valueType,omitempty"`
}

type AliasDefinition struct {
	TypeName TypeName       `json:"typeName" yaml:"typeName,omitempty"`
	Alias    Type           `json:"alias" yaml:"alias,omitempty"`
	Docs     *Documentation `json:"docs" yaml:"docs,omitempty"`
}

type EnumDefinition struct {
	TypeName TypeName              `json:"typeName" yaml:"typeName,omitempty"`
	Values   []EnumValueDefinition `json:"values" yaml:"values,omitempty"`
	Docs     *Documentation        `json:"docs" yaml:"docs,omitempty"`
}

func (o EnumDefinition) MarshalJSON() ([]byte, error) {
	if o.Values == nil {
		o.Values = make([]EnumValueDefinition, 0)
	}
	type EnumDefinitionAlias EnumDefinition
	return json.Marshal(EnumDefinitionAlias(o))
}

func (o *EnumDefinition) UnmarshalJSON(data []byte) error {
	type EnumDefinitionAlias EnumDefinition
	var rawEnumDefinition EnumDefinitionAlias
	if err := json.Unmarshal(data, &rawEnumDefinition); err != nil {
		return err
	}
	if rawEnumDefinition.Values == nil {
		rawEnumDefinition.Values = make([]EnumValueDefinition, 0)
	}
	*o = EnumDefinition(rawEnumDefinition)
	return nil
}

func (o EnumDefinition) MarshalYAML() (interface{}, error) {
	if o.Values == nil {
		o.Values = make([]EnumValueDefinition, 0)
	}
	type EnumDefinitionAlias EnumDefinition
	return EnumDefinitionAlias(o), nil
}

func (o *EnumDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	type EnumDefinitionAlias EnumDefinition
	var rawEnumDefinition EnumDefinitionAlias
	if err := unmarshal(&rawEnumDefinition); err != nil {
		return err
	}
	if rawEnumDefinition.Values == nil {
		rawEnumDefinition.Values = make([]EnumValueDefinition, 0)
	}
	*o = EnumDefinition(rawEnumDefinition)
	return nil
}

type ObjectDefinition struct {
	TypeName TypeName          `json:"typeName" yaml:"typeName,omitempty"`
	Fields   []FieldDefinition `json:"fields" yaml:"fields,omitempty"`
	Docs     *Documentation    `json:"docs" yaml:"docs,omitempty"`
}

func (o ObjectDefinition) MarshalJSON() ([]byte, error) {
	if o.Fields == nil {
		o.Fields = make([]FieldDefinition, 0)
	}
	type ObjectDefinitionAlias ObjectDefinition
	return json.Marshal(ObjectDefinitionAlias(o))
}

func (o *ObjectDefinition) UnmarshalJSON(data []byte) error {
	type ObjectDefinitionAlias ObjectDefinition
	var rawObjectDefinition ObjectDefinitionAlias
	if err := json.Unmarshal(data, &rawObjectDefinition); err != nil {
		return err
	}
	if rawObjectDefinition.Fields == nil {
		rawObjectDefinition.Fields = make([]FieldDefinition, 0)
	}
	*o = ObjectDefinition(rawObjectDefinition)
	return nil
}

func (o ObjectDefinition) MarshalYAML() (interface{}, error) {
	if o.Fields == nil {
		o.Fields = make([]FieldDefinition, 0)
	}
	type ObjectDefinitionAlias ObjectDefinition
	return ObjectDefinitionAlias(o), nil
}

func (o *ObjectDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	type ObjectDefinitionAlias ObjectDefinition
	var rawObjectDefinition ObjectDefinitionAlias
	if err := unmarshal(&rawObjectDefinition); err != nil {
		return err
	}
	if rawObjectDefinition.Fields == nil {
		rawObjectDefinition.Fields = make([]FieldDefinition, 0)
	}
	*o = ObjectDefinition(rawObjectDefinition)
	return nil
}

type UnionDefinition struct {
	TypeName TypeName          `json:"typeName" yaml:"typeName,omitempty"`
	Union    []FieldDefinition `json:"union" yaml:"union,omitempty"`
	Docs     *Documentation    `json:"docs" yaml:"docs,omitempty"`
}

func (o UnionDefinition) MarshalJSON() ([]byte, error) {
	if o.Union == nil {
		o.Union = make([]FieldDefinition, 0)
	}
	type UnionDefinitionAlias UnionDefinition
	return json.Marshal(UnionDefinitionAlias(o))
}

func (o *UnionDefinition) UnmarshalJSON(data []byte) error {
	type UnionDefinitionAlias UnionDefinition
	var rawUnionDefinition UnionDefinitionAlias
	if err := json.Unmarshal(data, &rawUnionDefinition); err != nil {
		return err
	}
	if rawUnionDefinition.Union == nil {
		rawUnionDefinition.Union = make([]FieldDefinition, 0)
	}
	*o = UnionDefinition(rawUnionDefinition)
	return nil
}

func (o UnionDefinition) MarshalYAML() (interface{}, error) {
	if o.Union == nil {
		o.Union = make([]FieldDefinition, 0)
	}
	type UnionDefinitionAlias UnionDefinition
	return UnionDefinitionAlias(o), nil
}

func (o *UnionDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	type UnionDefinitionAlias UnionDefinition
	var rawUnionDefinition UnionDefinitionAlias
	if err := unmarshal(&rawUnionDefinition); err != nil {
		return err
	}
	if rawUnionDefinition.Union == nil {
		rawUnionDefinition.Union = make([]FieldDefinition, 0)
	}
	*o = UnionDefinition(rawUnionDefinition)
	return nil
}

type EnumValueDefinition struct {
	Value string         `json:"value" yaml:"value,omitempty"`
	Docs  *Documentation `json:"docs" yaml:"docs,omitempty"`
}

type FieldDefinition struct {
	FieldName FieldName      `json:"fieldName" yaml:"fieldName,omitempty"`
	Type      Type           `json:"type" yaml:"type,omitempty"`
	Docs      *Documentation `json:"docs" yaml:"docs,omitempty"`
}

type ServiceDefinition struct {
	ServiceName TypeName             `json:"serviceName" yaml:"serviceName,omitempty"`
	Endpoints   []EndpointDefinition `json:"endpoints" yaml:"endpoints,omitempty"`
	Docs        *Documentation       `json:"docs" yaml:"docs,omitempty"`
}

func (o ServiceDefinition) MarshalJSON() ([]byte, error) {
	if o.Endpoints == nil {
		o.Endpoints = make([]EndpointDefinition, 0)
	}
	type ServiceDefinitionAlias ServiceDefinition
	return json.Marshal(ServiceDefinitionAlias(o))
}

func (o *ServiceDefinition) UnmarshalJSON(data []byte) error {
	type ServiceDefinitionAlias ServiceDefinition
	var rawServiceDefinition ServiceDefinitionAlias
	if err := json.Unmarshal(data, &rawServiceDefinition); err != nil {
		return err
	}
	if rawServiceDefinition.Endpoints == nil {
		rawServiceDefinition.Endpoints = make([]EndpointDefinition, 0)
	}
	*o = ServiceDefinition(rawServiceDefinition)
	return nil
}

func (o ServiceDefinition) MarshalYAML() (interface{}, error) {
	if o.Endpoints == nil {
		o.Endpoints = make([]EndpointDefinition, 0)
	}
	type ServiceDefinitionAlias ServiceDefinition
	return ServiceDefinitionAlias(o), nil
}

func (o *ServiceDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	type ServiceDefinitionAlias ServiceDefinition
	var rawServiceDefinition ServiceDefinitionAlias
	if err := unmarshal(&rawServiceDefinition); err != nil {
		return err
	}
	if rawServiceDefinition.Endpoints == nil {
		rawServiceDefinition.Endpoints = make([]EndpointDefinition, 0)
	}
	*o = ServiceDefinition(rawServiceDefinition)
	return nil
}

type EndpointDefinition struct {
	EndpointName EndpointName         `json:"endpointName" yaml:"endpointName,omitempty"`
	HttpMethod   HttpMethod           `json:"httpMethod" yaml:"httpMethod,omitempty"`
	HttpPath     HttpPath             `json:"httpPath" yaml:"httpPath,omitempty"`
	Auth         *AuthType            `json:"auth" yaml:"auth,omitempty"`
	Args         []ArgumentDefinition `json:"args" yaml:"args,omitempty"`
	Returns      *Type                `json:"returns" yaml:"returns,omitempty"`
	Docs         *Documentation       `json:"docs" yaml:"docs,omitempty"`
	Deprecated   *Documentation       `json:"deprecated" yaml:"deprecated,omitempty"`
	Markers      []Type               `json:"markers" yaml:"markers,omitempty"`
}

func (o EndpointDefinition) MarshalJSON() ([]byte, error) {
	if o.Args == nil {
		o.Args = make([]ArgumentDefinition, 0)
	}
	if o.Markers == nil {
		o.Markers = make([]Type, 0)
	}
	type EndpointDefinitionAlias EndpointDefinition
	return json.Marshal(EndpointDefinitionAlias(o))
}

func (o *EndpointDefinition) UnmarshalJSON(data []byte) error {
	type EndpointDefinitionAlias EndpointDefinition
	var rawEndpointDefinition EndpointDefinitionAlias
	if err := json.Unmarshal(data, &rawEndpointDefinition); err != nil {
		return err
	}
	if rawEndpointDefinition.Args == nil {
		rawEndpointDefinition.Args = make([]ArgumentDefinition, 0)
	}
	if rawEndpointDefinition.Markers == nil {
		rawEndpointDefinition.Markers = make([]Type, 0)
	}
	*o = EndpointDefinition(rawEndpointDefinition)
	return nil
}

func (o EndpointDefinition) MarshalYAML() (interface{}, error) {
	if o.Args == nil {
		o.Args = make([]ArgumentDefinition, 0)
	}
	if o.Markers == nil {
		o.Markers = make([]Type, 0)
	}
	type EndpointDefinitionAlias EndpointDefinition
	return EndpointDefinitionAlias(o), nil
}

func (o *EndpointDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	type EndpointDefinitionAlias EndpointDefinition
	var rawEndpointDefinition EndpointDefinitionAlias
	if err := unmarshal(&rawEndpointDefinition); err != nil {
		return err
	}
	if rawEndpointDefinition.Args == nil {
		rawEndpointDefinition.Args = make([]ArgumentDefinition, 0)
	}
	if rawEndpointDefinition.Markers == nil {
		rawEndpointDefinition.Markers = make([]Type, 0)
	}
	*o = EndpointDefinition(rawEndpointDefinition)
	return nil
}

type HeaderAuthType struct {
}

type CookieAuthType struct {
	CookieName string `json:"cookieName" yaml:"cookieName,omitempty"`
}

type ArgumentDefinition struct {
	ArgName   ArgumentName   `json:"argName" yaml:"argName,omitempty"`
	Type      Type           `json:"type" yaml:"type,omitempty"`
	ParamType ParameterType  `json:"paramType" yaml:"paramType,omitempty"`
	Docs      *Documentation `json:"docs" yaml:"docs,omitempty"`
	Markers   []Type         `json:"markers" yaml:"markers,omitempty"`
}

func (o ArgumentDefinition) MarshalJSON() ([]byte, error) {
	if o.Markers == nil {
		o.Markers = make([]Type, 0)
	}
	type ArgumentDefinitionAlias ArgumentDefinition
	return json.Marshal(ArgumentDefinitionAlias(o))
}

func (o *ArgumentDefinition) UnmarshalJSON(data []byte) error {
	type ArgumentDefinitionAlias ArgumentDefinition
	var rawArgumentDefinition ArgumentDefinitionAlias
	if err := json.Unmarshal(data, &rawArgumentDefinition); err != nil {
		return err
	}
	if rawArgumentDefinition.Markers == nil {
		rawArgumentDefinition.Markers = make([]Type, 0)
	}
	*o = ArgumentDefinition(rawArgumentDefinition)
	return nil
}

func (o ArgumentDefinition) MarshalYAML() (interface{}, error) {
	if o.Markers == nil {
		o.Markers = make([]Type, 0)
	}
	type ArgumentDefinitionAlias ArgumentDefinition
	return ArgumentDefinitionAlias(o), nil
}

func (o *ArgumentDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	type ArgumentDefinitionAlias ArgumentDefinition
	var rawArgumentDefinition ArgumentDefinitionAlias
	if err := unmarshal(&rawArgumentDefinition); err != nil {
		return err
	}
	if rawArgumentDefinition.Markers == nil {
		rawArgumentDefinition.Markers = make([]Type, 0)
	}
	*o = ArgumentDefinition(rawArgumentDefinition)
	return nil
}

type BodyParameterType struct {
}

type HeaderParameterType struct {
	ParamId ParameterId `json:"paramId" yaml:"paramId,omitempty"`
}

type PathParameterType struct {
}

type QueryParameterType struct {
	ParamId ParameterId `json:"paramId" yaml:"paramId,omitempty"`
}
